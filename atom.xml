<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>동글씨</title>
  
  <subtitle>동글씨의 LOG</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-17T09:30:11.889Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Suyan Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>네트워크-OSI모델, 물리계층과 데이터링크계층</title>
    <link href="http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI%EB%AA%A8%EB%8D%B8-%EB%AC%BC%EB%A6%AC%EA%B3%84%EC%B8%B5/"/>
    <id>http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI%EB%AA%A8%EB%8D%B8-%EB%AC%BC%EB%A6%AC%EA%B3%84%EC%B8%B5/</id>
    <published>2021-06-16T06:17:17.000Z</published>
    <updated>2021-06-17T09:30:11.889Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><blockquote><p>네트워크 프로토콜의 모음.<br><code>패킷 통신 방식</code>의 <code>IP</code>와<br><code>전송 조절 프로토콜</code>인 <code>TCP</code>로 이루어져 있다.</p></blockquote><ul><li><strong>TCP/IP &amp; OSI 7 Layer</strong></li></ul><table>    <thead>        <tr>            <th>TCP/IP</th>            <th>Service/Protocol</th>            <th>OSI 7Layer</th>        </tr>    </thead>    <tbody>        <tr>            <td rowspan=3>Application</td>            <td rowspan=3>HTTP, SMTP, DNS</td>            <td>Application</td>        </tr>        <tr>            <td>Presentaition</td>        </tr>        <tr>            <td>Session</td>        </tr>        <tr>          <td>Transport</td>          <td>TCP, UDP</td>          <td>Transport</td>        </tr>        <tr>          <td>Network</td>          <td>IP, ICMP, OSPF</td>          <td>Network</td>        </tr>        <tr>          <td rowspan=2>Network Interface</td>          <td rowspan=2>Ethernet</td>          <td>Data Link</td>        </tr>        <tr>          <td>Physical</td>        </tr>    </tbody></table><br><hr><h1 id="물리계층"><a href="#물리계층" class="headerlink" title="물리계층"></a>물리계층</h1><blockquote><p>OSI 7 Layer 1계층의 하드웨어</p></blockquote><ul><li>네트워크 장치의 <code>전기적, 기계적</code> 속성과 전송하는 수단</li><li><code>데이터 링크</code> 계층 프레임 –&gt; (bit를 Signal 로 인코딩) –&gt; <code>네트워크 장치</code>로 전송</li><li>통신 장치와 커넥터, 인코딩(Bit to Signal), 송수신을 담당하는 회로 등의 요소 포함</li><li>전송하는 수단인 Signaling(신호)은 전기, 광, 무선 등이 있다.</li></ul><h2 id="물리계층-장비"><a href="#물리계층-장비" class="headerlink" title="물리계층 장비"></a>물리계층 장비</h2><ul><li>허브 &amp; 리피터<ul><li>허프는 전기신호를 증폭하여 포트에 연결된 PC들끼리 통신이 가능</li><li>리피터는 현재 거의 쓰이지 않는다. 세기를 더 증폭하여 더 멀리까지 통신이 가능</li></ul></li></ul><h3 id="허브-동작방식"><a href="#허브-동작방식" class="headerlink" title="허브 동작방식"></a>허브 동작방식</h3><blockquote><p>허브는 <code>브로드캐스팅</code> 통신과 <code>CSMA/CD</code> 방식을 사용, <code>Half Duplex</code> 모드이다.</p></blockquote><ul><li>브로드캐스팅 1 : All</li><li>유니캐스트 1 : 1</li><li>멀티캐스트 1 : N</li></ul><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><blockquote><p>Carrier Sense Multiple Access / Collision Detection</p></blockquote><ol><li>Carrier Sensing: 데이터를 보내기 전에 다른 노드에서 데이터를 보내는 중인지 확인</li><li>Multiple Access: 데이터를 보내는곳이 없으면 전송</li><li>Collision Detection: 동시간대의 데이터 충돌 후 정지. 일정시간 이후 재동작</li></ol><h3 id="전송방식"><a href="#전송방식" class="headerlink" title="전송방식"></a>전송방식</h3><ol><li>Simplex: 단방향 통신으로 수신측은 송신척에 응답 불가</li><li>Half Duplex: 반이중 전송방식. 무전기.</li><li>Full Duplex: 전이중 전송방식. 전화기.</li></ol><h3 id="케이블-커넥터"><a href="#케이블-커넥터" class="headerlink" title="케이블/커넥터"></a>케이블/커넥터</h3><ul><li><code>TP</code>(Twisted Pair)<ul><li>총 8가닥의 선으로 구성. 두개의 선을 서로 꼬아놓음<ul><li>UTP(Unshield Twisted Pair), STP(Shielded Twisted Pair)</li></ul></li></ul></li><li><code>Coaxial</code>(동축)<ul><li>선 중앙에 심선있음. 전화 또는 회선망 등 사용</li></ul></li><li><code>Fiber</code>(광)  - 전기신호이 자기장이 없는 빛으로 통신하기 때문에 장거리 고속통신 가능<ul><li>모드(Single, Multi), 커넥터타입(LC, SC)</li></ul></li><li>광 트랜시버<ul><li>광통신에 사용되는 네트워크 인터페이스 모튤 커넥터<ul><li>SFP, GBIC 등</li></ul></li></ul></li></ul><h3 id="장비의-Capacity-성능"><a href="#장비의-Capacity-성능" class="headerlink" title="장비의 Capacity 성능"></a>장비의 Capacity 성능</h3><ul><li><strong>Bandwidth</strong>(대역폭)::8차선 도로<ul><li>주어진 시간대에 네트워크를 통해 이동가능한 정보의 양</li></ul></li><li><strong>Throughput</strong>(처리량)::8차선 도로를 달리는 자동차의 양<ul><li>단위 시간당 디지털 데이터 전송으로 처리하는 양</li></ul></li><li><strong>BackPlane</strong><ul><li>네트워크 장비가 최대로 처리가능한 데이터 용량</li></ul></li><li><strong>CPS</strong>(Connections Per Second): 초당 커넥션 연결수, L4</li><li><strong>CC</strong>(Concurent Connections): 최대 수용가능한 커넥션</li><li><strong>TPS</strong>(Transactions Per Seconds): 초당 트랜젝션 연결수, L7, HTTP성능</li><li>데이터 단위<ul><li>bit &amp; Byte 존재. Kilo, Mega, Giga, Tera로 표현</li></ul></li></ul><h2 id="UTP-케이블"><a href="#UTP-케이블" class="headerlink" title="UTP 케이블"></a>UTP 케이블</h2><p><strong>::Unshielded Twisted Pair, 주로 근거리 통신망에 사용되는 케이블로, 이더넷망 구성시 가장 많이 보임</strong></p><h3 id="코드배열"><a href="#코드배열" class="headerlink" title="코드배열"></a>코드배열</h3><ul><li><strong>8P8C</strong>: 8개의 선 배열에 따라 다이렉트 또는 크로스 케이블로 구성<ul><li>Direct Cable: PC to Hub -&gt; DTE to DCE</li><li>Cross Cable: PC to PC, Hub to Hub -&gt; DTE to DTE, DCE to DCE</li><li>DTE(Data <code>Terminal</code> Equipment), DCE(Data <code>Communication</code> Equipment)</li></ul></li></ul><h3 id="Auto-MDI-X"><a href="#Auto-MDI-X" class="headerlink" title="Auto MDI-X"></a>Auto MDI-X</h3><ul><li>Automatic Medium Dependent Interface Crossover</li><li>어떤 노드의 연결인지에 따라 다이렉트와 크로스 케이블을 선택하는 불편함을 개선하여, <code>케이블 타입에 관계없이</code> 노드 상호간 <code>자동</code>으로 통신 가능</li></ul><h3 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h3><ul><li>비영리 기구인 Wi-Fi Aliance의 상표로 전자기기들이 무선랜에 연결할 수 있게 하는 기술</li><li>무선랜 구성시 WIPS(보안)-AP(무선 Hub)</li></ul><h3 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h3><blockquote><p>오픈소스 패킷 분석 프로그램</p></blockquote><ul><li>인터페이스를 선택하고 실시간 패킷 확인과 저장, 분석이 가능</li><li>pcap 파일을 통해서 Fram-L2-L3-L4 정보 확인 가능</li></ul><hr><h1 id="데이터링크-계층"><a href="#데이터링크-계층" class="headerlink" title="데이터링크 계층"></a>데이터링크 계층</h1><blockquote><p>OSI 7 Layer 2계층. 인접한 네트워크 노드끼리 데이터를 전송하는 기능과 절차 제공</p></blockquote><ul><li>물리계층에서 발생가능한 오류를 감지, 수정</li><li>대표적인 프로토콜에는 <code>이더넷</code>, 장비는 <code>스위치</code></li></ul><h2 id="부계층-MAC-amp-LLC"><a href="#부계층-MAC-amp-LLC" class="headerlink" title="부계층 MAC &amp; LLC"></a>부계층 MAC &amp; LLC</h2><ul><li><strong>MAC (Media Access Control)</strong>: 물리적인 부분. 매체간의 연결방식 제어, 1계층과 연결</li><li><strong>LLC (Logical Link Control)</strong>: 논리적인 부분. Frame을 만들어 3계층과 연결</li></ul><h2 id="주요기능"><a href="#주요기능" class="headerlink" title="주요기능"></a>주요기능</h2><p><strong>:: Framing, 회선제어, 흐름제어, 오류제어</strong></p><h3 id="Framing"><a href="#Framing" class="headerlink" title="Framing"></a>Framing</h3><ul><li>데이터그램을 캡슐화하여 프레임단위로 만들고 <code>header</code> 헤더와 <code>trailer</code> 트레일러 추가</li><li>헤더: 목적지, 출발지 주소, 데이터 내용 정의</li><li>트레일러: <code>비트에러</code> 감지</li></ul><h3 id="회선제어"><a href="#회선제어" class="headerlink" title="회선제어"></a>회선제어</h3><ul><li><strong>Select 모드</strong>: 송신자가 나머지 수신자들을 선택하여 전송</li><li><strong>Poll 모드</strong>: 수신자에게 데이터 <code>수신 여부를 확인</code>하여 응답을 확인하고 전송</li></ul><h3 id="흐름제어"><a href="#흐름제어" class="headerlink" title="흐름제어"></a>흐름제어</h3><p><strong>:: 송신자와 수신자의 데이터를 처리하는 속도 차이를 해결하기 위한 제어</strong></p><ul><li>Feedback 방식의 Flow Control, 상위 계층은 Rate기반</li><li><strong>Stop &amp; Wait</strong> : 데이터를 보내고 <code>ACK</code> 응답이 올 때까지 기다림<ul><li>간단히 구현될 수 있지만 비효율적</li><li>데이터를 보내고 ACK응답이 오지 않으면 일정시간 후 <code>다시 보냄</code></li></ul></li><li><strong>Sliding window</strong>: ACK 응답 없이 여러개의 프레임 연속 전송<ul><li><ol><li>PC1: Frame 전송후 Window size축소</li></ol></li><li><ol start="2"><li>PC2: (현재ACK)-(이전ACK)= Window size</li></ol></li><li><ol start="3"><li>PC1: ACK 수신후 Window size 확장</li></ol></li></ul></li></ul><h3 id="오류제어"><a href="#오류제어" class="headerlink" title="오류제어"></a>오류제어</h3><p><strong>:: 전송중에 오류나 손실 발생시 수신측에서 에러탐지 및 재전송</strong></p><ul><li><strong>ARQ(Automatic Repeat Request)</strong>: 프레임 손상시 재전송 수행과정</li><li><strong>Stop &amp; Wait ARQ</strong><ul><li>전송측에서 <code>NAK</code> 수신시 재전송</li><li>주어진 시간에 ACK 안오면 재전송</li></ul></li><li><strong>Go Back n ARQ</strong><ul><li><ol><li>전송측 Frame 6개전송</li></ol></li><li><ol start="2"><li>수신측 NAK 3으로 손상응답</li></ol></li><li><ol start="3"><li>전송측 3이 포함된 345 재전송</li></ol></li></ul></li><li><strong>Selective Repeat ARQ</strong><ul><li>손상된 Frame만 <code>선별</code>하여 재전송</li></ul></li></ul><h2 id="이더넷-프레임-구조"><a href="#이더넷-프레임-구조" class="headerlink" title="이더넷 프레임 구조"></a>이더넷 프레임 구조</h2><h3 id="Ethernet-v2"><a href="#Ethernet-v2" class="headerlink" title="Ethernet v2"></a>Ethernet v2</h3><p><strong>::</strong> 데이터 링크 계층에서 MAC 통신과 프로토콜 형식을 정의</p><ul><li><strong>Preamble</strong>: 이더넷 프레임의 시작과 동기화</li><li><strong>Dest Addr</strong>: 목적지 MAC주소</li><li><strong>Src Addr</strong>: 출발지 MAC주소</li><li><strong>Type</strong>: 캡슐화된 패킷의 프로토콜정의</li><li><strong>Data</strong>: 상위 계층의 데이터</li><li><strong>FCS(Frame Check Sequence)</strong>: 에러체크</li></ul><h2 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h2><p><strong>:: 2계층의 대표적인 장비. MAC주소 기반 통신</strong></p><ul><li>허브의 단점을 보완<ul><li>Half duplex -&gt; Full duplex</li><li>1 Collision Domain -&gt; 포트별 Collision Domain</li></ul></li><li>L3 스위치: 라우팅 기능이 있는 스위치</li></ul><h3 id="스위치-동작방식"><a href="#스위치-동작방식" class="headerlink" title="스위치 동작방식"></a>스위치 동작방식</h3><p><strong>:: 목적지 주소를 MAC 주소 테이블에서 확인, 연결된 포트로 프레임 전달</strong></p><ol><li><strong>Learning</strong>: 출발지 주소가 MAC 테이블에 없으면 해당 주소 저장</li><li><strong>Flooding-Broadcasting</strong>: 목적지 주소가 MAC 테이블에 <strong>없으면</strong> <code>전체포트</code>로 전달</li><li><strong>Forwarding</strong>: 목적지 주소가 MAC 테이블에 <strong>있으면</strong> <code>해당 포트</code>로 전달</li><li><strong>Filtering-Collision Domain</strong>: 출발지와 목적지가 <code>같은 네트워크 대역</code>일 경우 다른 네트워크로 전달하지 않음</li><li><strong>Aging</strong>: MAC 주소 테이블의 정보를 일정시간 이후에 삭제</li></ol><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p><strong>:: ARP(Address Resolution Protocol)- IP주소를 통해 MAC주소를 알려줌</strong><br>(ARP Request – ARP Reply)</p><h3 id="ARP-동작과정"><a href="#ARP-동작과정" class="headerlink" title="ARP 동작과정"></a>ARP 동작과정</h3><ol><li><strong>PC1(172.10.10.1) –&gt; PC2(172.10.10.9) 패킷전송</strong> 시도</li></ol><ul><li>PC1 자신의 <code>ARP Cache Table</code> 에서 목적지 <code>MAC주소</code> 확인</li></ul><ol start="2"><li>ARP Cache Table 에 있을경우: 패킷전송<br>ARP Cache Table 에 <strong>없을경우</strong>: <code>ARP Request</code>-Broadcasting</li><li>PC2(172.10.10.9) 에서 목적지 MAC주소 <code>ARP Reply</code></li><li>목적지 MAC주소 ARP Cache Table 에 <code>저장</code>, <code>패킷 전송</code></li></ol><h3 id="ARP-헤더구조-pcap"><a href="#ARP-헤더구조-pcap" class="headerlink" title="ARP 헤더구조(pcap)"></a>ARP 헤더구조(pcap)</h3><ul><li>Hardware Type: ARP 동작하는 네트워크 환경, 이더넷</li><li>Protocol Type: 프로토콜 종류</li><li>Hardware &amp; Protocol Length</li><li>Operation: 명령코드, 1=ARP Request, 2=ARP Reply</li><li>Hardware Address=MAC, Protocol Address=IP</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OSI모델의 물리계층? 우리가 알던 그 장비.&lt;br&gt;항상 접하던 Ethernet, 스위치, ARP 프로토콜에 대하여.&lt;br&gt;&lt;code&gt;#osi_7_layer&lt;/code&gt; &lt;code&gt;#tcp_ip&lt;/code&gt; &lt;code&gt;#csma_cd&lt;/code&gt; &lt;code&gt;#switch&lt;/code&gt; &lt;code&gt;#ethernet&lt;/code&gt; &lt;code&gt;#arp&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Network" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Network/"/>
    
    
    <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
    <category term="osi_7_layer" scheme="http://yoursite.com/tags/osi-7-layer/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터구조-멀티프로세서</title>
    <link href="http://yoursite.com/2021/06/12/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C/"/>
    <id>http://yoursite.com/2021/06/12/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C/</id>
    <published>2021-06-12T01:50:54.000Z</published>
    <updated>2021-06-16T06:07:51.864Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="Serial-vs-Parallel"><a href="#Serial-vs-Parallel" class="headerlink" title="Serial vs Parallel"></a>Serial vs Parallel</h1><ul><li>Serial Process system<ul><li>CPU 가 하나뿐인 시스템</li><li>기계적, 논리적 프로세싱으로 가장 효율적</li></ul></li><li>Parallel Process system<ul><li>동시에 여러작업 실행가능한 병렬처리 시스템</li><li>=병렬구조</li><li>병렬처리 소프트웨어가(병렬 운영체제, 병렬 컴파일러, 메모리 공유) 과거에 비해 비약적인 발전을 이루고 있음</li></ul></li></ul><h2 id="Parallel-Process-system"><a href="#Parallel-Process-system" class="headerlink" title="Parallel Process system"></a>Parallel Process system</h2><ul><li><strong>다중장치 구조</strong><ul><li><code>다수의 CPU</code>로 동시에 여러개의 작업을 병렬로 처리</li><li><code>공간적</code> 병렬성</li></ul></li><li><strong>파이프라인 구조</strong><ul><li><code>다수의 작업</code>을 각기 다른 실행단계에서 병렬로 처리</li><li><code>시간적</code> 병렬성</li></ul></li></ul><h2 id="멀티프로세서"><a href="#멀티프로세서" class="headerlink" title="멀티프로세서"></a>멀티프로세서</h2><ul><li>메모리와 I/O 장치를 공유하는 <code>두 개 이상의 CPU</code>를 갖는 시스템</li><li>다중명령어 &amp; 다중데이터 = <code>MIMD</code> 시스템에 포함된다.</li><li><code>하나의 운영체제</code>에 의해 프로세서-다른요소들 사이의 동작이 제어된다.<ul><li>동일한 문제해결을 위해 모든 요소들이 협력</li></ul></li><li><strong>시스템 신뢰성 향상</strong><ul><li><code>다수의 독립적 작업</code>들이 <code>병렬</code>적으로 처리된다.</li><li><code>하나의 작업</code>이 여러 부분들로 나눠져 <code>병렬</code>로 처리된다.</li></ul></li><li>사용자가 명시적으로 병렬실행 가능한 작업을 선언한다.</li><li>컴파일러가 자동적으로 프로그램의 <code>병렬성을 감지</code>하여 처리한다.</li></ul><h3 id="멀티프로세서-분류"><a href="#멀티프로세서-분류" class="headerlink" title="멀티프로세서 분류"></a>멀티프로세서 분류</h3><ul><li>Shared memory ;공유메모리(=밀착결합 멀티프로세서): 연관성이 있는 작업을 할때</li><li>Distributed memory: 프로세서마다 독립된 시스템</li><li>Loosely coupled: 프로세서가 옮겨다니는 형식. 어느 경우에는 하나의 프로세서만 적용될 수 있음</li></ul><hr><h2 id="멀티프로세서-상호연결-구조"><a href="#멀티프로세서-상호연결-구조" class="headerlink" title="멀티프로세서 상호연결 구조"></a>멀티프로세서 상호연결 구조</h2><ul><li>CPU, IOP(I/O Processor) 그리고 여러 모듈로 분리된 메모리 장치에 의해 구성된다.</li><li>공유 메모리 시스템: <code>프로세스와 메모리 사이</code>의 경로 수에 따름</li><li>느슨히 결합된 시스템: <code>프로세싱 요소들 사이</code>의 전송경로 수에 따라 물리적으로 다른 구성</li></ul><h3 id="1-시분할-공통버스"><a href="#1-시분할-공통버스" class="headerlink" title="1) 시분할 공통버스"></a>1) 시분할 공통버스</h3><ul><li><strong>단일</strong> 공통버스 시스템<ul><li>주어진 시간에 <code>하나의 프로세서만</code>이 시스템 버스를 사용</li><li><code>충돌 발생시</code> 버스제어기에 의해 해결가능</li><li>시스템 전체 전송률이 단일 경로의 속도에 <code>제한</code>된다</li></ul></li><li><strong>이중</strong> 버스 구조<ul><li>주어진 시간에 <code>하나의 프로세서만</code>이 시스템 버스를 사용</li><li>시스템 버스 제어기에 각 <code>로컬버스</code>를 연결</li><li>각 프로세서들의 대기시간 감소</li><li>여러개의 버스 <code>동시전송</code> 가능</li><li>시스템 구축 비용과 <code>복잡도</code>가 증가</li></ul></li></ul><h3 id="2-다중-포트-메모리"><a href="#2-다중-포트-메모리" class="headerlink" title="2) 다중 포트 메모리"></a>2) 다중 포트 메모리</h3><ul><li>CPU or IOP 와 각 메모리 모듈이 버스라인을 갖고 있는 시스템</li><li>각 모듈은 주어진 시간에 <code>어떤 포트가 메모리에 접근할 수 있을지</code> 결정하는 내부 <code>논리회로</code> 보유</li><li>메모리 접근을 위한 <code>우선순위는 포트의 위치</code>에 따라 결정</li><li><code>고가</code>의 메모리 제어 논리회로와 전선 커넥터</li></ul><h3 id="3-크로스바-스위치-Crossbar-switch"><a href="#3-크로스바-스위치-Crossbar-switch" class="headerlink" title="3) 크로스바 스위치 (Crossbar switch)"></a>3) 크로스바 스위치 (Crossbar switch)</h3><ul><li><em>프로세스 버스</em> 와 <em>메모리 모듈</em> 통로간의 <code>교차점</code>에 위치한 여러개의 크로스포인트로 구성</li><li><code>크로스포인트</code>(crosspoints)<ul><li>프로세서와 메모리 모듈간의 <code>통로를 결정</code>하는 스위치</li><li>버스에 실린 주소를 확인하여 통로를 열어주며, 주어진 <code>순위</code>에 따라 중재도 가능</li></ul></li></ul><h3 id="4-다단-교환망"><a href="#4-다단-교환망" class="headerlink" title="4) 다단 교환망"></a>4) 다단 교환망</h3><ul><li>2입력, 2출력 상호교환 스위치</li><li>2개 입력 중 하나만을 선택하여 전체 경로를 연결</li><li>충돌 중재</li><li>입출력 단자를 연결할 수 있는 제어신호 필요</li></ul><h3 id="5-하이퍼-큐브-상호연결"><a href="#5-하이퍼-큐브-상호연결" class="headerlink" title="5) 하이퍼 큐브 상호연결"></a>5) 하이퍼 큐브 상호연결</h3><ul><li>2<super>n</super>개의 프로세서가 <em>n차원 이진 큐브</em> 로 연결되어 느슨히 결합된 시스템</li><li>각 프로세서는 큐브의 <code>노드</code>를 형성. 이 노드에는 <code>CPU</code> 뿐 아니라 <code>로컬 메모리</code>나 <code>I/O 인터페이스</code>도 포함</li></ul><hr><h2 id="중재-프로세스"><a href="#중재-프로세스" class="headerlink" title="중재 프로세스"></a>중재 프로세스</h2><ul><li>공유 메모리 멀티프로세서 시스템에서 각 자원의 <code>효율적 분배</code>와 <code>상호 충돌을 배제</code>할 수 있는 <code>중재 프로세스</code>는 전체 시스템에 큰 영향을 준다.</li></ul><h3 id="중재-알고리즘"><a href="#중재-알고리즘" class="headerlink" title="중재 알고리즘"></a>중재 알고리즘</h3><ul><li>일반적으로 시스템 버스는 100여개의 신호라인으로 구성. 이 명령라인에 의해 논리가 성립.<ul><li>직렬 중재절차 (daisy-chain)<ul><li>순서가 정해져 있다. 우선순위가 높아도 작업이 끝날때까지 기다려야한다.</li></ul></li><li>병렬 중재논리<ul><li>순서가 정해져 있다.</li></ul></li><li>동적 중재논리<ul><li>큐를 설치</li></ul></li></ul></li></ul><hr><h1 id="프로세서간-통신과-동기화"><a href="#프로세서간-통신과-동기화" class="headerlink" title="프로세서간 통신과 동기화"></a>프로세서간 통신과 동기화</h1><ul><li>멀티 프로세서 시스템의 다양한 프로세서들은 <code>공통의 입출력 채널</code>을 통해 통신</li><li><strong>공통 메모리의 역할</strong><ul><li>메모리의 일부를 모든 프로세서가 접근가능하도록 할당한 공간</li><li><code>송신 프로세서</code>: 요구, 메시지, 프로시저 저장하여 의미있는 정보의 유무를 공지</li><li><code>수신 프로세서</code>: 폴링방식에 의해 주기적 점검<ul><li>더 효율적인 통신방식? <code>인터럽트 신호</code>를 통하여 정보를 지정하여 통신</li></ul></li></ul></li></ul><h2 id="프로세서간-통신"><a href="#프로세서간-통신" class="headerlink" title="프로세서간 통신"></a>프로세서간 통신</h2><ul><li><strong>주종모드</strong><ul><li>주프로세서: OS 기능수행</li><li>종프로세서: 필요에 의한 인터럽트 요청</li></ul></li><li><strong>분리 운영체제</strong><ul><li>모든 프로세서가 자신의 운영체제 보유</li><li>느슨한 결합 시스템에 적합</li></ul></li><li><strong>분산 운영체제</strong><ul><li>부동 운영체제: OS의 특정기능은 한 순간에 하나의 프로세서에만 작동</li><li>운영체제가 여러 프로세서에 분산</li></ul></li></ul><h2 id="프로세서간-동기화"><a href="#프로세서간-동기화" class="headerlink" title="프로세서간 동기화"></a>프로세서간 동기화</h2><ul><li>멀티프로세서의 명령어 집합에는 동작하는 <strong>프로세서와의 통신</strong> 과 <strong>동기화</strong> 를 구현하는 명령어를 포함한다.</li><li>동기화의 필요성<ul><li>처리될 작업들간 순서를 유지할 수 있다.</li><li>공통 변수에 대한 상호배제적 접근을 보장한다.</li></ul></li><li>동기화를 위해 가장 많이 활요되는 기법에 <code>이진 세마포</code>가 있다.</li></ul><h1 id="캐시의-일관성"><a href="#캐시의-일관성" class="headerlink" title="캐시의 일관성"></a>캐시의 일관성</h1><ul><li><strong>cache coherence</strong><ul><li>공유 메모리 멀티프로세서 시스템에서도 각 프로세서는 로컬 메모리를 운영한다.</li><li>정확한 메모리 동작을 위해 이 내용들이 모두 동일하게 유지되어야 한다.</li></ul></li><li>메모리에 쓰기동작시 메모리 갱신<ul><li>write-through: 쓰기동작 발생시 <code>cache 와 주기억장치 모두 갱신</code></li><li>write-back: <code>cache만 갱신</code>하고 메모리로 전달가능한 위치 표시</li></ul></li></ul><h2 id="캐시-일관성에-대한-헤결책"><a href="#캐시-일관성에-대한-헤결책" class="headerlink" title="캐시 일관성에 대한 헤결책"></a>캐시 일관성에 대한 헤결책</h2><ul><li>각 프로세서에 개별적 cache를 허용하지 않고 주기억장치에 <code>공용 cache 메모리를 둔다.</code><ul><li>평균접근시간을 증가시킨다.</li></ul></li><li><strong>캐시가능(cachable)</strong><ul><li>비 공유적, <code>읽기 전용 데이터</code>에 한해 cache 데이터에 저장하도록 한다.</li></ul></li><li><strong>스누피 캐시 제어기</strong><ul><li>기본적으로 버스에 부착된 cache에 대해 <code>버스-감시 기능을 유지</code> 하도록 설계된 하드웨어 장치이다.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;병렬처리 시스템, 멀티 프로세서의 상호연결 구조에는 어떤 것들이 있는지 알아본다.&lt;br&gt;&lt;code&gt;#parallel_system&lt;/code&gt; &lt;code&gt;#multi_processor&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>⛓ 컴퓨터구조-Memory System</title>
    <link href="http://yoursite.com/2021/06/09/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5/"/>
    <id>http://yoursite.com/2021/06/09/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5/</id>
    <published>2021-06-08T16:50:54.000Z</published>
    <updated>2021-06-16T00:47:39.620Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="메모리-계층"><a href="#메모리-계층" class="headerlink" title="메모리 계층"></a>메모리 계층</h1><h2 id="기억장치-MMU-buffer-AMU"><a href="#기억장치-MMU-buffer-AMU" class="headerlink" title="기억장치 (MMU, buffer, AMU)"></a>기억장치 (MMU, buffer, AMU)</h2><blockquote><p>CPU에 의하여 수행될 프로그램이 저장되는 곳.</p></blockquote><ul><li><strong>주기억 장치 (Main memory Unit)</strong><ul><li><strong>RAM</strong> Random Access Memory (마더보드에 장착)<ul><li>비교적 대용량이며 고속, <code>휘발성</code></li></ul></li><li><strong>ROM</strong> Read Only Memory<ul><li>주기억장치의 일종</li></ul></li></ul></li><li><strong>캐쉬 메모리</strong> Cache memory, buffer<ul><li>수행중인 프로그램의 <code>사용빈도가 높은 임시데이터</code>를 저장한다.</li></ul></li><li><strong>보조기억 장치 (Auxiliary memory Unit)</strong><ul><li>대용량 자료보관 가능, 저속</li><li>CPU 가 컨트롤 하지 못한다.</li><li>보조기억 내의 필요한 자료는 <code>주기억장치</code>로 <code>Loading</code> ;옮겨진다.</li><li><strong>SRAM</strong>: 캐시메모리, CPU와 1:1 정도의 속도</li><li><strong>DRAM</strong>: 일반적 주기억장치, 상대적으로 느리다. 7배정도 기다려야 메인메모리가 기다려준다.</li><li>Magnetic Tape, USB, SDcard : 파일 생성/삭제</li><li>Magnetic drum, disk : 백업 저장장치</li></ul></li></ul><blockquote><p>@ 메모리를 계층별로 나누는 이유?</p><ul><li>입출력의 경제성 때문이다.</li></ul></blockquote><h3 id="RAM-의-동작"><a href="#RAM-의-동작" class="headerlink" title="RAM 의 동작"></a>RAM 의 동작</h3><p>⏬ <strong>MAR</strong> Memory Address Register 로 신호가 들어오면,<br>⏬ <strong>주소 디코더</strong> 에 의해서 <code>번지</code> 지정<br>⏬ <code>정보</code>에 의헤서 읽기/쓰기 수행: <strong>CS(Clock Segnal)=0/1, RD(Read)=0/1. WR(Write)=0/1</strong><br>⏬ <strong>MBR</strong> Memory Buffer Register 에 의해 출력된다.</p><h3 id="보조기억-장치"><a href="#보조기억-장치" class="headerlink" title="보조기억 장치"></a>보조기억 장치</h3><blockquote><p>섹터, 트랙, 헤드, 실린더<br><code>접근시간</code>: 메모리내의 기억장소에 도달하여 응답을 받는데까지 요구되는 평균시간</p></blockquote><ul><li><strong>시크타임</strong>: read/write head가 지정된 기억장소에 <code>도달하기까지 소요 시간</code></li><li><strong>트랜스퍼 타임</strong>: 추출된 데이터를 장치내/외 필요한 곳으로 <code>전송하는 시간</code></li><li><strong>레코드</strong>: 데이터가 기록되는 <code>단위, 시크타임을 체크</code>하는 기준.</li><li><strong>전송률</strong>: 장치가 레코드의 시작점에 위치하고서부터 <code>전송 가능한 문자/워드 수</code></li></ul><hr><h1 id="효율적인-메모리-관리"><a href="#효율적인-메모리-관리" class="headerlink" title="효율적인 메모리 관리"></a>효율적인 메모리 관리</h1><h2 id="Associative-memory"><a href="#Associative-memory" class="headerlink" title="Associative memory"></a>Associative memory</h2><blockquote><p><code>내용</code>에 의해 접근하는 <code>메모리 장치</code></p><ul><li>메모리 장치? 자료의 저장과 접근을 용이하게 함</li><li>이제는, <strong>효율적 탐색(search)</strong> 이 필요 : <code>병렬 탐색</code>을 하기에 적합</li><li>외부인자와 <code>내용</code>을 비교할 수 있는 논리회로보유. ::RAM보다 비싸다.</li></ul></blockquote><ul><li>Argument register</li><li>Key register 역할<ul><li>인자워드의 특정 영역이나 키를 선택하기 위한 <code>마스크</code>를 제공한다.</li></ul></li></ul><h2 id="캐쉬-메모리-Cache-memory"><a href="#캐쉬-메모리-Cache-memory" class="headerlink" title="캐쉬 메모리 (Cache memory)"></a>캐쉬 메모리 (Cache memory)</h2><blockquote><p><strong>참조의 국한성</strong> : 프로그램 수행중 메모리 참조는 <code>국한된 영역</code>에서만 이루어진다.</p><ul><li>프로그램 루프, 서브루틴 빈번</li><li>순차적 프로그램 실행</li></ul></blockquote><ul><li><p><strong>캐쉬 메모리의 동작/성능</strong></p><ul><li>Cache를 체크한다.<ul><li>워드가 발견되면(<code>hit</code>) 읽고</li><li>없으면(<code>miss</code>) 주기억장치에 접근</li></ul></li><li>히트율</li></ul></li><li><p><strong>효율적인 메모리관리</strong></p><ul><li>associative mapping<ul><li>associative memory로 캐쉬를 만든다.</li><li>가장 빠르고 융통성 있다.</li><li><code>miss</code> 일 경우 <code>주기억장치</code>에서 해당자료를 찾아 옮긴다.</li><li>여유공간이 있다면 그공간에 저장하지만<ul><li>여유공간이 없다면, 주어진 알고리즘에 의해 해당 주소-데이터 쌍이 새로운 정보로 <code>대체</code>된다.</li></ul></li></ul></li></ul><p>  @@@@@@@@@@@@@ 사진 예시</p><ul><li>Direct mapping<ul><li>SRAM 에 만든다. 하나의 공간에 하나씩 저장한다.</li><li>동일한 인덱스를 보유한 워드가 반복접근시, <code>히트율 감소</code></li></ul></li><li>Set-associative mapping<ul><li>주어진 공간에 <code>병렬</code>로 여러개씩 저장한다.</li><li>복잡한 알고리즘을 필요로한다.</li></ul></li></ul></li></ul><hr><h1 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h1><h2 id="가상메모리-VS-캐쉬메모리"><a href="#가상메모리-VS-캐쉬메모리" class="headerlink" title="가상메모리 VS 캐쉬메모리"></a>가상메모리 VS 캐쉬메모리</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;메모리 시스템&lt;br&gt;&lt;code&gt;#&lt;/code&gt; &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>⛓ 컴퓨터구조-파이프라인</title>
    <link href="http://yoursite.com/2021/06/07/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"/>
    <id>http://yoursite.com/2021/06/07/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/</id>
    <published>2021-06-07T01:50:54.000Z</published>
    <updated>2021-06-16T00:47:39.620Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="병렬처리"><a href="#병렬처리" class="headerlink" title="병렬처리"></a>병렬처리</h1><blockquote><p>컴퓨터 시스템의 계산 속도의 향상을 목적으로 동시 데이터 처리기능을 제공하는 광범위한 개념의 기술.</p><ul><li>다중 기능장치를 가진 레지스터</li><li>실행 장치를 동시에 동작되는 8개의 기능장치로 나눔</li></ul></blockquote><h2 id="병렬처리-구조-분류방법-by-M-J-Flynn"><a href="#병렬처리-구조-분류방법-by-M-J-Flynn" class="headerlink" title="병렬처리 구조 분류방법 by M.J Flynn"></a>병렬처리 구조 분류방법 by M.J Flynn</h2><ul><li>SISD : 단일 명령어, 단일 데이터</li><li>SIMD : 단일 명령어, 다중 데이터</li><li>MISD : 다중 명령어, 단일 데이터</li><li>MIMD : - 다중 명령어, 다중 데이터<ul><li>여러 프로그램 동시수행 능력</li><li>대부분의 다중 프로세서와 다중 컴퓨터 시스템</li></ul></li></ul><hr><h1 id="파이프-라인"><a href="#파이프-라인" class="headerlink" title="파이프 라인"></a>파이프 라인</h1><h2 id="파이프라인-구조-성능"><a href="#파이프라인-구조-성능" class="headerlink" title="파이프라인 구조 성능"></a>파이프라인 구조 성능</h2><ul><li>파이프 라인의 동작은 공간, 시간표에 의해 설명되는데, 이것은 시간에 대한 함수로서 <strong>세그먼트의 사용현황</strong> 을 나타낸다.</li><li>동일한 복잡도의 <code>부연산</code>들로 이루어지는 연산동작도 구현가능하다.</li><li>매번 다른 집합을 동일한 태스크에 적용해, <code>반복적인 일에 효과적</code>이다.</li><li><strong>그러나,</strong> 각 레지스터 Ri 에 분리되는 작업들의 업무강도가 비슷해야 한다. 업무강도가 가장 높은 작업에 비중을 둘 수 밖에 없어서 <code>유휴시간</code>이 생긴다.</li></ul><blockquote><p>파이프라인의 <code>이론적 최대속도 증가율</code>은 <code>세그먼트 수와 같다.</code></p><ul><li>그렇다면, 세그먼트가 많을 수록 효과적일까?</li></ul></blockquote><h2 id="클럭-사이클시간"><a href="#클럭-사이클시간" class="headerlink" title="클럭 사이클시간"></a>클럭 사이클시간</h2><img width="630" alt="파이프라인1" src="https://user-images.githubusercontent.com/28856435/121041772-0251ef00-c7ee-11eb-90d2-5493c5ee541b.PNG"><br><blockquote><p>위와 같은 파이프라인의 클럭 사이클시간을 구하는 공식은 아래와 같다.<br>k + (n-1)<br>(= k개의 세그먼트 파이프라인에서 n개의 데스크를 수행)<br>즉 위의 식에 대입하면 4 + (6-1)= 9<br><code>:: 9개의 클럭사이클을 수행한다.</code></p></blockquote><h2 id="파이프라인-구현"><a href="#파이프라인-구현" class="headerlink" title="파이프라인 구현"></a>파이프라인 구현</h2><ul><li><p>하나의 프로세스를 서로 다른 기능을 가진 서브프로세스로 나누어 각 프로세스가 <code>동시에</code> 서로 다른 데이터를 취급하도록 하는 기법</p></li><li><p>각 세그먼트에서 수행된 연산결과는 다음 세그먼트로 연속적으로 넘어간다.</p><ul><li>마지막 세그먼트를 통과하게되면 최종 연산결과를 얻는다.</li><li>하나의 프로세스를 다양한 연산으로 중복시킬 수 있는 근간은 <code>세그먼트</code>마다의 <code>레지스터</code>이다.</li></ul></li><li><p>곱셈과 덧셈이 섞인 다항식 연산<br><strong>Ai X Bi + Ci (i= 1,2,3 …7)</strong></p></li><li><p>R1 ~ R5 레지스터와 조합논리회로 (Adder, Multiplier) 구성</p></li></ul><img width="693" alt="파이프라인2" src="https://user-images.githubusercontent.com/28856435/121041793-08e06680-c7ee-11eb-9c19-daec02459cc3.PNG"><br><ul><li>수도코드<table><thead><tr><th>수도코드</th><th>설명</th></tr></thead><tbody><tr><td>R1 &lt;- Ai, R2 &lt;- Bi</td><td>Ai와 Bi의 입력</td></tr><tr><td>R1 &lt;- R1 X R2, R4 &lt;- Ci</td><td>곱셈과 Ci의 입력</td></tr><tr><td>R1 &lt;- R3 + R4</td><td>곱셈 결과와 Ci의 덧셈</td></tr></tbody></table></li></ul><br><br><ul><li><strong>세번의 clock pulse이후부터 R5의 첫번째 결과획득</strong> 및 파이프 <strong>라인상에서 데이터 이동시작</strong></li></ul><img width="533" alt="파이프라인3" src="https://user-images.githubusercontent.com/28856435/121213896-9fc62500-c8b9-11eb-8eaa-582963e0c47c.PNG"><h2 id="파이프라인-데이터-처리"><a href="#파이프라인-데이터-처리" class="headerlink" title="파이프라인 데이터 처리"></a>파이프라인 데이터 처리</h2><blockquote><ul><li>예시<ul><li>각 세그먼트에서 부연산 수행 소요시간: t<sub>p</sub>= <code>20ns</code></li><li>파이프 라인은 <code>k=4</code> 세그먼트</li><li>태스크의 수: <code>n=100</code></li></ul></li></ul></blockquote><p><strong>파이프라인 구조를 활용한 경우 총 소요시간</strong></p><ul><li>(k+ n-1)t<sub>p</sub> = (4+100-1) X 20 = 2060ns</li></ul><p><strong>비파이프라인 시스템</strong></p><ul><li>각 태스크 완료시간: t<sub>n</sub>= kt<sub>p</sub> = 4 X 20 = 80ns</li><li>전체 태스크 완료시간: nkt<sub>p</sub> = 100 X 80 = 8000ns</li></ul><p><strong>:: 속도 증가율을 확인할 수 있다.</strong></p><ul><li>8000/2060 = 3.88 ~= 4</li></ul><hr><h1 id="현실적인-파이프라인"><a href="#현실적인-파이프라인" class="headerlink" title="현실적인 파이프라인"></a>현실적인 파이프라인</h1><h2 id="파이프라인-VS-병렬-다중기능-장치"><a href="#파이프라인-VS-병렬-다중기능-장치" class="headerlink" title="파이프라인 VS 병렬 다중기능 장치"></a>파이프라인 VS 병렬 다중기능 장치</h2><ul><li><strong>파이프라인</strong><ul><li>실제 파이프라인 구조는 <strong>이론적인 최대속도 구현 불가</strong><ul><li>각 세그먼트들이 <code>부연산을 수행하는 시간</code>이 다르기 때문이다.</li></ul></li><li><code>최대 전파시간</code>을 갖는 세그먼트의 지연시간에 맞춰야한다.</li></ul></li><li><strong>병렬 다중기능 장치</strong><ul><li>그래서, 병렬적인 다중기능장치를 고려 할 수 있다.</li><li>순차적 처리가 아닌, 데이터를 <code>동시입력</code> 받아 태스크를 <code>동시에 처리</code>한다. (SIMD구조)</li></ul></li></ul><h2 id="파이프라인-구조"><a href="#파이프라인-구조" class="headerlink" title="파이프라인 구조"></a>파이프라인 구조</h2><h3 id="산술-파이프라인"><a href="#산술-파이프라인" class="headerlink" title="산술 파이프라인"></a>산술 파이프라인</h3><ul><li><p>산술 연산들을 <code>부연산으로 나누어</code> 파이프라인의 <code>세그먼트</code>에서 수행</p><ul><li>불필요한 작업을 줄일 수 있다.</li><li>eg. 부동 소수점 연산, 과학계산 등</li></ul></li><li><p>부동 소수점 덧셈/뺄셈을 위한 파이프라인</p><ul><li>초기값이 아래와 같은 X, Y 의 ADD 연산을 산술파이프라인을 사용한다면, 표와같이 나타난다.<br>X = 0.2345 X 10<sub>3</sub><br>Y = 0.1200 X 10<sub>2</sub></li></ul></li></ul><table><thead><tr><th>segment</th><th>result</th></tr></thead><tbody><tr><td>Segment 1</td><td>값이 큰 지수에 맞춘다:3</td></tr><tr><td>Segment 2</td><td><strong>X</strong> = 0.2345 X 10<sub>3</sub> <strong>Y</strong> = 0.0120 X 10<sub>3</sub></td></tr><tr><td>Segment 1</td><td>Z = 0.2465<sub>3</sub></td></tr><tr><td>Segment 1</td><td>정규화(항상 0으로 표현): <strong>Z</strong> = 0.02465<sub>4</sub></td></tr></tbody></table><h3 id="명령어-파이프라인"><a href="#명령어-파이프라인" class="headerlink" title="명령어 파이프라인"></a>명령어 파이프라인</h3><blockquote><p>명령어 사이클의 fetch, 디코드, 실행단계를 <code>중첩</code>사켜 명령어 흐름에 <code>동시에</code> 동작</p></blockquote><ul><li><p><strong>취약점</strong> </p><ul><li>하지만 현재 파이프라인은 <code>모두 비워져</code> 있어야한다.</li><li>분기명령(<code>Branch</code>) 이후의 명령어는 무시된다.</li><li>세그먼트 수행시간이 서로다르다.</li></ul></li><li><p><strong>효율적인 명령어 파이프라인?</strong></p><ul><li>명령어 fetch장치<ul><li><code>FIFO</code> 에 의한 큐로 구성하여 queuing 기법으로, 메모리를 참조 하도록 하여 접근시간을 줄인다.</li></ul></li><li>두개 이상의 세그먼트에 의해 주소참조 충돌이 일어날 수 있다.<ul><li>우선권을 주는 로직 필요</li></ul></li></ul></li></ul><hr><h1 id="파이프라인-CPU"><a href="#파이프라인-CPU" class="headerlink" title="파이프라인 CPU"></a>파이프라인 CPU</h1><h2 id="파이프라인-분기예측"><a href="#파이프라인-분기예측" class="headerlink" title="파이프라인 분기예측"></a>파이프라인 분기예측</h2><ul><li><p>명령어 파이프라인이 비정상적인 동작을 하는 요인</p><ul><li><strong>1) 자원충돌</strong> <ul><li>명령어 메모리와 데이터 메모리를 <code>분리</code>하여 해결</li></ul></li><li><strong>2) 데이터 의존성</strong>: 아직 준비되지 않은 데이터를 기다림<ul><li><em>하드웨어 인터락</em><ul><li><code>피연산자</code>가 먼저 앞선 명령어의 목적지와 일치하는지 검사</li><li>피연산자가 준비되지 않았다면 충돌을 충분히 피할만큼의 <code>클럭사이클</code>을 둔다.</li></ul></li><li><em>오퍼랜드 포워딩</em> : 충돌시 특별한 <code>통로</code>를 통해서 직접 세그먼트에 전달.</li></ul></li><li><strong>3) 주소 의존성</strong>: 간접모드를 사용하는 명령어는 주소를 참조할 경우 메모리로부터 바로 fetch 되지 못한다.</li><li><strong>4) 분기 곤란</strong>: 분기 명령어같이 PC값을 바꾸려는 명령어에 의해 발생</li></ul></li><li><p>분기 명령어 처리</p><ul><li>조건,무조건 분기는 파이프라인의 정상적인 프로그램 순서를 바꿔버린다.<ul><li>컴퓨터 성능 저하</li></ul></li><li><em>분기 목표 버퍼 (branch target buffer, BTB)</em><ul><li>fetch 세그먼트에 속해있는 associative memory(주소가 아닌 내용에 의해 검색가능한 장치)</li><li>일종의 <code>레지스터</code>로, 이전에 실행된 <code>분기 명령어와 목표 명령어를 저장</code>하여 활용한다. (loop buffer)</li></ul></li></ul></li></ul><h2 id="RISC-Processor"><a href="#RISC-Processor" class="headerlink" title="RISC Processor"></a>RISC Processor</h2><blockquote><p>실행 명령어 수는 증가, 작업 처리시간 감소 가능<br>명령어당 실행 클록수와 클록주기를 파이프라인 구조로 감소 가능</p></blockquote><ul><li><strong>RISC Processor 구조적 특징</strong><ul><li>명령어 1사이클 실행을 위한 <code>온칩 캐쉬</code></li><li>간단한 명령코드, 주소지정 모드</li><li>신속한 오퍼랜드 참조/문맥 전환을 위한 레지스터 집합</li></ul></li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><blockquote><p>파이프라인의 <code>이론적 최대속도 증가율</code>은 <code>세그먼트 수와 같다.</code></p><ul><li>그렇다면 세그먼트가 많을 수록 효과적일까?<br><strong>실제 상황은 그렇지 않다.</strong></li></ul></blockquote><ul><li>모든 명령어는 <code>동일한 처리 과정</code>으로 처리되어야 한다.</li><li>파이프라인을 구성하는 각 단계의 <code>처리시간이 일정</code>해야한다.</li><li>모든 명령어는 <code>순차적</code>으로 실행되어야 한다.</li><li>각 명령어 사이에는 <code>의존성이 없어야 </code>한다.</li><li>명령어들 처리시 공유자원의 <code>충돌이 없어야</code> 한다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;파이프라인은 무조건 성능이 좋을까?&lt;br&gt;세그먼트 수가 많을 수록 효과적인걸까?&lt;br&gt;&lt;code&gt;#segment&lt;/code&gt; &lt;code&gt;#RISC_Processor&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>🖨 컴퓨터구조-입출력과 프로그래밍</title>
    <link href="http://yoursite.com/2021/06/05/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0__%EC%9E%85%EC%B6%9C%EB%A0%A5/"/>
    <id>http://yoursite.com/2021/06/05/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0__%EC%9E%85%EC%B6%9C%EB%A0%A5/</id>
    <published>2021-06-05T01:50:54.000Z</published>
    <updated>2021-06-08T04:48:49.605Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="입출력-구성"><a href="#입출력-구성" class="headerlink" title="입출력 구성"></a>입출력 구성</h1><blockquote><ul><li>컴퓨터는 사용자와 통신하기 위해, 외부장치를 사용한다.</li><li>즉 메모리로 데이터와 명령어를 읽어들일 입력장치와 계산결과를 사용자에게 출력장치를 통해 표시해주어야 한다.</li></ul></blockquote><h2 id="입출력-과정"><a href="#입출력-과정" class="headerlink" title="입출력 과정"></a>입출력 과정</h2><ul><li>OUTR, AC, INPR, FGI는 모두 <code>병렬로 연결</code>되어 있다.</li></ul><ol><li><strong>Keyboard</strong> 입력이 들어가면</li><li><strong>Transmitter Interface</strong>  를 통해서 </li><li><strong>INPR</strong> 에 시프트되어 들어간다.<ul><li>flag bit<ul><li><strong>FGI</strong>(입력용 제어 플립플롭)<ul><li><code>0</code>: Key in 8bit code. 8비트가 채워지면  FGI는 1로 변경된다.</li><li><code>1</code>: INPR 값은 바꿀 수 없다. 이후 플래그가 1이면 AC로 <code>병렬 전송</code>을 하고 FGI를 클리어 시킨다. 이후 새로운 정보가 INPR에 들어갈 수 있다.</li></ul></li></ul></li></ul></li></ol><ul><li><strong>AC(Accumulator)</strong> : 명령어의 출발지이자 Destination(결과저장) 이다. FGI의 플래그가 1일경우, INPR 로부터 병렬전송을 받는다.</li><li><strong>OUTR</strong><ul><li>flag bit<ul><li><strong>FGO</strong>(출력용 제어 플립플롭)<ul><li><code>0</code>: 출력 장치가 사용중</li><li><code>1</code>: OUTR 가 AC 값을 reciever를 통해 출력</li></ul></li></ul></li></ul></li></ul><h2 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h2><h3 id="IEN-Interrupt-Enable-flip-flop"><a href="#IEN-Interrupt-Enable-flip-flop" class="headerlink" title="IEN : Interrupt Enable flip-flop"></a>IEN : <code>Interrupt Enable flip-flop</code></h3><ul><li>프로그램 제어전송 대신에 <code>외부장치의 전송작업이 준비되었을 때 컴퓨터에 알리는</code> 방법에 활용되는 플리플롭이다.</li><li>프로그램 실행 도중 플래그를 체크하지 않고, 플래그(=1)가 들어오면 실행중이던 작업을 중단하고 우선순위가 높은 작업부터 처리하게 된다.</li><li>IEN 는 인터럽트를 가능하게 해준다.</li></ul><h3 id="인터럽트-수행과정"><a href="#인터럽트-수행과정" class="headerlink" title="인터럽트 수행과정"></a>인터럽트 수행과정</h3><ul><li>인터럽트 시에는 ?</li><li>PC &lt;- 1</li><li>IEN &lt;- 0</li><li>R &lt;- 0</li></ul><p><img src="https://user-images.githubusercontent.com/28856435/120877206-31027680-c5f0-11eb-82c1-fa8615579088.jpg" alt="interrupt"></p><br><h3 id="컴퓨터-실행속도-VS-입출력장치-속도"><a href="#컴퓨터-실행속도-VS-입출력장치-속도" class="headerlink" title="컴퓨터 실행속도 VS 입출력장치 속도"></a>컴퓨터 실행속도 VS 입출력장치 속도</h3><blockquote><p><strong>QESTION. 입출력 장치는 작업 수행시 몇번의 플래그 체크를 수행할까?</strong></p><ul><li>컴퓨터의 프로세스 처리속도는 <code>10μs fetch and execute cycle time</code>(하나의 instruction을 처리하는데 10μs가 걸림) 라 하고.</li><li>입출력장치의 처리속도는 10문자/초 가 걸리며, 1문자당 0.1초= 100,000μs 라 한다.<br><code>(1sec = 1000ms = 1000,000μs 이다.)</code></li><li><strong>결론</strong><br> :: 플래그 체크 횟수는 1문자당 입력/출력이 함께 일어난다고 생각하면, 하나의 명령을 처리할 때 100,000μs/10μs = 10,000 번 체크를 하게된다.<br> :: 입력과 출력 각 <code>5000번의 체크</code>가 일어나게 된다.</li></ul></blockquote><hr><h1 id="프로그램의-종류"><a href="#프로그램의-종류" class="headerlink" title="프로그램의 종류"></a>프로그램의 종류</h1><ul><li><p>소프트웨어는 <code>시스템 소프트웨어</code>와 <code>응용 프로그램</code>으로 나눠져있다.</p></li><li><p><strong>시스템 소프트웨어</strong></p><ul><li>운영체제<ul><li>Job 관리</li><li>스케줄 관리</li><li>네트워크 관리</li><li>입출력 관리</li></ul></li><li>언어번역 프로그램<ul><li>컴파일러</li><li>어셈블러</li><li>인터프리터</li></ul></li><li>유틸리티 프로그램<ul><li>DBMS</li><li>VCCINE</li><li>드라이버 관리 프로그램</li></ul></li></ul></li><li><p><strong>응용 소프트웨어</strong></p><ul><li>Application/ App</li><li>Mobile App</li></ul></li></ul><h2 id="프로그램-처리과정"><a href="#프로그램-처리과정" class="headerlink" title="프로그램 처리과정"></a>프로그램 처리과정</h2><blockquote><p>고급언어 프로그램 - 어셈블리 프로그램 - 기계어 프로그램</p></blockquote><ul><li><p><strong>기계어</strong>(처리중심)</p><ul><li>1100 0001 1010 0000</li></ul></li><li><p><strong>어셈블리 언어</strong>(처리중심): 모든 컴퓨터는 각각의 어셈블리 언어를 가지고 있으며 이 규틱은 컴퓨터 제조업체로부터 출판되어진다.</p><ul><li> 니모닉(mnemonic) : 기억하기 용이한 형태로 정해진 기호. (ADD, LDA …)</li><li>라벨필드: 기호주소나 빈칸</li><li>명령어 필드: 기계어나 수도명령어 기술<ul><li>메모리 참조 명령어</li><li>레지스터 참조/입출력 명령어</li><li>sudo 명령어</li></ul></li></ul></li><li><p><strong>고급언어</strong>(문제중심)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    a= <span class="number">5</span>, b=<span class="number">-2</span>;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b = %d&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="프로그래밍-구현"><a href="#프로그래밍-구현" class="headerlink" title="프로그래밍 구현"></a>프로그래밍 구현</h1><h2 id="소프트웨어-개발-패러다임"><a href="#소프트웨어-개발-패러다임" class="headerlink" title="소프트웨어 개발 패러다임"></a>소프트웨어 개발 패러다임</h2><p>⬇️ 구조적 기법<br>⬇️ 객체지향 기법: 객체지향<br>⬇️ 컴포넌트 기법: 외부와 Interface를 통해 동작구현. 시스템의 단순성.<br>⬇️ 분산객체 프레임워크: 이종 분산환경에서 여러종류의 Application을 쉽게 통합</p><h2 id="컴퓨터-네트워크-환경"><a href="#컴퓨터-네트워크-환경" class="headerlink" title="컴퓨터 네트워크 환경"></a>컴퓨터 네트워크 환경</h2><ul><li><p>Wireshark 패킷 분석툴</p><ul><li>Explorer가 운영체제의 한 축을 담당하게 된 순간부터 컴퓨터는 이미 통신기계로 분류되고 있다.</li><li>통신기계로서의 hexadecimal 표현</li><li>NOS (New technology Operating Systerm)</li></ul>  <img width="837" alt="wireshark" src="https://user-images.githubusercontent.com/28856435/120879375-d96b0780-c5fd-11eb-9158-1985d5af3fb1.png">  <br></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;프로그래밍 입출력은 어떻게 수행되는걸까?&lt;br&gt;&lt;code&gt;#FGI&lt;/code&gt; &lt;code&gt;#FGO&lt;/code&gt; &lt;code&gt;#IEN&lt;/code&gt; &lt;code&gt;#Flip-Flop&lt;/code&gt; &lt;code&gt;#프로그램_언어_패러다임&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>📱 CPU구조_레지스터</title>
    <link href="http://yoursite.com/2021/06/03/CPU%EA%B5%AC%EC%A1%B0-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/"/>
    <id>http://yoursite.com/2021/06/03/CPU%EA%B5%AC%EC%A1%B0-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/</id>
    <published>2021-06-02T15:35:59.000Z</published>
    <updated>2021-06-08T04:34:02.853Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="CPU-구성요소"><a href="#CPU-구성요소" class="headerlink" title="CPU 구성요소"></a>CPU 구성요소</h1><blockquote><p>중앙처리장치 = CPU(Central Processing Unit)</p><ul><li>레지스터 세트 (Register set) : 명령어를 실행시 필요한 데이터를 보관</li><li>산술논리장치 (ALU; Arithmetic Logic Unit) : 명령어를 실행하기 위한 <code>마이크로 연산</code> 수행</li><li>마이크로 연산 종류- shift, count, clear, load</li><li>제어장치 (Contol Unit) : RS 간의 정보전송 감시, ALU에 수행할 동작 지시. ID(명령어해독기) 로부터 보내진 신호를 기준으로 명령어 실행</li></ul></blockquote><h2 id="각-레지스터들의-기능"><a href="#각-레지스터들의-기능" class="headerlink" title="각 레지스터들의 기능"></a>각 레지스터들의 기능</h2><ul><li><code>MAR</code> Memory Address Register : 메모리의 <code>상태</code></li><li><code>MBR</code> Memory Buffer Register : 메모리 <code>임시저장공간</code></li><li><code>IR</code> Instruction Register 명령어 레지스터 : 계수기가 지정하는 주소에 기억된 <code>명령어를 해독</code>하기 위해 <code>임시 기억</code><ul><li><code>ID</code> Instruction decoder 명령어 해독기: IR에 들어있는 명령코드의 해석</li></ul></li><li><code>PC</code> (Program Counter) 프로그램 계수기 : <code>다음 수행될 명령어</code>가 들어있는 주소(주기억장치)를 기억.</li><li><code>SR</code> Status Register 상태레지스터: CPU의 상태를 나타내는 특수목적의 레지스터. flag 정보를 저장한다.<ul><li>연산결과 상태</li><li>0(Z; Zero), 부호(S; sign), 오버플로우(V; overflow), 캐리(C; carry), 인터럽트(I; interrupt)</li></ul></li><li><code>WR</code> Work Register 작업레지스터: <code>산술논리연산</code>을 실행할 수 있게 자료 및 결과 저장. (GPR 은 ALU를 사용하지 않는다.)</li><li><code>GR</code> General Purpose Register 범용 레지스터 : 작업 레지스터에서 <code>데이터가 용이하게 처리</code>되도록 임시자료 저장</li></ul><p><strong>ADD 명령의 실행예</strong></p><table><thead><tr><th>seq</th><th>stage</th><th>flow</th><th>function</th></tr></thead><tbody><tr><td>1</td><td>FETCH</td><td>MAR &lt;- PC</td><td>다음 실행할 명령어의 주소를 <code>MAR</code>로 이동</td></tr><tr><td>2</td><td>FETCH</td><td>MBR &lt;- 기억장치[MAR]</td><td>MAR 이 지정하는 주소의 내용을 <code>MSR</code>로 이동</td></tr><tr><td>3</td><td>FETCH</td><td>IR &lt;- MBR</td><td>MBR의 내용을 <code>IR 명령어 레지스터</code>로 이동</td></tr><tr><td></td><td></td><td><em>&lt;어떤 명령인가 ?&gt;</em></td><td></td></tr><tr><td>4</td><td>EXECUTE</td><td>MAR &lt;- IR[OPRD]</td><td>명령어 레지스터의 주소 부분을 <code>MAR</code>로 이동</td></tr><tr><td>5</td><td>EXECUTE</td><td>MBR &lt;- 기억장치[MAR]</td><td>ADD 할 내용을 <code>MBR</code>로 이동</td></tr><tr><td>6</td><td>EXECUTE</td><td>WR &lt;- GR[IR]</td><td>IR에서 지정하는 GR의 내용을 <code>WR</code>로 이동</td></tr><tr><td>7</td><td>EXECUTE</td><td>WR &lt;- WR + MBR</td><td><code>ADD 작업</code>: data(WR) + data(MBR)</td></tr><tr><td>8</td><td>EXECUTE</td><td>GR[IR] &lt;- WR</td><td>WR의 결과를 <code>GR</code>로 이동</td></tr><tr><td>9</td><td>EXECUTE</td><td>PC &lt;- PC+1</td><td>다음 명령어 수행 위해 <code>PC값 증가</code></td></tr></tbody></table><h2 id="CPU-내부-구조"><a href="#CPU-내부-구조" class="headerlink" title="CPU 내부 구조"></a>CPU 내부 구조</h2><blockquote><p>명령어 구성 및 실행</p></blockquote><ul><li>레지스터 간의 전송문으로 나타나는 컴퓨터의 각 연산이 어떻게 동작하는가?</li><li><strong>컴퓨터의 구조</strong>: 내부 레지스터, 타이밍, 제어구조 명령어 집합에 의해 정의</li></ul><h3 id="레지스터-전송-언어"><a href="#레지스터-전송-언어" class="headerlink" title="레지스터 전송 언어"></a>레지스터 전송 언어</h3><ul><li><code>마이크로 연산</code> : 레지스터에 저장된 데이터 조작을 위해 실해되는 동작</li><li>하나의 <code>Clock Pulse</code> 클럭 펄스 내에서 실행.<ul><li>shift, count, clear, road etc.</li></ul></li></ul><h3 id="레지스터-전송"><a href="#레지스터-전송" class="headerlink" title="레지스터 전송"></a>레지스터 전송</h3><ul><li>레지스터 전송의 기본기호</li></ul><img width="473" alt="레지스터_전송_기호" src="https://user-images.githubusercontent.com/28856435/120518845-f7bde100-c40c-11eb-9643-9e9cac53d0dc.PNG"><br><ul><li>R1 -&gt; R2 : 치환연산자를 이용한 레지스터간 정보 전송</li><li><em>P: R1 -&gt; R2</em><ul><li><code>if(P=1) then(R1-&gt;R2)</code></li><li><code>소스</code>레지스터로부터 <code>목적</code>레지스터까지의 연결.</li><li>목적 레지스터애는 조건부 처리 가능한 <code>병렬로드</code> 기능이 있어야한다.</li></ul></li></ul><blockquote><p>레지스터 전송을 나타내는 각 문장들은 그 전송을 수행하는 <code>하드웨어가 구성되어 있음</code>을 의미한다.</p></blockquote><h3 id="CPU-디자인"><a href="#CPU-디자인" class="headerlink" title="CPU 디자인"></a>CPU 디자인</h3><ul><li>다양한 <code>디바이스들 간</code> 상호 연결<ul><li><code>직접연결</code>: 연결 복잡도가 장치수의 <code>제곱</code>에 비례</li><li><code>버스연결</code><ul><li><code>공용선</code>에 의한 연결 -&gt; MUX (멀티플렉서) 를 이용한다.</li><li><code>디코더</code> decoder 이용 -&gt; 코드화된 데이터로부터 정보를 찾아내는 논리회로</li><li>가성비가 높다.</li><li>관리를 위한 다양한 방식이 존재한다.</li></ul></li></ul></li><li>자료구조<ul><li>스택(stack): 주 함수에서 <code>서브루틴</code>을 호출할 경우(콜스택)</li><li>큐(queue): 버퍼(buffer) 등과 같이 <code>순차적 처리</code>를 요하는 자료의 대기시에 활용</li><li>데크(deque): 스택과 큐의 동작을 동시에 가능. (*이건 잘 모르겠다..)<ul><li>입력제한 데크: scroll</li><li>출력제한 데크: shelf</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CPU 구성과 디자인 그리고 레지스터들의 종류와 기능을 알아본다.&lt;br&gt;&lt;code&gt;#MBR&lt;/code&gt; &lt;code&gt;#register&lt;/code&gt; &lt;code&gt;#마이크로_연산&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>🖥 컴퓨터구조-데이터의 종류, 논리회로</title>
    <link href="http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%EC%A2%85%EB%A5%98/"/>
    <id>http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%EC%A2%85%EB%A5%98/</id>
    <published>2021-06-01T14:50:54.000Z</published>
    <updated>2021-06-03T09:31:07.434Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="데이터의-종류"><a href="#데이터의-종류" class="headerlink" title="데이터의 종류"></a>데이터의 종류</h1><h2 id="진법-amp-진법변환"><a href="#진법-amp-진법변환" class="headerlink" title="진법 &amp; 진법변환"></a>진법 &amp; 진법변환</h2><blockquote><ul><li>1nibble = 4bit</li><li>1byte = 8bit</li><li>1btye = 1문자(character)</li><li>1워드: 특정 CPU에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수.<ul><li> HalfWord=2byte, FullWord=4byte, DoubleWord=8byte</li></ul></li></ul></blockquote><ul><li><p>8/16진수와 2진수</p><ul><li>8진수: 2진수를 3자리씩 묶어서 표현한다.<ul><li>111101111(2) -&gt; 757(8)</li></ul></li><li>16진수: 2진수를 4자리씩 묶어서 표현한다.<ul><li>111101111(2) -&gt; 1EF(16)</li></ul></li></ul></li><li><p>분수의 변환</p><ul><li>0.75<ul><li>0.75 x 2 = <code>1</code>.5</li><li>1.5 x 2 = <code>1</code>.0</li></ul></li><li>0.75 =&gt; 0.<code>11</code></li></ul></li></ul><h2 id="보수"><a href="#보수" class="headerlink" title="보수"></a>보수</h2><ul><li>양/음수로 활용</li><li>연산에 활용</li><li>1의 보수: <code>최대값</code>을 형성하는데 서로 보완 관계에 있는 두 수 사이의 관계를 1의 보수라고 한다.<ul><li>0111(2) 의 1의 보수 = 1000(2)</li></ul></li><li>2의 보수: MODULUS(<code>최대 표현자리 수</code>)형성하는데 서로 보완관계에 있는 두수 사이읙 관계<ul><li>1의 보수 1000(2)에 1을 더한다.</li><li>0111(2) 의 2의 보수 = 1001(2)</li></ul></li></ul><h3 id="정수-표현"><a href="#정수-표현" class="headerlink" title="정수 표현"></a>정수 표현</h3><ul><li>고정 소수점, FIXED POINT NUMBER</li><li>10진수형 정수표현<ul><li><code>Unpacked decimal</code>: 1byte 에 10진수 <code>1개 자리</code>만 표현.</li><li>zoned decimal 이라고 하며,<ul><li>연산에는 이용될 수 없지만, 10진수 데이터를 <code>입출력용</code>.</li><li>쉽게 입력하기 위해서 unpacked형으로 변환시킨것을 packed로 변환.</li></ul></li><li><code>Packed decimal</code>: 1byte 에 <code>2개 자리</code>의 10진수를 표현. (<code>BCD code</code>이용)<ul><li>마지막 4개의 비트는 부호표현</li><li><code>연산</code>에 이용하며, 입출력은 불가하다.</li></ul></li></ul></li></ul><h3 id="실수표현-부동소수점-Floating-ponint"><a href="#실수표현-부동소수점-Floating-ponint" class="headerlink" title="실수표현 (부동소수점, Floating-ponint)"></a>실수표현 (부동소수점, Floating-ponint)</h3><ul><li>과학적 표기의 지수를 사용하여 <code>소수점의 위치를 이동</code>시킬 수 있는 표현 방법이다.</li></ul><h3 id="디지털-코드"><a href="#디지털-코드" class="headerlink" title="디지털 코드"></a>디지털 코드</h3><ul><li>BCD 코드 (Binary Coded Decimal Code, 2진화 10진 코드)</li></ul><br><img width="505" alt="BCD_code" src="https://user-images.githubusercontent.com/28856435/120340687-38482c80-c331-11eb-8b65-234e6c092496.png"><br><ul><li>3초화 코드</li><li>오류 검출 코드<ul><li>패리티 비트</li><li>해밍 비트</li></ul></li></ul><hr><h1 id="논리-게이트-Logical-gate"><a href="#논리-게이트-Logical-gate" class="headerlink" title="논리 게이트(Logical gate)"></a>논리 게이트(Logical gate)</h1><ul><li>논리 연산을 수행하는 전자소자로서, 주어진 입력 변수값에 대하여 정해진 논리 함수를 수행한다. 그 함수의 경과와 동일한 결과값을 출력하는 하드웨어이다.</li></ul><h2 id="스위칭-이론"><a href="#스위칭-이론" class="headerlink" title="스위칭 이론"></a>스위칭 이론</h2><ul><li>논리곱(AND)<ul><li>A B 가 모두 1일 때만 1이다.</li></ul></li><li>논리합(OR)<ul><li>A B 증 하나만 1이라면, 1이다.</li></ul></li><li>논리부정(NOT)<ul><li>A가 0일 때, B는 1.</li><li>A가 1일 때, B는 0.</li></ul></li><li>배타적 논리합(exclusive OR = XOR)<ul><li>A B 값이 같을 때는 0, 다를때는 1이다.</li></ul></li></ul><h2 id="반가산기-Half-addr"><a href="#반가산기-Half-addr" class="headerlink" title="반가산기(Half addr)"></a>반가산기(Half addr)</h2><ul><li>1bit 덧셈의 구현</li><li>a+b=S 기본연산을 구현하고자 하는경우</li></ul><hr><h1 id="부울대수-Boolean-Algebra"><a href="#부울대수-Boolean-Algebra" class="headerlink" title="부울대수(Boolean Algebra)"></a>부울대수(Boolean Algebra)</h1><ul><li>참과 거짓을 판별할 수 있는 논리적 명제를 수학적 표현으로.</li><li>논리회로의 형태와 구조를 기술하는데 필요한 수학적인 이론.</li><li>변수들의 진리표 관계를 대수식으로 표현하기에 용이.</li><li>동일한 성능을 갖는 간단한 회로를 만들기 편리.</li></ul><h2 id="부울대수-법칙"><a href="#부울대수-법칙" class="headerlink" title="부울대수 법칙"></a>부울대수 법칙</h2><ul><li>기본법칙<ul><li>A<em>B = B</em>A</li><li>A+B = B+A</li></ul></li><li>결합법칙<ul><li>A*(B<em>C) = (A</em>B)*C</li><li>(A+B)+C = A+(B+C)</li></ul></li><li>분배법칙<ul><li>A*(B+C) = AB + AC</li></ul></li><li>드모르간의 법칙 (DeMorgan’s Theorem)<ul><li>A+B 부정 = A부정 * B부정</li><li>(A*B)부정 = A부정 + B부정 </li></ul></li></ul><br><img width="369" alt="드모르간" src="https://user-images.githubusercontent.com/28856435/120344270-6844ff00-c334-11eb-8a49-12b1b1164c27.PNG"><br><h2 id="부울식-간략화-예제"><a href="#부울식-간략화-예제" class="headerlink" title="부울식 간략화 예제"></a>부울식 간략화 예제</h2><pre><code>eg. E = (a&#39; + bc)(a+b)    = aa&#39; + a&#39;b + abc + bbc ;`aa&#39;=0`    = a&#39;b + abc + bc ;`bbc=bc`    = (a+1)bc + a&#39;b ;`a+1=0`    = bc + a&#39;b</code></pre><h2 id="논리식-간편화-카르노맵-Karnaugh-Map"><a href="#논리식-간편화-카르노맵-Karnaugh-Map" class="headerlink" title="논리식 간편화 카르노맵 (Karnaugh-Map)"></a>논리식 간편화 카르노맵 (Karnaugh-Map)</h2><ul><li>복잡한 논리식을 좀 더 편리하게 간소화할 수 있는 방법 중 하나이다.</li><li>eg. E = a’b + abc + bc</li></ul><img width="305" alt="카노맵" src="https://user-images.githubusercontent.com/28856435/120344782-ddb0cf80-c334-11eb-8764-6f5dd7ced2f1.PNG"><br><h3 id="카르노맵-사용순서"><a href="#카르노맵-사용순서" class="headerlink" title="카르노맵 사용순서"></a>카르노맵 사용순서</h3><ol><li>변수의 개수를 파악하고 2^n개의 테이블을 생성.</li><li>테이블에 식을 분석하여 0과 1을 채워준다.</li><li>인접한 것끼리 묶어준다.</li><li>간소화된 식을 도출 할수 있다.</li></ol><hr><h1 id="조합-논리회로"><a href="#조합-논리회로" class="headerlink" title="조합 논리회로"></a>조합 논리회로</h1><ul><li><code>입력</code>과 <code>출력</code>값을 가진 <code>논리 게이트의 집합</code></li><li>출력은 현재의 <code>입력값</code>과 <code>조합의 함수(AND/XOR ...)</code>이다.</li><li><code>순차 논리회로</code>는 게이트뿐 아니라 기억능력이 있는 <code>플립플롭(Flip-Flop)</code>으로 구성된다.</li></ul><h2 id="조합논리-회로-설계절차"><a href="#조합논리-회로-설계절차" class="headerlink" title="조합논리 회로 설계절차"></a>조합논리 회로 설계절차</h2><ol><li>문제 제시</li><li>입력/출력 변수에 문자기호를 부여</li><li>입력/출력 사이의 관계를 정의하는 진리표 유도</li><li>각 출력에 대한 부울식을 간소화</li><li>논리도 작성</li></ol><h3 id="대표적인-조합회로"><a href="#대표적인-조합회로" class="headerlink" title="대표적인 조합회로"></a>대표적인 조합회로</h3><ul><li><strong>가산기(Adder):</strong> 반가산기, 전가산기</li><li><strong>멀티플렉서(Multiplexer):</strong> <code>다수의 입력선</code> 중 <code>하나만</code>을 선별적으로 출력 가능 (시그널 조작)</li><li><strong>디멀티플렉서(Demultiplexer):</strong> 하나의 입력선을 <code>다수개의 출력선으로 분해</code>하는 기능 (멀티플렉서의 역기능)</li></ul><h2 id="순차회로"><a href="#순차회로" class="headerlink" title="순차회로"></a>순차회로</h2><ul><li>플립플롭과 게이트를 서로 연결한것.</li><li>게이트들로만 이루어진 회로는 조합회로이지만 플립플롭이 포함될 경우 순차회로가 된다.</li><li>순차회로의 특성은 입력, 출력 및 플리플롭의 상태로부터 지어진다. -&gt; <code>상태표, 상태도</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;플리플롭(Flip-Flop) 이란 무엇일까?&lt;br&gt;부울대수 그리고 카르노맵&lt;br&gt;&lt;code&gt;#Pthread&lt;/code&gt; &lt;code&gt;#부울대수&lt;/code&gt; &lt;code&gt;#karnaugh_map&lt;/code&gt; &lt;code&gt;#Flip-Flop&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>💻 컴퓨터구조-컴퓨터 구성요소</title>
    <link href="http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"/>
    <id>http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</id>
    <published>2021-06-01T14:40:54.000Z</published>
    <updated>2021-06-02T02:10:14.784Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="중앙처리-장치와-보조기억장치"><a href="#중앙처리-장치와-보조기억장치" class="headerlink" title="중앙처리 장치와 보조기억장치"></a>중앙처리 장치와 보조기억장치</h1><h2 id="중앙처리장치-Central-Processing-Unit"><a href="#중앙처리장치-Central-Processing-Unit" class="headerlink" title="중앙처리장치(Central Processing Unit)"></a>중앙처리장치(Central Processing Unit)</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li>마더보드(Mother board)<ul><li>산술논리 연산장치(ALU)</li><li>제어장치(CU)</li></ul></li></ul><h3 id="MPU-Micro-Processor-Unit"><a href="#MPU-Micro-Processor-Unit" class="headerlink" title="MPU (Micro Processor Unit)"></a>MPU (Micro Processor Unit)</h3><ul><li>CPU를 LSI(고밀도 집적회로)화 한 일종의 통합장치</li><li>기계어 명령의 길이와 형식에 따라 CISC(Complex Instruction Set Computer)/RISC(Reduced Instruction Set Computer) 로 나뉜다.</li><li>Bit Slice MPU 등이 존재한다.</li><li><strong>CISC</strong><ul><li>컴파일러 작성이 쉬우며 <code>복잡한 명령</code>도 실행 <code>효율</code>이 좋다.</li><li>명령어가 <code>복잡하고 종류가 많다</code>. 디코딩 시간이 오래걸린다.</li></ul></li><li><strong>RISC</strong><ul><li><code>고정된 명령어</code> 길이를 사용하고 <code>종류가 적다</code>. 속도가 빠르다. 효율은 낮다.</li><li>명령수행 속도가 빠르다. 전력 소모가 적다. -&gt; 임베디드 프로세서에 많이 사용한다.</li><li>단순화되어서 연속적으로 중복 수행하는 <code>파이프라인 성능</code>에 최적화 된다.</li><li>단순 -&gt; 설계비용이 줄어든다.</li><li>적은수의 명령어 셋을 이용해 쉽게 프로그래밍 할 수 있다.</li><li>컴파일 최적화 과정이 복잡하다.</li></ul></li></ul><h3 id="사물인터넷-IoT-H-W-플랫폼"><a href="#사물인터넷-IoT-H-W-플랫폼" class="headerlink" title="사물인터넷(IoT) H/W 플랫폼"></a>사물인터넷(IoT) H/W 플랫폼</h3><ul><li>아두이노</li></ul><hr><h2 id="주변장치"><a href="#주변장치" class="headerlink" title="주변장치"></a>주변장치</h2><h3 id="기억장치-Memory-Unit"><a href="#기억장치-Memory-Unit" class="headerlink" title="기억장치(Memory Unit)"></a>기억장치(Memory Unit)</h3><pre><code>- RAM (Random Access Memory)    - DRAM(Dinamic RAM)    - SRAM- ROM (Read Only Memory)    - ROM BIOS 부팅으로 하드디스크에 있는 운영체제를 불러온다.    - 외부에 있는 프로그램을 불러들일 수 있게끔 작동하는 기억장치.</code></pre><h4 id="주기억장치-보조기억장치-관계"><a href="#주기억장치-보조기억장치-관계" class="headerlink" title="주기억장치-보조기억장치 관계"></a>주기억장치-보조기억장치 관계</h4><ol><li>전원 부팅시 CPU는 자동으로 ROM에 있는 프로그램 실행.</li><li>보조기억장치-&gt; RAM <code>적재(load)</code></li><li>RAM &lt;-&gt; CPU 메모리로부터 실행할 명령어와 데이터를 가지고 와서 처리한다.</li><li>RAM -&gt; 보조기억장치 <code>저장(save)</code></li></ol><h3 id="보조기억장치"><a href="#보조기억장치" class="headerlink" title="보조기억장치"></a>보조기억장치</h3><pre><code>- 동작속도 : 저속- 가격: 저렴- 종류    - 플래시 기억장치(RAM과 ROM의 중간위치)    - USB 기억장치    - SD card    - 메모리 스틱</code></pre><h3 id="입출력장치"><a href="#입출력장치" class="headerlink" title="입출력장치"></a>입출력장치</h3><pre><code>- 키보드, 마우스, 스캐너, 터치스크린 등</code></pre><hr><h1 id="컴퓨터-구조와-통신"><a href="#컴퓨터-구조와-통신" class="headerlink" title="컴퓨터 구조와 통신"></a>컴퓨터 구조와 통신</h1><ul><li>혁신적 네트워크 발전 (양자컴퓨터)<ul><li><code>NOS</code>(Network Operating System) 의 역할 확대</li></ul></li></ul><h2 id="비지니스환경의-통신과-네트워킹"><a href="#비지니스환경의-통신과-네트워킹" class="headerlink" title="비지니스환경의 통신과 네트워킹"></a>비지니스환경의 통신과 네트워킹</h2><ul><li>4차 산업혁명을 실현하기 위한 핵심 인프라</li><li>유무선 통신, 방송 통신, 컴퓨터의 융합 등 컨버전스가 가능</li><li>소프트웨어 기술과 고밀도 집적기술의 발달 - 신형 서비스/장비</li><li>사용자 중심의 신기술 발전</li></ul><h2 id="양자-컴퓨터"><a href="#양자-컴퓨터" class="headerlink" title="양자 컴퓨터"></a>양자 컴퓨터</h2><ul><li>중첩(superposition), 얽힘(entanglement) 등 고유한 양자의 물리학적 특성으로, 다수의 정보를 동시에 처리할 수 있는 새로운 컴퓨터</li><li>누전 설류로 인한 고전컴퓨터 성능 한계돌파를 위한 대안</li></ul><h2 id="글로벌인터넷"><a href="#글로벌인터넷" class="headerlink" title="글로벌인터넷"></a>글로벌인터넷</h2><ul><li>1세대: www디렉토리 검색</li><li>2세대: 개방, 참여정신을 바탕으로 쌍방향 웹기술이 가능</li><li>3세대: 시맨틱 웹기술을 활용하여 개인 맞춤형 정보를 제공하는 지능형 웹기술</li><li>4세대: 현실과 가상이 연결되는 초연결 지능화 웹기술</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;기본적인 컴퓨터의 구성요소&lt;br&gt;&lt;code&gt;#CPU&lt;/code&gt; &lt;code&gt;#MPU&lt;/code&gt; &lt;code&gt;#ROM&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>🛢 메모리_mmap</title>
    <link href="http://yoursite.com/2021/05/31/%EB%A9%94%EB%AA%A8%EB%A6%AC-mmap/"/>
    <id>http://yoursite.com/2021/05/31/%EB%A9%94%EB%AA%A8%EB%A6%AC-mmap/</id>
    <published>2021-05-31T08:44:06.000Z</published>
    <updated>2021-06-02T02:10:14.783Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h1 id="메모리-amp-mmap"><a href="#메모리-amp-mmap" class="headerlink" title="메모리 &amp; mmap"></a>메모리 &amp; mmap</h1><h2 id="mmap-함수-사용"><a href="#mmap-함수-사용" class="headerlink" title="mmap 함수 사용"></a>mmap 함수 사용</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fildes, <span class="keyword">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addr: 매핑할 메모리 <code>주소</code></li><li>len: 메모리 <code>공간의 크기</code></li><li>prot: 보호 모드</li><li>flags: 매핑된 데이터의 처리 방법을 지정하는 상수</li><li>fildes: 파일 기술자</li><li>off: 파일 오프셋</li></ul><p><strong><code>문제</code></strong></p><ul><li>기존에 <code>파일 - 프로세스</code> 에 접근할경우,</li><li>프로세스에서는 시스템콜, 스케줄러, 인터럽트 등의 기법을 사용하기 위해 OS가 <code>처리할일이 많아서</code> </li><li>파일을 가지고 있는 CPU에서는 DMA 나 SystemBus 를 사용해야 한다.</li><li>즉, <code>성능이 떨어질 수 밖에</code> 없다.</li></ul><p><strong><code>해결</code></strong></p><ul><li><code>파일 - 메모리 - 프로세스</code> : 중간에 메모리를 두어, 파일의 특정공간을 미리 메모리 영역에 매핑해둔다.</li><li>자주 엑세스할 파일이 있다면, 프로세스는 메모리 영역에 접근하여 빠르게 읽어올 수 있다.</li><li>mmap는 프로세스의 주소공간을 파일에 대응시킨다. 파일은 운영체제 전역적인 자원이므로 당연히 어렵잖게 <code>다른 프로세스와 공유</code>해서 사용할 수 있을 것이다.</li></ul><h2 id="mmap-동작"><a href="#mmap-동작" class="headerlink" title="mmap 동작"></a>mmap 동작</h2><ol><li>mmap 실행시, 가상 메모리 주소에 file 주소를 매핑한다. (페이지 디렉토리)</li><li>해당 메모리 접근시(요구페이징, lazy allocation)</li></ol><ul><li><code>페이지폴트 인터럽트</code> 발생</li><li>OS에서 file data 를 복사해서 물리메모리 페이지에 넣어준다.</li></ul><ol start="3"><li>메모리 read: 해당 물리 페이지 데이터를 읽음</li><li>메모리 write: 해당 물리 페이지 데이터 수정후, 페이지 상태 flag 중 dirty bit를 1로 수정</li><li>파일 close: 물리 페이지 데이터가 file에 업데이트됨. (dirty bit 가 1인곳)</li></ol><h3 id="파일-메모리-가상메모리"><a href="#파일-메모리-가상메모리" class="headerlink" title="파일, 메모리 가상메모리"></a>파일, 메모리 가상메모리</h3><ul><li>장점</li><li>read(), write 시에 반복적인 파일접근을 방지하여 성능을 개선한다.</li><li>mapping 된 영역은 파일 처리를 위한 lseek() <code>file-&gt;data주소 찾아가는 함수</code>를 사용하지 않고 간단한 포인터 조작으로 탐색.</li></ul><p>단점</p><ul><li>mmap은 내부적으로 가상메모리와 연관되어 <code>페이지 사이즈 단위로 매핑</code>된다. 그런데 고정된 페이지 사이즈 단위보다 클 경우 추가공간이 필요하고, 적을 경우 공간낭비(0으로 채움)가 일어난다.</li></ul><h2 id="파일처리-성능개선-munmap"><a href="#파일처리-성능개선-munmap" class="headerlink" title="파일처리 성능개선 munmap"></a>파일처리 성능개선 munmap</h2><ul><li>*addr 에 mapping 된 물리 메모리 주소를 해제한다.</li><li>lenght: mapping된 메모리크기 (mmap과 동일값)</li></ul><h2 id="맵핑된-메모리-영역을-동기화-하는-방법"><a href="#맵핑된-메모리-영역을-동기화-하는-방법" class="headerlink" title="맵핑된 메모리 영역을 동기화 하는 방법"></a>맵핑된 메모리 영역을 동기화 하는 방법</h2><ul><li>MS_ASYNC: 비동기 방식으로 결과에 관계 없이 프로그램 속행</li><li>MS_SYNC: 동기 방식으로 결과를 확인 후 프로그램 속행</li><li>MS_ALERT: 동기화 후 시그널을 통해 알림.</li><li>MS_INVALIDATE: 현제 메모리 맵을 무효화함.</li></ul><hr><h1 id="inode-방식-파일시스템"><a href="#inode-방식-파일시스템" class="headerlink" title="inode 방식 파일시스템"></a>inode 방식 파일시스템</h1><ul><li>inode의 메타데이터에는 아래와 같은 정보들이 포함된다.</li></ul><ul><li>Mode: 파일종류/권한</li><li>Owner Info: 소유자,소울그룹</li><li>Size: 파일사이즈</li><li>Timestamps: 생성, 수정시간</li><li>Direct blocks (12개): 직접적으로 주소가리킴</li><li>Single inderect, Double inderect, Triple inderect: 간접적 주소가리킴</li></ul><blockquote><p>이러한 inode 메타데이터를 모두 가져오는 함수가 있다. <code>stat</code> 함수</p></blockquote><h2 id="stat-함수"><a href="#stat-함수" class="headerlink" title="stat 함수"></a>stat 함수</h2><blockquote><p><strong>사용 문법</strong><br>int stat(const char *path, struct stat *buf);<br>*buf : 구조체 변수</p></blockquote><ul><li>stat: 파일을 <code>filepath</code> 로 지정한다.</li><li>fstat: 파일을 <code>fd 넘버</code>로 지정한다.</li><li>lstat: 파일을 <code>filepath 로 지정</code>하되 지정된 파일이 <code>심볼릭 링크 파일</code>이면 링크파일 자체에 대한 정보를 얻는다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"> <span class="keyword">dev_t</span>     st_dev;  <span class="comment">// ID of device containing file</span></span><br><span class="line">                          <span class="comment">// :: 가상파일 시스템 file-system interface 를 사용하여 하단부에 있는 실제    디바이스의  종류는 달리할 수 있다. `추상화` `UNIX 모든것은 파일`</span></span><br><span class="line"> <span class="keyword">ino_t</span>     st_ino;  <span class="comment">// inode number</span></span><br><span class="line"> <span class="keyword">mode_t</span>    st_mode;  <span class="comment">// 파일 종류 및 접근권한</span></span><br><span class="line"> <span class="keyword">nlink_t</span>   st_nlink;  <span class="comment">// hardlink 의 횟수</span></span><br><span class="line"> <span class="keyword">uid_t</span>     st_uid;  <span class="comment">// 파일 owner</span></span><br><span class="line"> <span class="keyword">gid_t</span>     st_gid;  <span class="comment">// group ID of owner</span></span><br><span class="line"> <span class="keyword">off_t</span>     st_size;  <span class="comment">// 파일크기</span></span><br><span class="line"> <span class="keyword">blksize_t</span> st_blksize; <span class="comment">// blocksize for file system I/O</span></span><br><span class="line"> <span class="keyword">blkcnt_t</span>  st_blocks;  <span class="comment">// number of 512B blocks allocated</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_atime;  <span class="comment">// time if last access</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_mtime;  <span class="comment">// time if last modification</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_ctime;  <span class="comment">// time if last status change</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stat-test-c-실습"><a href="#stat-test-c-실습" class="headerlink" title="stat-test.c 실습"></a>stat-test.c 실습</h3><ul><li>실제로 hello.txt 라는 파일의 메타데이터를 출력해보는 stat-test.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret= <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">  ret= <span class="built_in">stat</span>(<span class="string">&quot;hello.txt&quot;</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;deviceId:%ld, inode:%ld, hardLinkCount:%ld, filesize: %ld, blockSize:%ld, blockCount:%ld \n&quot;</span>, buf.st_dev, buf.st_ino, buf.st_nlink, buf.st_size, buf.st_blksize, buf.st_blocks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>출력 결과</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> ./stat-test</span></span><br><span class="line">deviceId:51713, inode:256331, hardLinkCount:1, filesize: 7, blockSize:4096, blockCount:8</span><br></pre></td></tr></table></figure><h1 id="Standard-Stream-표준-입출력-스트림"><a href="#Standard-Stream-표준-입출력-스트림" class="headerlink" title="Standard Stream 표준 입출력 스트림"></a>Standard Stream 표준 입출력 스트림</h1><ul><li>모든 스트림은 일반적인 plain text로 console에 출력된다.</li><li>표준 입력 스트림(Standard Input Stream): stdid</li><li>표준 입력 스트림(Standard Ouput Stream): stdout</li><li>표준 입력 스트림(Standard Error Stream): stderr</li></ul><h3 id="std-test-c-실습"><a href="#std-test-c-실습" class="headerlink" title="std-test.c 실습"></a>std-test.c 실습</h3><ul><li>아래 프로그램을 실행하면, 터미널에 입력할 때마다 stdin 에 들어가고, stdout 으로 출력되는 것을 확인할 수 있다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">  FILE* fp; <span class="comment">// 파일 디스크립터</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;  <span class="comment">// 인자가 들어오면,</span></span><br><span class="line">    fp= <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>); <span class="comment">// 읽기오픈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;file open error&quot;</span>, stderr);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fp= stdin; <span class="comment">// 터미널에 입력된 데이터가 표준입력(stdin)에 들어간다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="number">255</span>, fp) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stdout); <span class="comment">// 파일 표준출력(stdout)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>실행 결과</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> ./std-test</span></span><br><span class="line">hello // stdin</span><br><span class="line">hello // stdout</span><br><span class="line">입력  // stdin</span><br><span class="line">입력  // stdout</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;메모리와 관련된 mmap 함수의 사용법을 알아본다.&lt;br&gt;stat 함수 사용으로 inode 메타데이터를 출력해본다.&lt;br&gt;&lt;code&gt;#mmap&lt;/code&gt; &lt;code&gt;#stat&lt;/code&gt; &lt;code&gt;#inode&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>스레드 pthread 구현</title>
    <link href="http://yoursite.com/2021/05/27/%EC%8A%A4%EB%A0%88%EB%93%9C-pthread-%EA%B5%AC%ED%98%84/"/>
    <id>http://yoursite.com/2021/05/27/%EC%8A%A4%EB%A0%88%EB%93%9C-pthread-%EA%B5%AC%ED%98%84/</id>
    <published>2021-05-27T14:50:54.000Z</published>
    <updated>2021-06-03T09:31:07.432Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="스레드"><a href="#스레드" class="headerlink" title="스레드"></a>스레드</h1><h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><ul><li><code>POSIX 스레드</code> 또는 <code>Pthread</code> 라고 부른다.</li><li>저수준 API로 100 여개의 함수 제공</li><li>복잡하지만 유닉스 시스템 핵심 스레딩 라이브러리</li><li>다른 스레딩 솔루션도 결국 Pthread 를 기반으로 구현되어 있으므로 익혀둘 가치가 있다.</li><li>기본 라이브러리 <code>(glibc) 와 분리</code>된 <code>libpthread</code> 라이브러리에 pthread 구현되어 있으므로<br>컴파일시 명시적으로 <code>pthread 옵션</code>이 필요하다.</li><li>pthread API는 <code>Semaphore를 포함하지 않는다</code>.</li></ul><h2 id="Pthread-라이브러리"><a href="#Pthread-라이브러리" class="headerlink" title="Pthread 라이브러리"></a>Pthread 라이브러리</h2><ul><li>&lt;pthread.h&gt; 헤더 파일에서 정의한다.</li><li>모든함수는 <code>pthread_</code> 로 시작한다.</li></ul><h2 id="스레드-생성"><a href="#스레드-생성" class="headerlink" title="스레드 생성"></a>스레드 생성</h2><ul><li>스레드 생성<ul><li>thread_inst(): 9까지 출력</li><li>main 함수: thread_inst 스레드 생성후, 4까지 출력</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">include&lt;pthread.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void * thread_inst(void *arg)&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    tid = pthread_self();</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;10)&#123;</span><br><span class="line">        printf(&quot;[%lx] new thread: %d\n&quot;, tid, i);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, NULL, thread_inst, NULL);</span><br><span class="line">    pthread_t tid= pthread_self();</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;5)&#123;</span><br><span class="line">        printf(&quot;[%lx] main thread: %d\n&quot;, tid, i);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>스레드 실행결과<ul><li>아래처럼 9까지 출력되어야 할 new thread 는 main 함수가 끝나니 함께 끝나버렸다.</li><li>다음 예제의 pthread_join 추가가 필요하다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ gcc pthread.c -pthread -o pthread</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ./pthread</span><br><span class="line">[7f93eb31c740] main thread: 0</span><br><span class="line">[7f93eaaee700] new thread: 0</span><br><span class="line">[7f93eb31c740] main thread: 1</span><br><span class="line">[7f93eaaee700] new thread: 1</span><br><span class="line">[7f93eb31c740] main thread: 2</span><br><span class="line">[7f93eaaee700] new thread: 2</span><br><span class="line">[7f93eb31c740] main thread: 3</span><br><span class="line">[7f93eaaee700] new thread: 3</span><br><span class="line">[7f93eb31c740] main thread: 4</span><br><span class="line">[7f93eaaee700] new thread: 4</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="스레드-관리"><a href="#스레드-관리" class="headerlink" title="스레드 관리"></a>스레드 관리</h2><ul><li>리소스</li></ul><ol><li>pthread_join</li></ol><ul><li>메인 스레드에서 해당 스레드가 종료되면, 상태값을 보고 메인스레드에서 <code>추가처리</code>를 할 수 있다.</li></ul><ol start="2"><li>pthread_detach(thread1)</li></ol><ul><li>관련 리소스를 <code>즉시 해제</code>한다.</li></ul><ul><li>실행</li></ul><ol><li>pthread_join</li></ol><ul><li>스레드 1이 종료될때까지 다음코드를 수행하지 않고 <code>기다린다</code>.</li></ul><ol start="2"><li>pthread_detach</li></ol><ul><li>스레드 1이 종료될때까지 <code>기다리지 않는다</code>.</li></ul><h2 id="Pthread-뮤텍스-상호배제-기법"><a href="#Pthread-뮤텍스-상호배제-기법" class="headerlink" title="Pthread 뮤텍스 - 상호배제 기법"></a>Pthread 뮤텍스 - 상호배제 기법</h2><pre><code class="~~`"></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;POSIX thread와 그 사용법 익혀보기.&lt;br&gt;&lt;code&gt;#Pthread&lt;/code&gt; &lt;code&gt;#pthread_join&lt;/code&gt; &lt;code&gt;#pthread_detach&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>프로세스 IPC 기법</title>
    <link href="http://yoursite.com/2021/05/26/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-IPC-%EA%B8%B0%EB%B2%95/"/>
    <id>http://yoursite.com/2021/05/26/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-IPC-%EA%B8%B0%EB%B2%95/</id>
    <published>2021-05-26T14:13:08.000Z</published>
    <updated>2021-05-31T00:52:37.997Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="IPC-기법"><a href="#IPC-기법" class="headerlink" title="IPC 기법"></a>IPC 기법</h1><h2 id="파이프"><a href="#파이프" class="headerlink" title="파이프"></a>파이프</h2><ul><li>부모 프로세스와 자식 프로세스가 같은 <code>kernel 공간</code>을 공유한다. 즉, 같은 물리주소를 바라보고 있다.</li><li><code>단방향</code> 통신이다. 부모프로세스 -&gt; 자식프로세스</li></ul><h3 id="파이프-예제"><a href="#파이프-예제" class="headerlink" title="파이프 예제"></a>파이프 예제</h3><ul><li>부모프로세스가 <code>write</code> 한 msg를 <code>pipe</code>를 통해 자식프로세스가 <code>read</code> 한다.</li></ul><ul><li>pipe.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* msg=<span class="string">&quot;Hello Child Process&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>], pid, nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 파이프 생성: pipe(fd)= -1이면 pipe가 생성되지 않은것.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pipe</span>(fd)&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 종료</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 부모-자식 프로세스 생성</span></span><br><span class="line">        pid= fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after fork pid : %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123; <span class="comment">// 부모 프로세스</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[1] Parent: %d, Child: %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">                <span class="comment">// 부모 프로세스가 fd[1] 에 쓴다.</span></span><br><span class="line">                <span class="built_in">write</span>(fd[<span class="number">1</span>], msg, MSGSIZE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//자식 프로세스에는 pid값이 0</span></span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">&quot;[2] Parent: %d, Child: %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line"></span><br><span class="line">                 nbytes = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, MSGSIZE);</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">&quot;nbytes: %d , msg: %s\n&quot;</span>, nbytes, buf);</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="파이프-실행-결과"><a href="#파이프-실행-결과" class="headerlink" title="파이프 실행 결과"></a>파이프 실행 결과</h3><ul><li>pid=0 일 때 자식 프로세스이며, 아래와 같이 부모 프로세스가 저장한 <code>msg</code> 를 읽어오는 것을 확인할 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./_ipc</span></span><br><span class="line">[1] Parent: 21768, Child: 21769</span><br><span class="line"><span class="meta">$</span><span class="bash"> [2] Parent: 21769, Child: 0</span></span><br><span class="line">nbytes: 255 , msg: Hello Child Process</span><br></pre></td></tr></table></figure><hr><h2 id="메시지-큐"><a href="#메시지-큐" class="headerlink" title="메시지 큐"></a>메시지 큐</h2><ul><li><code>kernel 공간</code>의 메모리를 사용한다.</li><li><code>양방향</code> 통신이 가능하다.</li><li>먼저 들어간 메시지부터 읽는다.</li></ul><h3 id="메시지-큐-예시"><a href="#메시지-큐-예시" class="headerlink" title="메시지 큐 예시"></a>메시지 큐 예시</h3><ul><li><p> <code>msgrcv</code>(int msgid, void *msgp, size_t msgsz, long msgtype, int msgflag)</p></li><li><p>msgtype: 0일때 첫번째 데이터부터 읽고 그 이상이라면 그 type에 일치하는 데이터부터 읽는다.</p></li><li><p>msgflag: 0: 블록모드, IPC_NOWAIT: 비블록모드</p></li><li><p>보내는 프로세스 msgSnd.c, 받는 프로세스 msgRcv.c 를 따로 만들어 수행한다.</p></li></ul><ul><li>msgSnd.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> type;</span><br><span class="line">        <span class="keyword">char</span> text[<span class="number">50</span>];</span><br><span class="line">&#125; MsgBuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> msgid, len;</span><br><span class="line">        MsgBuf msg;</span><br><span class="line">        <span class="keyword">key_t</span> key = <span class="number">1234</span>;</span><br><span class="line">        <span class="comment">// IPC_CREAT: 새로운 키는 식별자 생성(접근권한)</span></span><br><span class="line">        msgid= <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0644</span>); <span class="comment">// =&gt; rw‑r‑‑r‑‑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.type = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 아래 메시지 전송</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg.text, <span class="string">&quot;Message Queue is Executed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgsnd</span>(msgid, (<span class="keyword">void</span> *)&amp;msg, <span class="number">50</span>, IPC_NOWAIT) == <span class="number">-1</span>)&#123; </span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>msgRcv.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> type;</span><br><span class="line">        <span class="keyword">char</span> text[<span class="number">50</span>];</span><br><span class="line">&#125; MsgBuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> msgid, len;</span><br><span class="line">        MsgBuf msg;</span><br><span class="line">        <span class="keyword">key_t</span> key = <span class="number">1234</span>;</span><br><span class="line">        <span class="comment">// IPC_CREAT: 새로운 키는 식별자 생성(접근권한)</span></span><br><span class="line">        msgid= <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0644</span>); <span class="comment">// =&gt; rw‑r‑‑r‑‑</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        len= <span class="built_in">msgrcv</span>(msgid, &amp;msg, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got a Message ! =&gt; %s [%d] \n&quot;</span>, msg.text, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="메시지큐-실행-결과"><a href="#메시지큐-실행-결과" class="headerlink" title="메시지큐 실행 결과"></a>메시지큐 실행 결과</h3><ul><li>msgSnd - 보내고 , msgRcv - 받는다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ gcc msgRcv.c -o msgRcv</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ gcc msgSnd.c -o msgSnd</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./msgSnd</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./msgRcv</span><br><span class="line">Got a Message ! =&gt; Message Queue is Executed</span><br><span class="line"> [50]</span><br></pre></td></tr></table></figure><br><blockquote><p><strong>ftok() - 키 생성을 위한 함수</strong></p><ul><li>path 경로명의 inode 값과 숫자값(id)을 기반으로 생성된다.</li><li>경로 삭제 후 재생성시 inode값이 달라지므로 기존과 다른 값을 리턴한다.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 예시</span></span><br><span class="line">key = <span class="built_in">ftok</span>(<span class="string">&quot;keyfile&quot;</span>, <span class="number">1</span>); <span class="comment">// 메시지큐를 통해서 부모-자식 프로세스 간 공유</span></span><br><span class="line">id = <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0640</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;IPC 기법을 직접 실습해본다.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="ipc" scheme="http://yoursite.com/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>시스템콜을 이용한 프로세스 관리</title>
    <link href="http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/"/>
    <id>http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/</id>
    <published>2021-05-24T13:24:11.000Z</published>
    <updated>2021-05-31T07:43:32.170Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h1><ul><li>생성과정<br>(1) TEXT, DATA, BSS, HEAP, STACK 의 공간을 생성한다.<br>(2) 프로세스 이미지를 해당 공간에 업로드하고 실행한다.</li></ul><h2 id="프로세스-소유자-관리"><a href="#프로세스-소유자-관리" class="headerlink" title="프로세스 소유자 관리"></a>프로세스 소유자 관리</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/shadow</span></span><br></pre></td></tr></table></figure><h1 id="시스템콜-함수사용"><a href="#시스템콜-함수사용" class="headerlink" title="시스템콜 함수사용"></a>시스템콜 함수사용</h1><h2 id="getpid-getppid-시스템콜"><a href="#getpid-getppid-시스템콜" class="headerlink" title="getpid() getppid() 시스템콜"></a>getpid() getppid() 시스템콜</h2><ul><li>getpid(), getppid() 함수를 사용하여 test_ps.c 프로그램 예시.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ppid=%d\n&quot;</span>, getppid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아래와 같이 <code>pid</code>, <code>ppid</code> 가 정상적으로 출력되는것을 확인할 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~/test$ gcc test_ps.c -o test_ps</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ls</span><br><span class="line">dir  loop.c  soft  soft_link  softlink  test_ps  test_ps.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ./test_ps</span><br><span class="line">pid=14611</span><br><span class="line">ppid=14529</span><br></pre></td></tr></table></figure><h2 id="fork-exec-프로세스-생성"><a href="#fork-exec-프로세스-생성" class="headerlink" title="fork() exec() - 프로세스 생성"></a>fork() exec() - 프로세스 생성</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><blockquote><p>새로운 프로세스 공간을 별도로 만들고, fork() 를 호출한 프로세스(부모) 공간을 모두 <code>복사</code>한다.</p></blockquote><ul><li><p>함수 사용</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;unistd.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>자식프로세스는 <code>pid=0</code>, 부모프로세스는 <code>실제 pid</code></p></li><li><p>pid= fork() 실행되면 부모 프로세스와 동일한 자식 프로세스를 <code>별도 메모리공간</code>에 생성한다.</p></li><li><p>두 프로세스의 변수, PC(Program Counter)값은 동일하다.</p></li></ul><ul><li>_fork.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before fork() call\n&quot;</span>);</span><br><span class="line"> <span class="comment">// -- 여기까지 프로세스는 1개</span></span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child Process&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><blockquote><p>호출한 현재 프로세스 공간의 <code>TEXT, DATA, BSS</code> 영역을 새로운 프로세스의 이미지로 <code>덮어씌운다</code>. 별도의 공간을 만들지 않는다.</p></blockquote><ul><li>헤더</li><li>함수 6가지</li><li>execlp : path 명 포함. </li></ul><ul><li>_execl.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;execute ls\n&quot;</span>);</span><br><span class="line">  execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// argv[0]=ls, argv[1]=-l</span></span><br><span class="line">  <span class="comment">// -- 기존의 &#x27;ls al&#x27; 의 기능이 덮어씌워진다.</span></span><br><span class="line">  perror(execl is failed\n);</span><br><span class="line">  <span class="comment">// - 에러코드 출력</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="wait-기다림"><a href="#wait-기다림" class="headerlink" title="wait() - 기다림"></a>wait() - 기다림</h2><blockquote><ul><li>fork() 함수 호출시 자식 프로세스가 종료할 때까지 <code>부모 프로세스가 기다린다.</code></li><li>wait() 자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 먼저 죽는 경우를 막기 위해 사용한다. (고아 프로세스: 자식 프로세스가 메모리를 계속 사용하고 있을 수 있다.)</li><li>자식 프로세스의 일이 끝나면 부모 프로세스에 <code>SIGCHLD</code> 시그널을 보낸다. </li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/28856435/119525382-6a99dd00-bdb9-11eb-9517-fd7ebb48d420.jpg" alt="KakaoTalk_20210526_002054322"></p><br><h3 id="wait-시스템콜-사용"><a href="#wait-시스템콜-사용" class="headerlink" title="wait() 시스템콜 사용"></a>wait() 시스템콜 사용</h3><ul><li>리턴값은 종료된 <code>자식 프로세스의 pid</code> 이다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span> <span class="params">(<span class="keyword">int</span> *status)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 사용: status 를 통해 자식 프로세스 정보 확인</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WIFEXITED</span><span class="params">(status)</span></span>; <span class="comment">// 0 이 아닐때 정상종료</span></span><br></pre></td></tr></table></figure><ul><li>test_wait.c 실습</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="keyword">int</span> child_pid;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  pid= fork();</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span>(pid)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;fork is failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    csae <span class="number">0</span>: <span class="comment">// pid : 자식</span></span><br><span class="line">      <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;execl is failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// pid : 부모</span></span><br><span class="line">      <span class="comment">// 부모프로세스는 자식 프로세스가 끝나길 기다림</span></span><br><span class="line">      <span class="comment">// status에 자식프로세스의 상태를 담아줌</span></span><br><span class="line">      child_pid= <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Parent PID(%d), Child PID (%d)\n&quot;</span>, <span class="built_in">getpid</span>(), child_pid)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0 이 아니면 정상종료.</span></span><br><span class="line">      ret = <span class="built_in">WIFEXITED</span>(status);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 정상종료</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is normally terminated\n&quot;</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 비정상 종료</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is abnormally terminated\n&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fork-execl-wait-사용한-프로그램-만들기"><a href="#fork-execl-wait-사용한-프로그램-만들기" class="headerlink" title="fork(), execl(), wait() 사용한 프로그램 만들기"></a>fork(), execl(), wait() 사용한 프로그램 만들기</h2><ul><li>execl() 만 사용하면, 부모 프로세스가 사라진다.</li><li>이를 유지위해 fork() 로 새로운 공간 복사 후, execl() 사용.</li></ul><ul><li>fork_execl_wait.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">        <span class="keyword">int</span> proc_status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DaveShell ver 1.0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// memset(void *ptr, int value, size_t num);</span></span><br><span class="line">            <span class="comment">// ptr: 채우고자하는 메모리 시작포인터</span></span><br><span class="line">            <span class="comment">// value: 메모리에서 채우고자하는값. 1byte마다 0x00(64)로 초기화</span></span><br><span class="line">            <span class="comment">// sizeof: 배열의 전체 바이트 크기</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, MAXLINE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// buf 출력해보기</span></span><br><span class="line">            <span class="comment">// for(int i=0; i&lt;(sizeof(buf)/sizeof(char)); i++)&#123;</span></span><br><span class="line">            <span class="comment">//     printf(&quot;%c\n&quot;, buf[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// char *fgets (char *string, int n, FILE *stream)</span></span><br><span class="line">            <span class="comment">// -- 파일에서 최대 MAXLINE-1 만큼 읽어서  buf 에 담음</span></span><br><span class="line">            <span class="built_in">fgets</span>(buf, MAXLINE<span class="number">-1</span>, stdin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf, <span class="string">&quot;exit\n&quot;</span>, <span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="comment">// strncmp(buf와 &#x27;exit\n&#x27; 의 문자열이 size5만큼) 같은지 문자열 비교</span></span><br><span class="line">              <span class="comment">// exit 를 입력후 enter치면 while문 종료</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 새로운 공간을 만들고 부모프로세스로부터 복사</span></span><br><span class="line">            pid= fork();</span><br><span class="line">            <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123; <span class="comment">// 자식 프로세스</span></span><br><span class="line">                <span class="comment">// 실행한 사용자의 PATH 환경변수</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">execl</span>(buf, buf, <span class="literal">NULL</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;command execution is failed\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 자식 프로세스 waiting</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fork_execl_wait 결과<ul><li><code>/bin/ls</code> 를 입력하면 해당 명령 수행.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ ./fork_exec_wait</span><br><span class="line">DaveShell ver <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">/bin/ls</span><br><span class="line">a.txt  a_link.txt  b.txt  b_link.txt  fork_exec_wait  fork_exec_wait.c</span><br></pre></td></tr></table></figure><h3 id="copy-on-write-COW-프로세스-생성"><a href="#copy-on-write-COW-프로세스-생성" class="headerlink" title="copy-on-write(COW) - 프로세스 생성"></a>copy-on-write(COW) - 프로세스 생성</h3><blockquote><p>copy-on-write<br><code>수정 (쓰기;write)</code> 가 일어날 때 복사한다.</p></blockquote><ul><li>자식 프로세스 생성시, 부모 프로세스 자원(페이지)을 우선 사용한다.</li><li>커널 공간을 공유한다.</li><li><code>READ</code> 요청<br>자식 프로세스 생성시, 부모 프로세스에서 사용하고 있는 물리주소를 그대로 사용(포인터랑 비슷하다고 생각하면 된다.)</li><li><code>WRITE</code> 요청<br>(1) write 요청<br>(2) Physical Memory : 부모 프로세스로의 물리 메모리 복사<br>(3) PCB : 자식 프로세스의 Page Pointer 변경</li></ul><h2 id="exit-프로세스-종료"><a href="#exit-프로세스-종료" class="headerlink" title="exit() - 프로세스 종료"></a>exit() - 프로세스 종료</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line"><span class="comment">// EXIT_SUCCESS 는 0, exit(EXIT_SUCCESS); // EXIT_SUCCESS 는 0</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><ul><li>main 함수의 return 0; 과 exit(0)l 의 차이</li><li><code>exit() </code> : 즉시 프로세스를 종료한다. exit()함수 다음에 있는 코드는 실행하지 않는다.</li><li><code>return 0</code> : 단순히 함수를 종료한다. 단, <code>main() 함수</code> 에서는 C 언어 실행파일에 포함된 <code>_start()</code> 함수를 호출한 뒤, 결과적으로는 exit() 함수가 호출된다.</li></ul><h3 id="exit-주요동작"><a href="#exit-주요동작" class="headerlink" title="exit() 주요동작"></a>exit() 주요동작</h3><ul><li>atexit()에 등록된 함수 실행</li><li>열려 있는 모든 입출력 스트림버퍼 삭제 (stdin, stdout, stdrerr 데이터)</li><li>프로세스가 오픈한 파일을 모두 닫는다.</li><li>tmpfile() 함수를 통해 생성된 임시파일 삭제</li><li><code>FILE *tmpfile(void)</code></li></ul><h3 id="atexit-함수-예제"><a href="#atexit-함수-예제" class="headerlink" title="atexit() 함수 예제"></a>atexit() 함수 예제</h3><ul><li>atexit()에 등록된 함수 실행 순서를 확인하는 예제이다.</li></ul><ul><li>test_exit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodbye</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">atexit</span>(hello);</span><br><span class="line">    <span class="keyword">if</span> (ret!=<span class="number">0</span>) <span class="built_in">perror</span>(<span class="string">&quot;Error in atexit\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">atexit</span>(goodbye);</span><br><span class="line">    <span class="keyword">if</span> (ret!=<span class="number">0</span>) <span class="built_in">perror</span>(<span class="string">&quot;Error in atexit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">goodbye</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;see you!\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아래와 같은 실행 결과를 보면, 아래서부터 반대로 수행한다. goodbye() 함수 수행 후 hello()함수가 수행되었다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> see you!</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br></pre></td></tr></table></figure><h2 id="우선순위-기반-스케줄러"><a href="#우선순위-기반-스케줄러" class="headerlink" title="우선순위 기반 스케줄러"></a>우선순위 기반 스케줄러</h2><ul><li>Priority-Based 스케줄러 (우선순위 스케줄링)<ul><li>동적/정적</li></ul></li><li>프로세스 중 <code>root</code> 가 소유한 프로세스만 우선순위를 높일 수 있다. 그 외의 프로세스는 낮출 수만 있다.<ul><li>즉, 일반유저는 nice 값을 증가만 가능하며 root는 nice값을 감소시켜서 우선순위를 높일 수 있다.</li></ul></li><li>스케줄링 방식에 따라 <code>효과가 없을 수도</code> 있다.</li></ul><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h3><ul><li>기본값은 보통 <code>0</code>으로 시작한다.</li><li><code>-20 ~ 19</code> 까지 순위값을 조정할 수 있다.</li><li>값이 <code>작을수록</code> 우선순위가 높다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span> <span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>nice -n 10 bash</code> bash 프로세스 기존값에서 10을 증가 시킨다.</li><li>새로운 프로세스가 추가된다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R  1000   394 27607  0  80   0 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  80   0 -  5814 wait   pts/0    00:00:00 bash</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ nice -n 10 bash</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   461 27607  0  90  10 -  5752 wait   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000   470   461  0  90  10 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  80   0 -  5814 wait   pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure><h3 id="renice"><a href="#renice" class="headerlink" title="renice"></a>renice</h3><ul><li>nice 와 달리 기존의 PID 로 우선순위를 조정한다.</li><li><code>renice 15 27607</code> PID 27607의 우선순위를 10-&gt;15로 조정</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ renice 15 27607</span><br><span class="line">27607 (process ID) old priority 0, new priority 15</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   461 27607  0  90  10 -  5752 wait   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000   492   461  0  90  10 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  95  15 -  5814 wait   pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure><h3 id="getpriority-setpriority"><a href="#getpriority-setpriority" class="headerlink" title="getpriority/setpriority"></a>getpriority/setpriority</h3><ul><li>스케줄링 조작 시스템콜을 기본 제공한다. (POSIX 기반)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p><code>which</code> 옵션</p><ul><li>프로세스(PRIO_PROCESS)</li><li>프로세스 그룹(PRIO_PGRP)</li><li>사용자(PRIO_USER)</li></ul><ul><li>root 소유로 우선순위변경 실행</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> which = PRIO_PROCESS;</span><br><span class="line"><span class="keyword">id_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">pid = <span class="built_in">getpid</span>();</span><br><span class="line">ret = <span class="built_in">getpriority</span>(which, pid); <span class="comment">// 프로세스 우선순위를 가져온다.</span></span><br><span class="line">ret = <span class="built_in">setpriority</span>(which, pid, <span class="number">5</span>); <span class="comment">//프로세스의 우선순위를 5로 설정</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜 함수를 직접 사용하면서 프로세스의 생성과 종료, 우선순위 관리까지 경험해본다.&lt;br&gt;&lt;code&gt;#fork&lt;/code&gt; &lt;code&gt;#exec&lt;/code&gt; &lt;code&gt;#wait&lt;/code&gt; &lt;code&gt;#COW&lt;/code&gt; &lt;code&gt;#exit&lt;/code&gt; &lt;code&gt;#nice&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="system_call" scheme="http://yoursite.com/tags/system-call/"/>
    
  </entry>
  
  <entry>
    <title>AWS-Docker,Jira 설치</title>
    <link href="http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/"/>
    <id>http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/</id>
    <published>2021-05-22T11:46:29.000Z</published>
    <updated>2021-05-25T00:54:42.539Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="AWS-인스턴스에서-Docker-설치"><a href="#AWS-인스턴스에서-Docker-설치" class="headerlink" title="AWS 인스턴스에서 Docker 설치"></a>AWS 인스턴스에서 Docker 설치</h1><ul><li>jira container 는 메모리를 많이 차지하기 때문에 AWS 인스턴스는 최소 <code>t2.larg</code> 로 선택해야 한다.<blockquote><p>$ sudo yum install docker-io</p></blockquote></li></ul><!-- [rectangle setX: 10 y: 10 width: 20 height: 20]; --><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -i suyeon.pem ec2-user@15.164.50.108</span></span><br><span class="line">The authenticity of host &#x27;15.164.50.108 (15.164.50.108)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:KwsFct4EwSLlShPOuWPC0yr0ewcI4lGT352J9tLKKwQ.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;15.164.50.108&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line"></span><br><span class="line">       __|  __|_  )</span><br><span class="line">       _|  (     /   Amazon Linux 2 AMI</span><br><span class="line">      ___|\___|___|</span><br><span class="line"></span><br><span class="line">https://aws.amazon.com/amazon-linux-2/</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ ^C</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker</span><br><span class="line">-bash: docker: command not found</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo yum install docker-io</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-ps-a-리스트-확인"><a href="#docker-ps-a-리스트-확인" class="headerlink" title="docker ps -a 리스트 확인"></a>docker ps -a 리스트 확인</h2><ul><li>Is the docker daemon running? : 도커를 실행해준다.</li><li><code>sudo systemctl start docker</code></li><li>dial unix /var/run/docker.sock: connect: permission denied : 권한 부여</li><li><code>sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo systemctl start docker</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/d</span><br><span class="line">dbus/               dhclient-eth0.pid   dmeventd-server     docker.pid</span><br><span class="line">dhclient6-eth0.pid  dmeventd-client     docker/             docker.sock</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</span><br></pre></td></tr></table></figure><ul><li>잘 실행된다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><hr><h1 id="Jira-협업툴-설치"><a href="#Jira-협업툴-설치" class="headerlink" title="Jira 협업툴 설치"></a>Jira 협업툴 설치</h1><ol><li>기존 지라 도커 컨테이너 삭제</li><li>지라 도커 컨테이너 설치<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull cptactionhank/atlassian-jira-software:latest</span></span><br></pre></td></tr></table></figure></li><li>지라 도커 컨테이너 생성</li></ol><ul><li>``<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker create --restart=no --name <span class="string">&quot;jira-container&quot;</span>\</span></span><br><span class="line"><span class="bash"> --publish <span class="string">&quot;8080:8080&quot;</span>\</span></span><br><span class="line"><span class="bash"> --volume <span class="string">&quot;hostpath:/var/atlassian/jira&quot;</span>\</span></span><br><span class="line"><span class="bash"> --env <span class="string">&quot;CATALINA_OPTS= -Xms1024m -Xmx1024m -Datlassian.plugins.enable.wait=300&quot;</span>\</span></span><br><span class="line"><span class="bash"> cptactionhank/atlassian-jira-software:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 0c8922efd3800885da4b46af5bc17e6804fc91b102e186dec61efa41e39f117d</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>지라 도커 컨테이너 실행<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS 에서 Jira와 Docker를 설치해보자.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ AWS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-AWS/"/>
    
    
  </entry>
  
  <entry>
    <title>📲 시스템콜과 API</title>
    <link href="http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/"/>
    <id>http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/</id>
    <published>2021-05-20T14:59:59.000Z</published>
    <updated>2021-05-25T00:54:42.546Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="시스템콜"><a href="#시스템콜" class="headerlink" title="시스템콜"></a>시스템콜</h1><ul><li>주요 시스템콜 명령어</li></ul><table><thead><tr><th>%eax</th><th>Kernel Function(System call)</th><th>%ebx</th><th>%ecx</th><th>%edx</th></tr></thead><tbody><tr><td>1</td><td>sys_exit(exit)</td><td>int</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork(fork)</td><td>struct pt_regs</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read(read)</td><td>unsigned int</td><td>char *</td><td>size_t</td></tr><tr><td>4</td><td>sys_write(write)</td><td>unsigned int</td><td>const char *</td><td>size_t</td></tr><tr><td>5</td><td>sys_open(open)</td><td>const char *</td><td>int</td><td>int</td></tr><tr><td>6</td><td>sys_close(clsoe)</td><td>unsigned int</td><td>-</td><td>-</td></tr></tbody></table><h2 id="시스템콜은-어떻게-구현"><a href="#시스템콜은-어떻게-구현" class="headerlink" title="시스템콜은 어떻게 구현?"></a>시스템콜은 어떻게 구현?</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0x04</span> <span class="comment">// 시스템콜 번호</span></span><br><span class="line">mov ebx, <span class="number">0x03</span> <span class="comment">// 인자값</span></span><br><span class="line">mov ecx, $buf</span><br><span class="line">mov edx, <span class="number">14</span>   <span class="comment">// 문자열 사이즈</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>      <span class="comment">// 소프트웨어 인터럽트 명령</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>레지스터</th><th>의미</th></tr></thead><tbody><tr><td>eax</td><td>산술 및 논리연산을 수행할 때 사용되며 함수의 반환값이 저장된다.</td></tr><tr><td>ebx</td><td>메모리 주소를 저장하기 위한 용도로 사용된다. 인자를 넣어준다.</td></tr><tr><td>ecx</td><td>반복 명령어 사용시 반복 카운터로 사용되는 레지스터이다.</td></tr><tr><td>edx</td><td>eax와 같이 쓰이며 부호 확장 명령등에 쓰이고 큰수의 곱셈, 나눗셈 등의 연산이 이루어질 때 사용된다.</td></tr><tr><td>int 0x80</td><td>소프트웨어 인터럽트 명령이다.</td></tr></tbody></table><hr><h1 id="C-컴파일러"><a href="#C-컴파일러" class="headerlink" title="C 컴파일러"></a>C 컴파일러</h1><ul><li>유닉스 C 컴파일러 <code>c</code></li><li>리눅스 C 컴파일러 -GNU cc- gcc</li><li>우분투 리눅스에 gcc설치</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">gcc --version</span><br><span class="line">gcc -o test.c test</span><br></pre></td></tr></table></figure><h2 id="컴파일-과정-전처리-컴파일-어셈블리-링크"><a href="#컴파일-과정-전처리-컴파일-어셈블리-링크" class="headerlink" title="컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)"></a>컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)</h2><blockquote><p>위 코드에서 <code>gcc -o test.c test</code> 를 수행할 때 발생하는 컴파일 과정이다.</p></blockquote><table><thead><tr><th>컴파일 과정</th><th>서술</th></tr></thead><tbody><tr><td>(1) 전처리기</td><td><code>cpp</code> 라는 전처리기를 사용한다.</td></tr><tr><td></td><td>전처리기가 #include 구문을 만나면 해당 <code>헤더 파일</code>을 찾아 그 내용을 순차적으로 삽입한다.</td></tr><tr><td></td><td>#define, #ifdef 같은 <code>매크로</code> 구문을 치환하고 처리한다.</td></tr><tr><td>(2) C컴파일러</td><td><code>ccl</code> 에 의해 <code>전단부</code>에서 소스코드를 어휘, 구문, 의미를 분석하고 중간코드를 생성한다.</td></tr><tr><td></td><td><code>중단부</code>에서 최적화를 거치고 <code>후단부</code>에서 <code>어셈블리 코드</code>를 생성한다.</td></tr><tr><td>(3) 어셈블러</td><td><code>as</code> 라는 어셈블러를 사용해 어셈블리 코드를 0과1의 기계어로 변환한다.</td></tr><tr><td></td><td>최종적으로 ELF 바이너리 포맷 구조를 갖는 <code>목적코드를 생성</code>한다.</td></tr><tr><td>(4) 링커</td><td><code>ld</code>라는 링커를 사용한다.</td></tr><tr><td></td><td>오브젝트 파일들과 프로그램에서 사용된 표준 C 라이브러리와 사용자 라이브러리를 링크한다.</td></tr><tr><td></td><td>이 과정을 통해 <code>실행파일</code>이 만들어진다.</td></tr></tbody></table><hr><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul><li>응용 프로그램과 분리된 <code>하위 호환 인터페이스</code></li><li>eg. 시스템콜 래퍼, 입출력 라이브러리 등</li><li>fork() 와 같은 시스템콜 함수 사용을 위해 사용자가 사용할 수 있는 함수들의 모음을 말한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process_fork()&#123;</span><br><span class="line">    fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="ABI-Application-Binary-Interface"><a href="#ABI-Application-Binary-Interface" class="headerlink" title="ABI (Application Binary Interface)"></a>ABI (Application Binary Interface)</h1><ul><li>응용 프로그램 바이너리 인터페이스</li><li>함수 실행방식, 레지스터 활용, 시스템콜 실행, 라이브러리 링크 방식 등</li><li>ABI가 호환되면 재컴파일 없이 동작한다. (ABI 표준)</li><li>리눅스에서 만든 프로그램을 리눅스에서 실행하지 못하는이유? ABI가 완벽하게 달라서이다.</li><li>컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공</li></ul><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><ul><li>유닉스 시스템 프로그래밍 인터페이스 표준</li><li>리차드 스톨만이 POSIX를 표준안 이름으로 제안</li><li>IEEE 에서 표준화 시도</li></ul><h2 id="C-언어-표준"><a href="#C-언어-표준" class="headerlink" title="C 언어 표준"></a>C 언어 표준</h2><ul><li>다양한 C 언어 변종이 존재한다.</li><li>ANSI 에서 <code>ANSI C</code> 표준을 정립했다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜의 수행과정, 컴파일 과정에 대해서도 알아본다.&lt;br&gt;API ? ABI ?&lt;br&gt;&lt;code&gt;#API&lt;/code&gt; &lt;code&gt;#ABI&lt;/code&gt; &lt;code&gt;#IDT&lt;/code&gt; &lt;code&gt;#system_call&lt;/code&gt; &lt;code&gt;#gcc&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="abi" scheme="http://yoursite.com/tags/abi/"/>
    
    <category term="system_call" scheme="http://yoursite.com/tags/system-call/"/>
    
    <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>🗯 리눅스 리다이렉션/파이프, 프로세스 관련 명령어</title>
    <link href="http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/"/>
    <id>http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/</id>
    <published>2021-05-19T12:34:46.000Z</published>
    <updated>2021-05-25T00:54:42.542Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="표준-입출력-Standard-Stream"><a href="#표준-입출력-Standard-Stream" class="headerlink" title="표준 입출력 (Standard Stream )"></a>표준 입출력 (Standard Stream )</h1><ul><li>command로 실행되는 프로세스는 세가지 스트림을 가지고 있다.</li><li>표준 입력 스트림 : stdin</li><li>표준 출력 스트림 : stdout</li><li>오류 출력 스트림 : stderr</li></ul><h1 id="리다이렉션-redirection"><a href="#리다이렉션-redirection" class="headerlink" title="리다이렉션 (redirection)"></a>리다이렉션 (redirection)</h1><ul><li>표준 스트림 흐름을 바꿔줄 수 있다.</li><li>‘&gt;’ , ‘&lt;’ 를 사용한다.</li><li>주로 명령어 표준 출력을 화면이 아닌 <code>파일</code>에 쓸때</li></ul><ul><li><p>아래와 같이 <code>ll</code>로 출력되는 메시지들이 file.txt 로 만들어진다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ll &gt; file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ vi file.txt</span><br></pre></td></tr></table></figure></li><li><p>혹은  <code>head</code> 명령어를 사용해, 방금 생성된 file.txt 의 앞에서부터 10줄만 file2.txt 로 새로 만들수 있다.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ head &lt; file.txt &gt; file2.txt</span><br></pre></td></tr></table></figure><h1 id="파이프-pipe"><a href="#파이프-pipe" class="headerlink" title="파이프 (pipe)"></a>파이프 (pipe)</h1><ul><li>두 프로세스 사이에서 한 프로세스의 출력 스트림을 또 다른 프로세스의 입력 스트림으로 사용할 때 사용함.</li></ul><ul><li><code>grep</code> 명령어로 가장 많이 사용된다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ls | grep file</span><br><span class="line">file.txt</span><br><span class="line">file2.txt</span><br></pre></td></tr></table></figure><h2 id="grep-명령어-옵션"><a href="#grep-명령어-옵션" class="headerlink" title="grep 명령어 옵션"></a>grep 명령어 옵션</h2></li></ul><ul><li><code>grep java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 모두 출력</li><li><code>grep -n java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>라인까지</code> 출력</li><li><code>grep -r java directory</code> : directory 내의 모든 파일 중 <code>java</code> 라는 문구가 포함된 행 출력</li><li><code>grep -i java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>대소문자 구분없이</code> 출력</li><li><code>grep -E python|java|ruby file.txt</code> : file.txt 내에서 <code>java</code>,<code>python</code>,<code>ruby</code> 라는 문구가 포함된 행을 출력</li></ul><h1 id="프로세스-vs-바이너리"><a href="#프로세스-vs-바이너리" class="headerlink" title="프로세스 vs 바이너리"></a>프로세스 vs 바이너리</h1><ul><li>코드 이미지 또는 바이너리: 실행파일</li><li>싫행중인 프로그램: 프로세스</li><li>가상 메모리 및 물리 메모리 정보</li><li>시스템 리소스 관련 정보</li><li>스케줄링 단위</li></ul><h1 id="다양한-프로세스-실행환경"><a href="#다양한-프로세스-실행환경" class="headerlink" title="다양한 프로세스 실행환경"></a>다양한 프로세스 실행환경</h1><ul><li>리눅스는 다양한 프로세스가 실행된다.<blockquote><p>유닉스 철학 : 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체 시스템이 동작하도록 하는 모델</p></blockquote></li></ul><h2 id="Foreground-Background-process"><a href="#Foreground-Background-process" class="headerlink" title="Foreground/Background process"></a>Foreground/Background process</h2><ul><li>foreground process: 쉘에서 해당 프로세스를 실행한 후, 해당 프로세스 수행 종료까지 다른 입력을 하지 못하는 프로세스</li><li>background process: 사용자 입력과 상관없이 실행되는 프로세스.</li><li>해당 프로세스 실행시, 맨 뒤에 <code>&amp;</code> 를 붙여주면 된다.</li></ul><ul><li>loop.c 라는 무한루프를 도는 프로그램을 간단히 만들어 테스트 해본다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="forground-process"><a href="#forground-process" class="headerlink" title="forground process"></a>forground process</h3><ul><li>sudo apt-get gcc: <code>gcc</code>는 C 프로그램을 컴파일해준다.</li><li><code>ctrl+C</code> 로 수행을 강제종료 할 때까지 명령어를 사용할 수 없다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ sudo apt-get gcc</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ gcc loop.c -o loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">`loop`  loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">dkfkslfjdldienfkajsdlkfjksjdlkfjaksldfjklsjgheihfodkjfklak</span><br><span class="line">dfasdfasd</span><br><span class="line">dsaf</span><br></pre></td></tr></table></figure></li></ul><h3 id="background-process"><a href="#background-process" class="headerlink" title="background process"></a>background process</h3><ul><li><code>&amp;</code> 를 붙여주면 된다.</li><li><code>[1] 32748</code> : <code>[1]</code>은 작업번호, <code>32748</code> 은 프로세스ID 를 나타낸다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop &amp;</span><br><span class="line">[1] 32748</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop</span><br><span class="line">loop    loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">        int i=1;</span><br><span class="line">        while(i==1)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$</span><br></pre></td></tr></table></figure><h3 id="jobs-명령어"><a href="#jobs-명령어" class="headerlink" title="jobs 명령어"></a>jobs 명령어</h3></li><li>백그라운드로 <code>진행</code> 또는 <code>중지</code>된 프로세스를 보여준다.</li><li>[CTRL]+Z : 프로세스를 중지상태로 변경</li><li><code>bg</code> : 맨 마지막 [CTRL]+Z 로 중지된 프로세스는 <code>bg</code> 명령으로 <code>background</code> 프로세스로 실행될 수 있다.</li><li>[CTRL]+C : 프로세스 작업취소(완전히 종료)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]+  Running                 ./loop &amp;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">^Z</span><br><span class="line">[2]+  Stopped                 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]-  Running                 ./loop &amp;</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure><h3 id="프로세스-상태-확인-ps-명령어"><a href="#프로세스-상태-확인-ps-명령어" class="headerlink" title="프로세스 상태 확인 ps 명령어"></a>프로세스 상태 확인 ps 명령어</h3><ul><li><p><code>ps [option]</code></p></li><li><p><code>-a</code>: 모든 사용자의 프로세스 출력.</p></li><li><p><code>-u</code>: 프로세스 소유자에대한 정보.</p></li><li><p><code>-l</code>: 프로세스 관련 상세정보.</p></li><li><p><code>-x</code>: 프로세스가 아닌 프로세스들도 출력한다. 주로 데몬 프로세스(사용자 모르게 시스템 관리를 위해 실행되는 프로세스)까지 확인하기 위해 사용한다.</p></li><li><p><code>-e</code>: 해당 프로세스와 관련된 환경변수 정보도 함께 출력.</p></li><li><p><code>-f</code>:</p></li><li><p><code>ps -aux</code> 명령 일부</p></li><li><p>USER: 프로세스를 실행시킨 사용자ID</p></li><li><p>%CPU: 마지막 1분동안 프로세스가 사용한 CPU시간의 백분율</p></li><li><p>%MEM: 마지막 1분동안 프로세스가 사용한 메모리 백분율</p></li><li><p>VSZ: 프로세스가 사용하는 가상 메모리크기</p></li><li><p>RSS: 프로세스에서 사용하는 실제 물리메모리</p></li><li><p>TTY : 하드웨어 리소스</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.8 159744  8672 ?        Ss   May17   0:04 /sbin/init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    May17   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_gp]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_par_gp]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [kworker/0:0H-kb]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [mm_percpu_wq]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S    May17   0:00 [ksoftirqd/0]</span><br><span class="line">root        11  0.0  0.0      0     0 ?        I    May17   0:00 [rcu_sched]</span><br><span class="line">root        12  0.0  0.0      0     0 ?        S    May17   0:01 [migration/0]</span><br><span class="line">root        13  0.0  0.0      0     0 ?        S    May17   0:00 [cpuhp/0]</span><br><span class="line">root        14  0.0  0.0      0     0 ?        S    May17   0:00 [kdevtmpfs]</span><br><span class="line">root        15  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [netns]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    May17   0:00 [rcu_tasks_kthre]</span><br><span class="line">root        17  0.0  0.0      0     0 ?        S    May17   0:00 [kauditd]</span><br><span class="line">root        18  0.0  0.0      0     0 ?        S    May17   0:00 [khungtaskd]</span><br></pre></td></tr></table></figure><h3 id="kill-명령"><a href="#kill-명령" class="headerlink" title="kill 명령"></a>kill 명령</h3><ul><li>아까 백그라운드에서 무한 루프를 돌리던 프로세스를 죽이기 위해서 사용한다.</li><li>kill 프로세스 ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu   32748 28829 99 14:11 pts/0    00:18:16 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ kill -9 32748</span><br><span class="line">[1]-  Killed                  ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;리눅스에서 리다이렉션과 파이프를 명령어와 함께 사용해본다.&lt;br&gt;background 와 foreground 프로세스에 대한 이해.&lt;br&gt;&lt;code&gt;#redirection&lt;/code&gt; &lt;code&gt;#pipe&lt;/code&gt; &lt;code&gt;#grep&lt;/code&gt; &lt;code&gt;#linux_process&lt;/code&gt; &lt;code&gt;#ps&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="pipe" scheme="http://yoursite.com/tags/pipe/"/>
    
    <category term="redirection" scheme="http://yoursite.com/tags/redirection/"/>
    
  </entry>
  
  <entry>
    <title>🗯 리눅스서버EC2, 리눅스 기본</title>
    <link href="http://yoursite.com/2021/05/18/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%84%9C%EB%B2%84EC2/"/>
    <id>http://yoursite.com/2021/05/18/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%84%9C%EB%B2%84EC2/</id>
    <published>2021-05-17T15:01:58.000Z</published>
    <updated>2021-05-25T00:54:42.544Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="리눅스-배포판-패키지"><a href="#리눅스-배포판-패키지" class="headerlink" title="리눅스 배포판(패키지)"></a>리눅스 배포판(패키지)</h1><ul><li>리눅스 커널 및 다양한 소프트웨어 패키지를 묶어서 배포하는것</li><li>리눅스 배포판(패키지)</li></ul><h2 id="리눅스-배포판-비교-GNU-Ubuntuk-CentOS-RedHat"><a href="#리눅스-배포판-비교-GNU-Ubuntuk-CentOS-RedHat" class="headerlink" title="리눅스 배포판 비교 (GNU, Ubuntuk, CentOS, RedHat)"></a>리눅스 배포판 비교 (GNU, Ubuntuk, CentOS, RedHat)</h2><table><thead><tr><th>종류</th><th>설명</th></tr></thead><tbody><tr><td>Debian GNU</td><td>데비안은 <code>무료 오픈소스 소프트웨어</code>로만 구성된 운영체제이다. 패키지 업데이트나 의존성 및 보안관련 업데이트를 자동으로 수행하여 <code>관리가 편리</code>하다. 안정성과 보안에 중점을 두어 다른 리눅스 배포판들의 기반으로 사용되고 있다. 다만 <code>설정이 어려워</code> 초보자에게는 권장되지 않는다.</td></tr><tr><td>Ubuntu</td><td>데비안에 기초한 운영체제로서 <code>유니티라는 독자적인 데스크톱 환경</code>을 제공한다. 업데이트 주기는 일년에 총 두번으로 짧다. 처음 접하는 사람들도 <code>쉽게 설치</code>가 가능하다. 개인용 데스크톱에서 많이 사용하지만, 현재는 모바일, 웹서버, 클라우드, 가상서버 등 다양한 형태로 지원하고 있다.</td></tr><tr><td>CentOS</td><td>유료버전인 <code>RHEL의 복제판</code>으로 레드햇에서 상표권을 배제하고 배포된 리눅스이다. 모든 패키지나 기능이 RHEL과 같고 <code>무료</code>로 사용할 수 있다.  하지만 RHEL처럼 사후 기술지원이나 서비스를 받을 수는 없다.</td></tr><tr><td>RedHat</td><td><code>쉬운 설치</code>와 <code>독자적인 패키지 관리</code>가 가능하기 때문에 현업에서 가장 널리 사용되는 운영체제이다.  GUI와 RPM,YUM 같은 패키지 관리 도구를  제공하여 <code>초보자들도 쉽게 설치</code>할 수 있다. 현재는 레드햇 엔터프라이즈 리눅스(RHEL) 만 의미하며, 유료 배포판으로 업데이트를 지원하고 있다.</td></tr></tbody></table><h1 id="클라우드-컴퓨팅-설정-방법-with-AWS"><a href="#클라우드-컴퓨팅-설정-방법-with-AWS" class="headerlink" title="클라우드 컴퓨팅 설정 방법 with AWS"></a>클라우드 컴퓨팅 설정 방법 with AWS</h1><ul><li>AWS 계정이 없다면, 만들어야 한다.</li></ul><h2 id="EC2-또는-인스턴스-서버-생성"><a href="#EC2-또는-인스턴스-서버-생성" class="headerlink" title="EC2 또는 인스턴스(서버) 생성"></a>EC2 또는 인스턴스(서버) 생성</h2><ul><li>인스턴스 서버를 생성하면 마지막에 <code>키페어</code> (.pem) 를 생성할 수 있다. 잘 저장해둔다.</li></ul><img width="1242" alt="aws_01" src="https://user-images.githubusercontent.com/28856435/118682817-bdb0e480-b83b-11eb-9915-0dc33531741b.PNG"><br><h2 id="Elastic-IP-탄력적-IP-생성"><a href="#Elastic-IP-탄력적-IP-생성" class="headerlink" title="Elastic IP(탄력적 IP)생성"></a>Elastic IP(탄력적 IP)생성</h2><ul><li>고정IP/동적IP</li><li>탄력적 IP 를 생성하고, 인스턴스와 연결까지 해주어야 성공.</li></ul> <img width="836" alt="aws_02" src="https://user-images.githubusercontent.com/28856435/118682878-cdc8c400-b83b-11eb-8339-8d4e4d683dba.PNG"><br><h2 id="자기-PC-클라이언트-에서-EC2-서버-접속"><a href="#자기-PC-클라이언트-에서-EC2-서버-접속" class="headerlink" title="자기 PC(클라이언트) 에서 EC2(서버) 접속"></a>자기 PC(클라이언트) 에서 EC2(서버) 접속</h2><ul><li>인스턴스를 생성할 때 다운 받은 <code>.pem</code> 파일을 시작하기 원하는 위치에 둔다.</li><li><code>.pem</code> 이 있는 위치에서 <code>ssh -i &#123;.pem 파일&#125; &#123;ubuntu@고정IP&#125;</code> 수행.</li><li>eg. <code>ssh -i suyeon.pem  ubuntu@3.34.112.149</code></li><li>권한문제는 <code>chmod 400 suyeon.pem</code></li></ul><ul><li>아래와 같이 <code>ubuntu@ip-172-31-42-223:~$</code> 서버 AWS 서버접속이 되는것을 볼 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 400 suyeon.pem</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">total 4</span><br><span class="line">-r--r--r-- 1 SUYEON 197609 1700  5월 18 00:23 suyeon.pem</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="bash">$ ssh -i suyeon.pem  ubuntu@3.34.112.149</span></span><br><span class="line">The authenticity of host &#x27;3.34.112.149 (3.34.112.149)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:u5P/Pib6W0sp1nNLTvMtbweg4qAibDzeqtC6T5EVWWg.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;3.34.112.149&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1045-aws x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Mon May 17 15:29:10 UTC 2021</span><br><span class="line"></span><br><span class="line">  System load:  0.0               Processes:           94</span><br><span class="line">  Usage of /:   3.9% of 29.02GB   Users logged in:     0</span><br><span class="line">  Memory usage: 19%               IP address for eth0: 172.31.42.223</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line">0 packages can be updated.</span><br><span class="line">0 of these updates are security updates.</span><br><span class="line"></span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br><span class="line"></span><br><span class="line">ubuntu@ip-172-31-42-223:~$</span><br></pre></td></tr></table></figure><hr><h1 id="리눅스-기본-구성"><a href="#리눅스-기본-구성" class="headerlink" title="리눅스 기본 구성"></a>리눅스 기본 구성</h1><h2 id="리눅스-파일"><a href="#리눅스-파일" class="headerlink" title="리눅스 파일"></a>리눅스 파일</h2><ul><li>모든것은 파일이라는 철학을 따른다.</li><li>모든 인터렉션은 read / write</li><li>마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다.</li><li>파일 네임스페이스</li><li>전역 네임스페이스를 사용한다.<ul><li>eg. /tomcat/ows/driver.txt</li></ul></li></ul><h2 id="리눅스-프로세스"><a href="#리눅스-프로세스" class="headerlink" title="리눅스 프로세스"></a>리눅스 프로세스</h2><ul><li>리눅스 실행 파일 포멧 - <code>ELF</code> (Executable and Linkable Format)<ul><li>콜스택, 코드 (텍스트), 데이터 및 BSS 섹션 등</li></ul></li><li>다양한 시스템 리소스와 관련되어 있다. (시스템콜 기반.)<ul><li>타이머, 시그널, 파일, 네트워크, 디바이스, IPC 기법</li></ul></li><li><code>가상 메모리</code>를 지원한다.</li><li>각 프로세스는 <code>pid</code>(프로세스 ID) 고유값으로 구분되어 있다.</li><li><code>init 프로세스</code>(첫번째 프로세스) 를 기반으로 <code>fork()</code> 시스템콜을 사용해서 신규 프로세스가 생성되는 방식이다.</li></ul><h2 id="리눅스-권한"><a href="#리눅스-권한" class="headerlink" title="리눅스 권한"></a>리눅스 권한</h2><ul><li>운영체제는 사용자/리소스 권한을 관리한다.</li><li>리눅스는 사용자/그룹으로 권한을 관리한다.</li><li>root 는 슈퍼관리자이다.</li><li>파일마다 소유자, 소유자  그룹, 모든 사용자에 대해 읽기/쓰기/실행 권한을 관리한다. (rwx)</li><li>접근 권한 정보는 inode 의 자료구조에 저장된다.<br><a href="#ls-%EB%AA%85%EB%A0%B9%EC%96%B4">리눅스 권한 예시👆</a></li></ul><h2 id="리눅스-파일-종류"><a href="#리눅스-파일-종류" class="headerlink" title="리눅스 파일 종류"></a>리눅스 파일 종류</h2><ol><li>디렉토리<ul><li>하나의 파일로, 상위 디렉토리 파일에 등록되어 있다.</li></ul></li><li>일반파일<ul><li>스트림 파일</li></ul></li><li>특수 파일<ul><li>장치파일 (Device file)</li><li>블록 장치(특수)파일, 캐릭터 장치(특수)파일</li><li>파이프</li><li>소켓</li></ul></li></ol><blockquote><p><strong>블록 장치 파일</strong><br>보통 파일 read/write 요청이 있으면 커널에 전달되어 파일스트림 드라이버에 의해 처리된다. 반면에 장치파일은 요청이 그 장치의 드라이버에 의해서 처리되며, 하드디스크, CD/DVD 등의 저장 장치 파일들이다. <code>블록단위</code>로 입출력을 수행한다.<br><strong>캐릭터 장치 파일</strong><br>터미널, 프린터, 키보드 등의 문자 기반 장치 파일을 의미한다. I/O 버퍼를 사용하지 않으며 <code>바이트 단위</code>의 입출력만 수행한다.<br><strong>파이프 파일</strong><br>특정 프로그램의 출력을 중간 파일을 거치지 않고 다른 파일의 입력으로 보내는 파일을 의미한다. <code>FIFO</code> 방식으로 처리된다.<br><strong>소켓 파일</strong><br>네트워크의 입출력을 담당하는 API(Application Program Interface) 로, 물리적인 두 호스트 컴퓨터 간의 데이터를 송수신 할 때 사용하는 논리적인 소프트웨어 장치파일이다.</p></blockquote><hr><h1 id="쉘-shell-이란"><a href="#쉘-shell-이란" class="headerlink" title="쉘(shell) 이란?"></a>쉘(shell) 이란?</h1><ul><li>사용자와 운영체제간 인터페이스이다.</li><li>사용자의 명령을 해석해서 커널에 명령을 요청한다.</li><li>관련된 시스템콜을 사용해서 프로그램이 작성되어 있다.</li></ul><h2 id="쉘의-종류"><a href="#쉘의-종류" class="headerlink" title="쉘의 종류"></a>쉘의 종류</h2><ul><li>Bourne-Again Shell (bash): GNU 프로젝트의 일환으로 개발되었다.</li></ul><h2 id="다중-사용자를-지원하는-시스템"><a href="#다중-사용자를-지원하는-시스템" class="headerlink" title="다중 사용자를 지원하는 시스템"></a>다중 사용자를 지원하는 시스템</h2><ul><li>다중 사용자 관련 명령어는 어떤것이 있을까?</li></ul><h3 id="sudo-명령어"><a href="#sudo-명령어" class="headerlink" title="sudo 명령어"></a>sudo 명령어</h3><ul><li>/etc/sudors 설정 파일에서 설정을 변경할 수 있다.</li></ul><ul><li>아래와 같이 내가 만드려는 사용자를 <code>root</code> 아래에 추가해준다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">suyn    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><ul><li><p><code>root</code> 권한으로 <code>adduser</code> 명령어를 사용해 새로운 사용자를 생성한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ adduser suyn</span><br><span class="line">adduser: Only root may add a user or group to the system.</span><br><span class="line"></span><br><span class="line">ubuntu@ip-172-31-42-223:~$ sudo adduser suyn</span><br><span class="line">Adding user `suyn&#x27; ...</span><br><span class="line">Adding new group `suyn&#x27; (1001) ...</span><br><span class="line">Adding new user `suyn&#x27; (1001) with group `suyn&#x27; ...</span><br><span class="line">Creating home directory `/home/suyn&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for suyn</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ sudo passwd suyn</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>생성한 <code>suyn</code> 유저로 전환</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ su - suyn</span><br><span class="line">Password:</span><br><span class="line">suyn@ip-172-31-42-223:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="ls-명령어"><a href="#ls-명령어" class="headerlink" title="ls 명령어"></a>ls 명령어</h3><ul><li><code>al</code> 옵션을 주면 숨김파일 까지 조회할 수 있다.</li><li>파일 권한</li><li>파일마다 소유자, 소유자그룹, 모든 사용자에대해 권한을 설정할 수 있다.</li><li><code>drwxr-xr-x</code><ul><li>d : directory 를 나타냄. <a href="#%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%A2%85%EB%A5%98">리눅스 파일종류👆</a></li><li>rwx 소유자는 rwx 가능</li><li>r-x 그룹은 rx 가능</li><li>r-x 모든 사용자는 rx 가능</li></ul></li><li>소유자 접근 권한 정보는 <code>inode</code> 에 저장되어 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ls -al</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 5 ubuntu ubuntu 4096 May 18 15:40 .</span><br><span class="line">drwxr-xr-x 4 root   root   4096 May 18 15:20 ..</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu  220 Apr  4  2018 .bash_logout</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 3771 Apr  4  2018 .bashrc</span><br><span class="line">drwx------ 2 ubuntu ubuntu 4096 May 17 15:29 .cache</span><br><span class="line">drwx------ 3 ubuntu ubuntu 4096 May 17 15:29 .gnupg</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu  807 Apr  4  2018 .profile</span><br><span class="line">drwx------ 2 ubuntu ubuntu 4096 May 17 15:24 .ssh</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu    0 May 18 15:19 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 ubuntu ubuntu 2106 May 18 15:40 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>[다시한번 짚고가기] <strong>슈퍼블록 &amp; inode</strong></p><ul><li><code>슈퍼블록</code>은 파일 시스템의 정보를 담고있다.<ul><li>SUPER_BLOCK [ [fileA] [fileB] ] 이런식이다.</li></ul></li><li>inode 는 파일이름마다 <code>inode 고유값</code>이 매칭되며 <code>자료구조</code> 형식으로 관리된다. 또한, inode를 기반의 메타정보(파일권한, 소유자정보, 파일사이즈, 생성시간 등)를 담고있다. 파일 시스템에서는 inode 기반으로 파일에 엑세스한다.<ul><li>SUPER_BLOCK [ [fileA:inode] [fileB:inode] ] 이런식이다.</li></ul></li></ul></blockquote><h3 id="ln-명령어"><a href="#ln-명령어" class="headerlink" title="ln 명령어"></a>ln 명령어</h3><ul><li>하드링크 : 기존파일의 inode 는 동일하다.</li><li><code>cp</code> 명령어는 물리적인 공간이 늘어나는 반면에, 하드링크는 동일한 inode 를 사용하되 포인터만 늘어난다고 생각하면 된다. (전체 파일 용량은 달라지지 않는다.)</li><li>심볼릭 링크 (소프트링크)</li><li>inode 가 바뀐다. 기존 파일의 위치가 바뀌거나 파일이 삭제되면 소프트링크에 접근할 수 없게된다.</li></ul><ul><li><p>하드링크 예시</p><ul><li>아래 코드에서 inode 값을 확인! a.txt 와 a_link 의 inode 값은 동일하다.<br><code>256239</code> -rw-rw-r– 2 ubuntu ubuntu 6 May 20 08:39 a.txt<br><code>256239</code> -rw-rw-r– 2 ubuntu ubuntu 6 May 20 08:39 a_link.txt<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ cat a.txt</span><br><span class="line">asdfg</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ln a.txt a_link.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ls -ali *.txt</span><br><span class="line">256239 -rw-rw-r-- 2 ubuntu ubuntu 6 May 20 08:39 a.txt</span><br><span class="line">256239 -rw-rw-r-- 2 ubuntu ubuntu 6 May 20 08:39 a_link.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>소프트링크 예시</p><ul><li>아래 코드에서 inode 값을 확인! a.txt 와 a_link.txt 의 inode 값은 다르다.<br><code>256241</code> -rw-rw-r– 1 ubuntu ubuntu 9 May 20 08:54 b.txt<br><code>256238</code> lrwxrwxrwx 1 ubuntu ubuntu 5 May 20 08:55 b_link.txt -&gt; b.txt<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ cat b.txt</span><br><span class="line">softlink</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ln -s b.txt b_link.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ls -ali b*</span><br><span class="line">256241 -rw-rw-r-- 1 ubuntu ubuntu 9 May 20 08:54 b.txt</span><br><span class="line">256238 lrwxrwxrwx 1 ubuntu ubuntu 5 May 20 08:55 b_link.txt -&gt; b.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ cat b_link.txt</span><br><span class="line">softlink</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;클라우드 컴퓨팅 환경에서 서버를 실행해보자. with AWS&lt;br&gt;리눅스 파일종류와 쉘(shell), 소프트링크/하드링크&lt;br&gt;&lt;code&gt;#EC2&lt;/code&gt; &lt;code&gt;#shell&lt;/code&gt; &lt;code&gt;#Linux&lt;/code&gt; &lt;code&gt;#hardlink&lt;/code&gt; &lt;code&gt;#softlink&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>💻 부팅의 이해</title>
    <link href="http://yoursite.com/2021/05/15/%EB%B6%80%ED%8C%85%EC%9D%98-%EC%9D%B4%ED%95%B4/"/>
    <id>http://yoursite.com/2021/05/15/%EB%B6%80%ED%8C%85%EC%9D%98-%EC%9D%B4%ED%95%B4/</id>
    <published>2021-05-15T12:59:56.000Z</published>
    <updated>2021-05-20T01:06:40.835Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><ul><li>컴퓨터를 켜서 동작시키는 절차를 말한다.</li><li>BIOS 가 특정 Storage 를 Memory 에 읽어와 bootstrap loader 를 메모리에 올리고 실행한다.</li><li>bootstrap loader 프로그램이 있는곳을 찾아서 실행시킨다.</li></ul><ol><li><code>CPU &gt; ROM-BIOS(특별한RAM: 컴퓨터가 종료되어도 메모리 기억)</code></li></ol><ul><li>CPU 가 BIOS 에서 매핑된 Memory 주소를 찾는다.</li></ul><ol start="2"><li><code>BIOS -&gt; Memory (RAM)</code></li></ol><ul><li>BIOS 프로그램을 Memory 에 올린다.</li><li>BIOS 는 컴퓨터를 초기화한다.</li></ul><ol start="3"><li><code>Memory &lt;-&gt; MBR(Master Boot Record ;저장매체)</code></li></ol><ul><li>부트로더 라는 프로그램을 로드한다.</li><li>부트로더에는 파티션 table 정보가 있다. (C:/, D:/)</li><li>어떤 파티션이 메인 파티션인지 확인.</li></ul><ol start="4"><li><code>Memory &lt;-&gt; 부트섹터(저장매체)</code></li></ol><ul><li>해당 메인 파티션에 들어가있는 특정 부트섹터 영역의 부트 코드를 로드한다.</li></ul><ol start="5"><li><code>Memory &lt;-&gt; 커널 이미지(저장매체)</code></li></ol><ul><li>부트 코드까지 Memory 에 올라가면 커널로부터 운영체제 이미지를 가져온다.</li></ul><ol start="6"><li>컴퓨터가 실행된다. </li></ol><br><img width="972" alt="부팅과정" src="https://user-images.githubusercontent.com/28856435/118362451-85ef3600-b5ca-11eb-9f56-c2f281b47f1e.PNG"><h1 id="실제-운영체제"><a href="#실제-운영체제" class="headerlink" title="실제 운영체제"></a>실제 운영체제</h1><ul><li>리눅스 운영체제</li></ul><ol><li>process management</li></ol><ul><li>응용프로그램은 여러개의 process로 관리.</li><li>프로세스 스케줄러: 프로세스 실행/종료 및 인터럽트 처리 관리.</li></ul><ol start="2"><li>memory management</li></ol><ul><li>가상메모리. page 기반 메모리 관리.</li></ul><ol start="3"><li>IO device management</li></ol><ul><li>VFS (Virsual File System)    - 가상 파일 시스템 인터페이스 사용</li><li>fild, Device drivers, Network 관리</li></ul><h2 id="시스템-프로그램"><a href="#시스템-프로그램" class="headerlink" title="시스템 프로그램"></a>시스템 프로그램</h2><ul><li>bash(bourne-again shell)</li><li>내부는 시스템콜을 호출하도록 구현</li><li>필요시 해당 운영체제의 시스템콜을 호출. (라이브러리-시스템콜)</li></ul><blockquote><ul><li><strong>안드로이드 스마트폰</strong><ul><li>Linux Kernel + Android Framework</li><li>리눅스OS 기반으로 안드로이드 플랫폼이 존재한다. </li></ul></li><li><strong>IoT</strong></li></ul><ul><li>IoT 관련 OS 의 경우 기능을 최소화 한다. (Tiny OS : 멀티태스킹, 보호모드, 가상메모리, 파일시스템 사용하지 않는다.)</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;부팅은 무엇이고, 실제로 어떻게 일어날까?&lt;br&gt;&lt;code&gt;#BIOS&lt;/code&gt; &lt;code&gt;#booting&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="booting" scheme="http://yoursite.com/tags/booting/"/>
    
    <category term="BIOS" scheme="http://yoursite.com/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>🗄 파일 시스템</title>
    <link href="http://yoursite.com/2021/05/15/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"/>
    <id>http://yoursite.com/2021/05/15/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/</id>
    <published>2021-05-15T11:44:27.000Z</published>
    <updated>2021-05-25T00:54:42.549Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="파일-시스템이란"><a href="#파일-시스템이란" class="headerlink" title="파일 시스템이란 ?"></a>파일 시스템이란 ?</h1><blockquote><p>운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘을 의미한다.</p></blockquote><h2 id="파일-시스템이-만들어진-이유"><a href="#파일-시스템이-만들어진-이유" class="headerlink" title="파일 시스템이 만들어진 이유?"></a>파일 시스템이 만들어진 이유?</h2><ul><li>블록: <code>블록</code> 단위로(보통 4KB), 블록마다 고유 번호를 부여해서 관리한다.</li><li>0과 1의 데이터를 비트로 저장하기에는 오버헤드 발생하기 때문.</li><li>파일: 사용자는 <code>파일</code> 단위로 관리하며, 각 파일에는 블록 단위로 관리된다.</li><li>사용자가 블록 단위로 고유번호를 관리하기 어렵기 때문.</li></ul><h2 id="파일-시스템-저장-방법"><a href="#파일-시스템-저장-방법" class="headerlink" title="파일 시스템 저장 방법"></a>파일 시스템 저장 방법</h2><ul><li>가능한 연속적 공간에 파일을 저장하는것이 좋으나, 파일 사이즈가 가변적이라면 외부 단편화가 일어날 수 있다.</li><li>따라서,  불연속 공간에 파일을 저장하는 기능이 필요하다.</li><li><code>블록체인</code>: 각 블록을 링크드 리스트로 연결한다. 어떤 주소를 찾으려면 처음부터 주소를 따라가야 하는 단점이 있다.</li><li><code>인덱스 블록</code>: 각 블록에 대한 위치정보를 기억해서, 한번에 그 블록을 찾을 수 있다.</li></ul><h2 id="파일시스템과-시스템콜"><a href="#파일시스템과-시스템콜" class="headerlink" title="파일시스템과 시스템콜"></a>파일시스템과 시스템콜</h2><ul><li>동일한 시스템콜을 사용해서 다양한 파일 시스템 지원 가능하도록 구현되어 있다.</li><li>파일을 실제로 어떻게 저장하는지는 다를 수 있다.</li><li>리눅스의 경우 ext4, NTFS, FAT32 파일시스템을 지원한다.</li></ul><h1 id="inode-방식-파일-시스템"><a href="#inode-방식-파일-시스템" class="headerlink" title="inode 방식 파일 시스템"></a>inode 방식 파일 시스템</h1><ul><li>파일시스템의 기본 구조</li><li>수퍼블록: 파일시스템 정보</li><li>아이노드 블록: 파일 상세정보 (PCB)</li><li>데이터 블록: 실제 데이터 (1KB~4KB)</li></ul><br><img width="316" alt="파일시스템구조" src="https://user-images.githubusercontent.com/28856435/118361659-6b678d80-b5c7-11eb-87d4-839182efbba0.PNG"><br><h2 id="수퍼블록"><a href="#수퍼블록" class="headerlink" title="수퍼블록"></a>수퍼블록</h2><ul><li>파일시스템 정보 및 파티션 정보를 포함한다.</li><li>리눅스 명령어 <code>df</code> 를 했을 때 출력되는 정보들.</li></ul><h2 id="inode와-파일"><a href="#inode와-파일" class="headerlink" title="inode와 파일"></a>inode와 파일</h2><ul><li><p>파일 <code>inode 고유값</code>과 <code>자료구조</code>에 의해 주요 정보를 관리한다.</p></li><li><p>파이이름 : inode =&gt; 파일이름은 inode 와 매칭된다.</p></li><li><p>파일 시스템에서는 inode 기반으로 파일에 엑세스 한다.</p></li><li><p><code>inode 기반의 메타 데이터</code> : 파일권한, 소유자 정보, 파일 사이즈, 생성시간 등</p></li><li><p>각 <code>디렉토리 엔트리</code>(dentry)를 탐색</p></li><li><p>/home/ubuntu/link.txt : <code>/</code> 마다 <code>dentry</code> 를 가지고 있다.</p></li><li><p>파일생성 &gt; inode 번호 &gt; inode 블록 &lt;- 파일 쿼리</p></li><li><p>아래 명령을 실행할 경우,</p></li><li><p>inode 번호 &gt; inode 블록 접근 &gt; 해당 데이터를 읽어옴.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat data.txt</span></span><br></pre></td></tr></table></figure><br><img width="773" alt="inode구조" src="https://user-images.githubusercontent.com/28856435/118361800-e92b9900-b5c7-11eb-8da3-0791cdf1dfc7.PNG"><br><h1 id="디렉토리-엔트리"><a href="#디렉토리-엔트리" class="headerlink" title="디렉토리 엔트리"></a>디렉토리 엔트리</h1><ul><li>디렉토리를 표현하는 데 쓰이는 자료구조이다.</li><li>일반적으로 파일이름, 파일 속성 등 여러가지 정보가 저장되는데, 유닉스 계열에서는 <code>파일이름</code>과 <code>inode번호</code>만 저장된다.</li><li>리눅스 파일탐색: /home/ubuntu/ink.txt</li><li>각 디렉토리 엔트리를 탐색 : 각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있다.</li><li>즉 <code>/</code> - <code>home</code> - <code>ubuntu</code> - <code>link.txt</code> 순으로 파일을 찾아 해당 <code>inode</code> 를 얻는다. </li></ul><h2 id="가상-파일-시스템"><a href="#가상-파일-시스템" class="headerlink" title="가상 파일 시스템"></a>가상 파일 시스템</h2><ul><li>Network 등 다양한 기기도 동일한 파일시스템 인터페이스를 통해 관리가능</li><li>eg. read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)</li><li>추상화 (abstraction)</li><li>복잡한 기능/자료/데이터의 핵심적 개념과 기능을 간추려 내는것.</li><li>input/output 을 통해 모든 디바이스를 <code>파일 interface</code> 로 다룬다.</li></ul><blockquote><p>모든 것은 파일이라는 철학</p><ul><li>모든 인터렉션 파일을 읽고, 쓰는것처럼 이루어져 있다.</li><li>마우스, 키보드와 같은 모든 디바이스 관련 기술 또한 파일과 같이 다루어짐.<br><strong>즉, 모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용한다.</strong></li></ul></blockquote><h2 id="특수파일-디바이스"><a href="#특수파일-디바이스" class="headerlink" title="특수파일 -디바이스"></a>특수파일 -디바이스</h2><ul><li>블록 디바이스(Block Device): HDD, CD/DVD 같이 블록 또는 섹터 단위 등 정해진 단위로 데이터를 전송한다. I/O 송수신 속도가 높다.</li><li>캐릭터 디바이스 (Character Device): 키보드, 마우스 등 byte 단위 데이터를 전송한다. I/O 송수신 속도가 낮다.</li></ul><h3 id="캐릭터-디바이스-tty"><a href="#캐릭터-디바이스-tty" class="headerlink" title="캐릭터 디바이스-tty"></a>캐릭터 디바이스-tty</h3><ul><li>가상파일 시스템 인터페이스를 통해서, <code>가상 터미널환경(디바이스)</code>에 연결이 되어있다. 이 디바이스에 input 을 주는것은 <code>키보드</code>이다.</li><li>아래 예제를 보면, tty라는 파일을 출력하면, 키보드로 입력하는 것이 두 번 출력된다.</li><li>키보드에 직접 입력하면 첫번째출력. <code>tty</code>-<code>cat</code>명령어를 통해 두번째 출력.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:/dev$ cat tty</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">i&#x27;m</span><br><span class="line">i&#x27;m</span><br><span class="line">suyeon</span><br><span class="line">suyeon</span><br></pre></td></tr></table></figure>즉, 터미널 조차도 가상시스템 인터페이스를 통해서 일종의 파일처럼 다뤄지고 있으며, 그 파일을 읽거나 쓰면 해당 디바이스를 다룰 수 있다.(운영체제와 통신할 수 있다.)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;inode 와 가상 파일 시스템&lt;br&gt;&lt;code&gt;#inode&lt;/code&gt; &lt;code&gt;#file_system&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="file_system" scheme="http://yoursite.com/tags/file-system/"/>
    
    <category term="inode" scheme="http://yoursite.com/tags/inode/"/>
    
  </entry>
  
  <entry>
    <title>☁️ 가상메모리와 페이징 시스템</title>
    <link href="http://yoursite.com/2021/05/13/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"/>
    <id>http://yoursite.com/2021/05/13/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/</id>
    <published>2021-05-13T08:34:43.000Z</published>
    <updated>2021-05-20T01:06:40.833Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="가상-메모리-Virtual-Memory-System"><a href="#가상-메모리-Virtual-Memory-System" class="headerlink" title="가상 메모리 (Virtual Memory System)"></a>가상 메모리 (Virtual Memory System)</h1><ul><li>각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 있다.</li><li>eg. 리눅스는 프로세스 하나당 4GB 이다.</li><li>즉, <code>가상 메모리</code>는 실제 메모리보다 많아보이게 하는 기술이다.</li><li>프로세스간 공간이 분리되어 프로세스 이슈가 전체 시스템에 영향을 주지 않는다.</li></ul><h2 id="가상-메모리의-사용"><a href="#가상-메모리의-사용" class="headerlink" title="가상 메모리의 사용"></a>가상 메모리의 사용</h2><ul><li>프로세스는 가상주소를 사용하고, 그 주소에 매핑되는 실제 주소는 데이터 read/write 시에만 가져온다. </li><li><code>virtual address</code>(가상주소) : 프로세스가 참조하는 주소</li><li><code>physical address</code> (물리주소) : 실제 메모리 주소</li><li><code>MMU</code> (Memory Management Unit)</li><li>가상주소의 메모리 접근이 필요할 때, 그 주소값을 물리주소로 반환해주는 하드웨어 장치이다.</li></ul><h2 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU (Memory Management Unit)"></a>MMU (Memory Management Unit)</h2><ul><li>CPU 는 가상메모리를 다루고, 해당 주소 접근시 <code>MMU 하드웨어 장치를 통해 물리메모리에 접근</code>한다.</li><li>하드웨어 장치를 사용하면 주소 변환이 빠르기 때문에 별도 장치를 둔다.</li></ul><h1 id="페이징-시스템-Paging-System"><a href="#페이징-시스템-Paging-System" class="headerlink" title="페이징 시스템 (Paging System)"></a>페이징 시스템 (Paging System)</h1><ul><li>페이징이란 ?</li><li>크기가 동일한 페이지로 가상주소 공간과 그에 상응하는 물리주소 공간을 관리한다.<ul><li>page(page frame) : 고정된 크기의 block(4KB)</li></ul></li><li>페이징 번호를 기반으로 <code>가상주소-물리주소 매핑 정보를 저장</code>하고 사용한다.</li><li>리눅스에서는 보통 4KB 만큼 페이징.</li><li>프로세스 (4GB) 의 <code>PCB</code>에 <code>Page Table 구조체</code>를 가리키는 주소가 들어있다.</li></ul><h2 id="페이징-시스템-구조"><a href="#페이징-시스템-구조" class="headerlink" title="페이징 시스템 구조"></a>페이징 시스템 구조</h2><ul><li>페이징 시스템</li><li>가상주소 = 가상메모리 페이지 + 변위</li><li>페이지 크기 4KB 라면, 가상주소의 <code>0~11bit</code> 변위를 나타내고, <code>12bit 이상</code>이 페이지 번호가 될 수 있다.</li></ul><h2 id="페이지-테이블-page-table"><a href="#페이지-테이블-page-table" class="headerlink" title="페이지 테이블 (page table)"></a>페이지 테이블 (page table)</h2><ul><li>프로세스 생성시 페이지 테이블 정보가 생성된다.</li><li>관련 페이지 테이블 base address 는 별도 <code>CR3 레지스터</code>에 저장한다.</li><li>물리주소에 있는 페이지 번호와 해당 페이지 번호의 첫 물리주소를 매핑한 표.</li><li>해당 페이지 테이블에서 해당 page 에 매핑된 첫 물리주소를 알아내고 변위를 더한값이 실제 물리주소이다.</li></ul><h2 id="MMU-Memory-Management-Unit-물리주소를-얻는-방법"><a href="#MMU-Memory-Management-Unit-물리주소를-얻는-방법" class="headerlink" title="MMU (Memory Management Unit) : 물리주소를 얻는 방법"></a>MMU (Memory Management Unit) : 물리주소를 얻는 방법</h2><p>  MMU(하드웨어 장치) - 물리메모리를 확인하기 위해 Memory 에 갔다와야 한다.</p><ul><li><code>CPU</code> 는 <code>virtual address</code>를 <code>MMU</code> 에 요청한다.</li><li><code>MMU</code> 는 <code>virtual address</code>로 해당 프로세스의 <code>PCB</code>의 페이지 테이블에 접근하여 <code>CR3 레지스터</code>로부터 <code>base address</code>를 얻는다.</li><li><code>MMU</code> 는 <code>base address</code>로, Memory의 물리주소에 접근한다.</li></ul><h2 id="다중단계-페이징-시스템"><a href="#다중단계-페이징-시스템" class="headerlink" title="다중단계 페이징 시스템"></a>다중단계 페이징 시스템</h2><ul><li>프로세스마다 페이지를 나누어서 메모리에 할당하면 많은 공간이 낭비된다. 필요한 부분만 페이지를 나눠서 할당하여 공간의 활용도를 높이고자 하는것에 착안했다.</li><li>모든 부분을 페이지도 나눌 필요없이 단계적으로 나누어서 필요한 부분만 <code>페이지 테이블</code>에 두고 이것을 <code>페이지 디렉토리</code>에 저장한다.</li><li>32bit 시스템에서 4KB를 위한 페이징 시스템</li><li><code>하위 12bit</code> : 오프셋(변위)</li><li><code>상위 20bit</code> : 페이징 번호 (2<sup>20</sup>=1048576 개의 페이징 번호)</li><li>페이지 번호를 나타내는 bit를 구분하여 단계를 나눈다.</li><li>10bit : Page Directory</li><li>10bit : Page Table</li><li>20bit : OFFSET &gt; Pysical Frame</li><li>CR3 -&gt; Page Directory(시작주소) -&gt; Page Table(시작주소) -&gt; Pysical Frame(물리 메모리에서 프레임주소)</li></ul><h2 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB (Translation Lookaside Buffer)"></a>TLB (Translation Lookaside Buffer)</h2><ul><li>페이지 정보를 캐슁한다. (Pysical Address 전달/캐슁)</li></ul><h2 id="공유-메모리-Shared-Memory"><a href="#공유-메모리-Shared-Memory" class="headerlink" title="공유 메모리 (Shared Memory)"></a>공유 메모리 (Shared Memory)</h2><ul><li>프로세스간 동일한 물리주소를 가리킬 수 있다.</li><li>공간절약, 메모리 할당 절약.</li><li>P1(Parent) - [fork] -&gt; P2(Child)</li></ul><h2 id="요구-페이징-Demand-Paging"><a href="#요구-페이징-Demand-Paging" class="headerlink" title="요구 페이징 (Demand Paging)"></a>요구 페이징 (Demand Paging)</h2><ul><li>프로세스의 모든 데이터를 메모리에 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재한다.</li><li>더 이상 필요치 않은 페이지 프레임은 저장매체에 저장한다.(페이지 교체 알고리즘)</li><li>요구페이징 &lt;-&gt; 선행페이징(anticipatory paging): 미리 프로세스 관련 데이터를 모두 메모리에 올려놓고 실행.</li></ul><h2 id="페이지-폴트-Page-Fault"><a href="#페이지-폴트-Page-Fault" class="headerlink" title="페이지 폴트 (Page Fault)"></a>페이지 폴트 (Page Fault)</h2><ul><li>어떤 페이지 정보가 실제 물리메모리에 없을때 <code>페이지폴트 인터럽트</code>가 발생한다.</li></ul><h1 id="전체-페이징-시스템-프로세스-feat-TLB-Page-fault"><a href="#전체-페이징-시스템-프로세스-feat-TLB-Page-fault" class="headerlink" title="전체 페이징 시스템 프로세스(feat. TLB, Page fault)"></a>전체 페이징 시스템 프로세스(feat. TLB, Page fault)</h1><br><img width="1009" alt="페이징_시스템" src="https://user-images.githubusercontent.com/28856435/118363663-62c78500-b5d0-11eb-902d-6ec65340e35c.PNG"><p>(a) <strong>[CPU -&gt; MMU]</strong> CPU는 <code>MMU</code> 에 가상주소를 요청한다.<br>(b) <strong>[MMU -&gt; TLB]</strong> 먼저 <code>TLB 칩</code>에 변환된 물리주소가 있는지 확인한다. 있다면 바로 그 정보로 (e)단계로, 없다면 (c) 단계로 진행한다.<br>(c) <strong>[MMU -&gt; Memory]</strong> <code>CR3 레지스터</code>로부터 해당 페이지의 테이블에 물리주소가 있는지(valid) 확인한다. -&gt; invalid일 경우(d) 단계를 수행, valid일 경우 (e)단계로 진행한다.</p><ul><li>(d-1) <strong>[MMU -&gt; OS]</strong> <code>Page Fault Interrupt</code> OS(운영체제) 에서 <code>page fault interrupt handling</code>이 수행되고</li><li>(d-2) <strong>[OS -&gt; 저장매체]</strong> <code>저장매체</code>에서 해당 프로세스의 페이지 정보를 찾아온다.</li><li>(d-3) <strong>[저장매체 -&gt; Memory]</strong> 해당 물리주소를 <code>메모리</code>에 올린다.</li><li>(d-4) <strong>[Memory]</strong> 페이징 정보를 업데이트 한다.</li></ul><p>(e) <strong>[Memory -&gt; MMU]</strong> 페이지 테이블에서 해당 물리주소를 가져온다.<br>(f) <strong>[MMU -&gt; Memory]</strong> 실제 물리주소 위치에 접근한다.<br>(g) <strong>[Memory -&gt; CPU]</strong> 해당 데이터를 전달한다.</p><hr><h1 id="페이지-교체-알고리즘"><a href="#페이지-교체-알고리즘" class="headerlink" title="페이지 교체 알고리즘"></a>페이지 교체 알고리즘</h1><h2 id="페이지-교체-정책-Page-replacement-policy"><a href="#페이지-교체-정책-Page-replacement-policy" class="headerlink" title="페이지 교체 정책 (Page replacement policy)"></a>페이지 교체 정책 (Page replacement policy)</h2><ul><li>운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리메모리에 공간이 없다면.</li><li>기존 페이지 중 하나를 저장매체로 내린다.</li><li>새로운 페이지를 해당 물리공간에 올린다.</li></ul><blockquote><p>페이지 교체 알고리즘(Page Replacement Algorithm) : 어떤 페이지를 물리메모리에서 저장매체로 보낼것인가 ?</p></blockquote><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>가장 먼저 들어온 페이지를 내리자.</li></ul><h3 id="OPT-OPTimal-Replacement-Algorithm"><a href="#OPT-OPTimal-Replacement-Algorithm" class="headerlink" title="OPT(OPTimal Replacement Algorithm)"></a>OPT(OPTimal Replacement Algorithm)</h3><ul><li>최적 페이지 교체 알고리즘</li><li>앞으로 오랫동안 사용하지 않을 페이지를 내리자.</li><li>어떤 페이지가 오랫동안 사용하지 않을지 예측이 힘들다. - 일반 OS에서는 구현이 불가.</li></ul><h3 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU (Least Recently Used)"></a>LRU (Least Recently Used)</h3><ul><li>가장 오래전에 사용된 페이지를 교체한다.</li><li>OPT 알고리즘이 현실적으로 불가하므로, 과거 기록을 기반으로 한다.</li><li><code>메모리 지역성</code> 에 따르면 근처의 메모리 영역을 많이 사용한다.</li></ul><h3 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU (Least Frequently Used)"></a>LFU (Least Frequently Used)</h3><ul><li>가장 적게 사용된 페이지를 교체한다.</li></ul><h3 id="NUR-Not-Used-Recently"><a href="#NUR-Not-Used-Recently" class="headerlink" title="NUR (Not Used Recently)"></a>NUR (Not Used Recently)</h3><ul><li>최근에 사용하지 않은 페이지부터 교체한다. (LRU와 비슷)</li><li>참조비트와 수정비르를 사용해 그 순서대로 페이지를 교체한다.</li></ul><h2 id="Threshing-스레싱"><a href="#Threshing-스레싱" class="headerlink" title="Threshing (스레싱)"></a>Threshing (스레싱)</h2><ul><li>반복적으로 페이지 폴트가 발생하면, 과도하게 페이지 교체작업이 일어나 결국엔 아무 일도 수행하지 못하는 상황.</li></ul><hr><h1 id="세그멘테이션-기법"><a href="#세그멘테이션-기법" class="headerlink" title="세그멘테이션 기법"></a>세그멘테이션 기법</h1><ul><li>가상메모리를 서로 <code>크기가 다른</code> 논리적 단위인 <code>segment</code>로 분할한다.</li><li>세그먼트의 가상주소도 페이징과 동일하게 (세그먼트번호 + 블록 내 변위) 로 찾는다.</li></ul><h2 id="내부단편화-amp-외부단편화"><a href="#내부단편화-amp-외부단편화" class="headerlink" title="내부단편화 &amp; 외부단편화"></a>내부단편화 &amp; 외부단편화</h2><ul><li>내부단편화는 페이징 기법에서 나타나는 현상이다.</li><li>페이지 블록만큼 데이터가 채워지지 않았을 경우.</li><li>이식성을 중요시하는 리눅스는 페이징 기법으로 구현되어 있다.</li><li>외부단편화는 세그멘트 기법에서 나타나는 현상이다.</li><li>물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;가상메모리와 페이징 기법과 세그먼트 기법.&lt;br&gt;&lt;code&gt;#paging_system&lt;/code&gt; &lt;code&gt;#virtual_memory&lt;/code&gt; &lt;code&gt;#segment&lt;/code&gt; &lt;code&gt;#MMU&lt;/code&gt; &lt;code&gt;#TLB&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="paging_system" scheme="http://yoursite.com/tags/paging-system/"/>
    
    <category term="virtual_memory" scheme="http://yoursite.com/tags/virtual-memory/"/>
    
  </entry>
  
  <entry>
    <title>📑 Thread, Synchronization, Semaphore</title>
    <link href="http://yoursite.com/2021/05/11/%EC%93%B0%EB%A0%88%EB%93%9C/"/>
    <id>http://yoursite.com/2021/05/11/%EC%93%B0%EB%A0%88%EB%93%9C/</id>
    <published>2021-05-11T14:32:46.000Z</published>
    <updated>2021-05-20T01:06:40.837Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="Thread-쓰레드"><a href="#Thread-쓰레드" class="headerlink" title="Thread 쓰레드?"></a>Thread 쓰레드?</h1><ul><li>한마디로 프로세스의 서브셋이다.</li><li><code>Light Weight Process</code> 라고도 한다.</li><li>하나의 프로세스에 여러개 스레드 생성이 가능하다.</li><li>스레드를 동시에 실행 가능하다.</li><li>프로세스 내부에 있으므로 <code>프로세스 데이터에 접근이 가능</code>하다.</li><li>각 스레드마다 <code>stack</code>이 존재한다.</li></ul><h2 id="Process-vs-Thread"><a href="#Process-vs-Thread" class="headerlink" title="Process vs Thread"></a>Process vs Thread</h2><ul><li>Process</li><li>프로세스 간 서로의 영역에 데이터 접근이 불가하다.</li><li>자신만의 주소를 갖는다. (독립적)</li><li>통신을 위해서 IPC 기법이 필요하다.</li><li>하나의 프로세스에 문제가 생겼을 경우, 다른 프로세스에 영향을 주지 않는다.</li><li>Thread</li><li>프로세스 자원 정보가 공유된다.</li><li>스레드 간의 주소 영역을 공유한다.</li><li>CODE, DATA, HEAP 영역을 공유.</li><li>하나의 스레드에 오류가 발생하면, 같은 자원을 사용하는 동일한 프로세스 내의 모든 스레드의 작업이 중단된다.</li></ul><h2 id="Multi-Thread"><a href="#Multi-Thread" class="headerlink" title="Multi Thread"></a>Multi Thread</h2><ul><li>최근의 CPU 는 멀티 프로세싱이 가능하므로 (여러개 CPU) 프로세스 내에도 여러개의 스레드를 만들어 멀티코어의 활용도를 높인다.</li></ul><h2 id="Thread-의-장-단점"><a href="#Thread-의-장-단점" class="headerlink" title="Thread 의 장.단점"></a>Thread 의 장.단점</h2><ul><li>장점</li><li>사용자에 대한 응답속도 향상 (T1이 특정작업을 하는 동시에 T2는 사용자와 통신을 한다.)</li><li>프로세스의 자원공유를 위해서 사용되는 IPC (Inter Processing Communication) 기법과 같이, 별도의 작업을 할 필요가 없다.</li><li>프로세스의 데이터에 접근 할 수 있다.</li><li>단점</li><li>하나의 프로세스에 있는 여러개 스레드 중 하나라도 문제가 생기면, 전체 프로세스에 영향을 미친다.</li><li>스레드를 너무 많이 생성하면 Context Switching 이 빈번하게 발생하여 성능이 저하될 수 있다. (모든 스레드를 스케줄링 해야하므로.)</li><li>공유 자원을 사용하기 때문에 동기화 이슈가 있다.</li></ul><blockquote><ul><li>PThread = POSIX Threads</li></ul><ul><li>Thread 관련 표준 API</li></ul></blockquote><h1 id="동기화-Synchronization-이슈"><a href="#동기화-Synchronization-이슈" class="headerlink" title="동기화 (Synchronization) 이슈"></a>동기화 (Synchronization) 이슈</h1><ul><li>동시에 여러개의 스레드가 동잃한 자원을 사용할 경우 발생한다.</li><li>동일 자원을 여러 스레드가 동시 수정시 최종 결과에 영향을 미친다.</li><li>두 스레드가 같은 객체를 공유하면서 서로 간섭하며 예상치 못한 결과를 도출하게 된다.</li></ul><h2 id="동기화-이슈-예시"><a href="#동기화-이슈-예시" class="headerlink" title="동기화 이슈 예시"></a>동기화 이슈 예시</h2><ul><li>Cal.java : <code>Cal</code> 이라는 객체에 다음값을 리턴해주는 함수가 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idx=idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>TestThreads.java : th1, th2 이라는 스레드 두개를 만들어 각 set1, set2 에 Cal 객체를 사용하여 증가값을 넣어준다. (Set 은 중복을 허용하지 않음.)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThreads</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedIOException </span>&#123;</span><br><span class="line">    Cal cal = <span class="keyword">new</span> Cal(<span class="number">0</span>);</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">      Thread th1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line">            set1.add(cal.getNext());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line">            set2.add(cal.getNext());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set1 : &quot;</span>+set1.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;set2 : &quot;</span>+set2.size());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">        ee.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">                </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>main 함수를 실행시 코드 그대로의 결과는 set1과 set2 에 각각 100000 개의 사이즈가 나와야 한다. 그런데 set1 과 set2 의 사이즈를 찍어보면, 아래와 같이 조금 부족한 숫자가 나온다.</li></ul><img width="871" alt="스레드_동기화" src="https://user-images.githubusercontent.com/28856435/117925951-ef551780-b332-11eb-8d3e-e147ff79439a.png"><br><blockquote><p><code>왜 예상 결과값과 다를까?</code><br><strong>main 함수 수행 중, idx=8888 인 시점이라고 가정한다.</strong></p><ol><li>th1 가 연산을 수행하기 위해 idx=8888 을 가져온다. 이 때 th2 가 끼어들면 th1 은 다음 연산을 수행하지 못하고&gt;멈추게 된다. (각 스레드는 자신의 stack 영역을 갖는다.)</li><li>th2 도 수행을 위해 idx=8888을 가져오고 자신의 n번째 작업을 마친다. idx=8889 로 업데이트 된다.</li><li>th1 이 중단되었던 작업을 이어서 수행한다. 이때 th1이 갖고 있는 Cal() 객체의 idx=8888 이다. th1 도 자신의 n번째 작업을 마친다.</li><li>th1 의 작업으로 인해 idx=8889 가 된다. Cal() 객체의 idx 값이 덮어씌워진다. 언급한 작업은 두 번 이지만 idx 의 값은&gt;8889로 동일하게 유지되는 현상을 볼 수 있다.</li></ol></blockquote><h2 id="동기화-이슈-해결방안"><a href="#동기화-이슈-해결방안" class="headerlink" title="동기화 이슈 해결방안"></a>동기화 이슈 해결방안</h2><ul><li>상호배제 (Mutual Extension)</li><li>여러 스레드가 사용중인(변경중인) 공유 변수에 대해 배제 (exclusive access) 필요하다.</li><li>임계영역을 하나의 스레드가 어떤 자원을 사용할 때 다른 스레드가 동시에 접근할 수 없도록 막는다.</li><li>위에서 수행했던 java 예제에서는 아래와 같이 바꿔줄 수 있다. ++ 연산이 수행되는 임계점에 <code>synchronized</code> 를 붙여준다. 이 부분은 <code>동기화</code> 처리 되어 수행중인 스레드가 있을 때 다른 스레드가 간섭하지 못하게 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idx=idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="임계영역-Critical-Section"><a href="#임계영역-Critical-Section" class="headerlink" title="임계영역(Critical Section)"></a>임계영역(Critical Section)</h1><ul><li>하나의 스레드의 접근만 허락된 영역. 둘 이상의 스레드가 접근하면 문제를 일으킬 수 코드들.</li></ul><h2 id="Mutex-와-Semaphore"><a href="#Mutex-와-Semaphore" class="headerlink" title="Mutex 와 Semaphore"></a>Mutex 와 Semaphore</h2><ul><li>Mutex(binary semaphore) : 임계영역에 하나의 스레드만 접근 가능하다.</li><li>Semaphore : 카운터를 두어, 임계영역역에 허용 가능한 스레드 개수만큼 여러개의 스레드가 동시에 접근할 수 있도록 한다.</li></ul><h3 id="Semaphore-수도코드로-표현-feat-바쁜대기"><a href="#Semaphore-수도코드로-표현-feat-바쁜대기" class="headerlink" title="Semaphore 수도코드로 표현 (feat.바쁜대기)"></a>Semaphore 수도코드로 표현 (feat.바쁜대기)</h3><ul><li>세마포어를 아래 조건에서 수도코드로 나타냈을때.</li><li>P: 검사 (임계영역에 <code>들어갈때</code>) S값이 1이상이면 임계영역 진입후 S 값 차감. (S값이 0이면 대기)</li><li>V: 증가 (임계영역에서 <code>나올때</code>) S 값에 1을 더하고 임계 영역을 나옴.</li><li>S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시에 임계 영역 접근가능)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P</span>(S): <span class="built_in">wait</span>(S)&#123;</span><br><span class="line">  <span class="keyword">while</span> S &lt;= <span class="number">0</span> ; <span class="comment">// 바쁜 대기</span></span><br><span class="line">  </span><br><span class="line">  S--;</span><br><span class="line">  <span class="comment">// 다른 프로세스 접근 제한</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(S): <span class="built_in">signal</span>(S)&#123;</span><br><span class="line">  S++;</span><br><span class="line">  <span class="comment">// 다른 프로세스 접근 허용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wait 바쁜 대기 (S&lt;=0) 일 경우 프로세스 중단. 중단은 대부분 loop 로 표현된다.<br>즉, 중단은  CPU 에 부하를 줄 수 있다.</li></ul><h3 id="Semaphore-대기큐-운영체제-기술로-보완"><a href="#Semaphore-대기큐-운영체제-기술로-보완" class="headerlink" title="Semaphore - 대기큐 (운영체제 기술로 보완)"></a>Semaphore - 대기큐 (운영체제 기술로 보완)</h3><ul><li>S 가 음수일 경우, 바쁜대기 대신 대기큐에 넣는다.</li><li>block() 함수를 통해 대기상태로.</li><li>S 가 양수일 경우, 해당 프로세스를 대기큐에서 지운다.</li><li>wakeup() 함수를 통해 대기상태의 프로세스를 재실행.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">  S-&gt;count--;</span><br><span class="line">  <span class="keyword">if</span> ( S-&gt;count &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">    add <span class="keyword">this</span> process to S-&gt;queue;</span><br><span class="line">    <span class="built_in">block</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">  S-&gt;count++;</span><br><span class="line">  <span class="keyword">if</span> ( S-&gt;count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    remove a process P from S-&gt;queue;</span><br><span class="line">    <span class="built_in">wakeup</span>(P)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-주요함수"><a href="#Semaphore-주요함수" class="headerlink" title="Semaphore 주요함수"></a>Semaphore 주요함수</h2></li><li>sem_open() : 세마포어 생성</li><li>sem_wait() : 임계영역 접근 전, 세마포어를 잠그거나 잠겨있다면 풀릴때까지 대기.</li><li>sem_post() : 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.</li></ul><h1 id="교착상태-amp-기아상태"><a href="#교착상태-amp-기아상태" class="headerlink" title="교착상태 &amp; 기아상태"></a>교착상태 &amp; 기아상태</h1><h2 id="교착상태-deadlock"><a href="#교착상태-deadlock" class="headerlink" title="교착상태 (deadlock)"></a>교착상태 (deadlock)</h2><ul><li>무한대기상태 : 두개 이상의 작업이 서로의 작업이 끝나기만을 기다리며, 다음 단계로 진행하지 못함.</li><li>프로세스, 쓰레드에서 모두 일어날 수 있다.</li><li>배치 프로그램에서는 일어나지 않는다.</li><li>교착상태 발생조건</li><li>상호배제(Mutual Exclusion) : 프로세스들이 필요로하는 공유자원에 대해 권한 접근이 제한되기 때문에 한번에 하나의 프로세스만 공유자원을 사용할 수 있다.</li><li>점유대기 : 이미 자원을 할당받은 프로세스가 그 자원을 양보하지 않은 상태에서 다른 자원을 요구할 수 있다.</li><li>비선점 : 프로세스가 어떤 자원의 사용을 끝날때까지 뺏을 수 없다. 즉, 한 프로세스가 다른 프로세스의 접근 권한을 강제로 취소할 수 없다.</li><li>순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다. 두 개 이상의 프로세스가 자원 할당을 기다리는 사이클이 존재한다.</li></ul><h3 id="교착상태-해결방법"><a href="#교착상태-해결방법" class="headerlink" title="교착상태 해결방법"></a>교착상태 해결방법</h3><ul><li>교착상태 예방 : 교착상태 네 가지 발생조건 중 한가지를 제거한다.</li><li>교착상태 회피 : 교착상태 조건 중 자원할당 순서를 정의하지 않는다. (순환대기 조건 제거)</li><li>교착상태 발견 : 교착상태를 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것.</li><li>교착상태 회복 : 교착상태를 일으킨 프로세스를 종료하거나, 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것.</li></ul><h2 id="기아상태-Starvation"><a href="#기아상태-Starvation" class="headerlink" title="기아상태 (Starvation)"></a>기아상태 (Starvation)</h2><ul><li>우선순위가 낮은 프로세스가 원하는 자원을 영원히 할당받지 못하는 상태.</li></ul><h3 id="기아상태-해결방법"><a href="#기아상태-해결방법" class="headerlink" title="기아상태 해결방법"></a>기아상태 해결방법</h3><ul><li>프로세스 우선순위를 수시로 변경해서 할당받을 기회를 준다.</li><li>오리 기다린 프로세스의 우선순위를 높여준다.</li><li>우선순위가 아니라, 요청을 순서대로 처리하는 FIFO 기반 큐를 사용한다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Thread 의 개념 및 프로세스와의 차이점, 동기화 이슈 그리고 세마포어&lt;br&gt;&lt;code&gt;#semaphore&lt;/code&gt; &lt;code&gt;#thread&lt;/code&gt; &lt;code&gt;#mutex&lt;/code&gt; &lt;code&gt;#critical_section&lt;/code&gt; &lt;code&gt;#deadlock&lt;/code&gt; &lt;code&gt;#starvation&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
    <category term="semaphore" scheme="http://yoursite.com/tags/semaphore/"/>
    
  </entry>
  
</feed>
