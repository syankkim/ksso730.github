<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>동글씨</title>
  
  <subtitle>동글씨의 LOG</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-19T00:39:14.204Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Suyan Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>링크드리스트 구현</title>
    <link href="http://yoursite.com/2021/07/19/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84/"/>
    <id>http://yoursite.com/2021/07/19/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84/</id>
    <published>2021-07-18T15:39:43.000Z</published>
    <updated>2021-07-19T00:39:14.204Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><br><h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><ol><li>Linked List 구조</li></ol><ul><li>연결 리스트</li><li>배열은 순차적으로 연결된 공간에 데이터를 나열</li><li>링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결</li></ul><ol start="2"><li>기본 용어</li></ol><ul><li>노드</li><li>포인터</li></ul><hr><h2 id="Node-객체를-생성할-클래스"><a href="#Node-객체를-생성할-클래스" class="headerlink" title="Node 객체를 생성할 클래스"></a>Node 객체를 생성할 클래스</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><br><ul><li>아래와 같이도 쓸 수 있다.<ul><li>next 인자에 아무것도 넣지 않으면 <code>default 값으로 None</code>이 들어감</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><br>* Node 객체 하나(0)를 할당하고, add함수를 활용하여 1-9까지의 노드를 더한다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 입력</span></span><br><span class="line">node1= Node(<span class="number">0</span>)</span><br><span class="line">head = node1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;add &#x27;</span>,i)</span><br><span class="line">    add(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 출력</span></span><br><span class="line">node = head</span><br><span class="line"><span class="comment">#node 다음 객체가 있을 때까지</span></span><br><span class="line"><span class="keyword">while</span> node.<span class="built_in">next</span> : </span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    node = node.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 가장 마지막 node의 next값은 없기 때문에 for문을 마치고 마지막에 한번더 출력</span></span><br><span class="line"><span class="built_in">print</span>(node.data) </span><br></pre></td></tr></table></figure><br><img width="1062" alt="4" src="https://user-images.githubusercontent.com/28856435/126073591-23031a06-9a7b-42d9-ad47-667624343fbd.png"><br><h2 id="파이썬-객체지향-Linked-List-구현"><a href="#파이썬-객체지향-Linked-List-구현" class="headerlink" title="파이썬 객체지향 Linked List 구현"></a>파이썬 객체지향 Linked List 구현</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data=data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeMgt</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.head = Node(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            self.head=Node(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=self.head</span><br><span class="line">            <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">                node=node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>=Node(data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printDesc</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="built_in">print</span>(node.data)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><br><ul><li>구현한 Linked List 사용</li></ul><img width="950" alt="5" src="https://user-images.githubusercontent.com/28856435/126073891-c22c8817-0c1a-478e-9b86-53b9adf5394c.png"><br>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linked List with Python&lt;br&gt;링크드 리스트의 Node, Data&lt;br&gt;&lt;code&gt;#node&lt;/code&gt; &lt;code&gt;#data&lt;/code&gt; &lt;code&gt;#linked_list&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Algorithm" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>큐, 스택</title>
    <link href="http://yoursite.com/2021/07/18/%ED%81%90-%EC%8A%A4%ED%83%9D/"/>
    <id>http://yoursite.com/2021/07/18/%ED%81%90-%EC%8A%A4%ED%83%9D/</id>
    <published>2021-07-18T14:57:33.000Z</published>
    <updated>2021-07-19T00:39:14.207Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="일반적인-큐-FIFO"><a href="#일반적인-큐-FIFO" class="headerlink" title="일반적인 큐 FIFO"></a>일반적인 큐 FIFO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">data_q = queue.Queue()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_q.put(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">data_q.put(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><img width="909" alt="jupyter" src="https://user-images.githubusercontent.com/28856435/126072441-e3304e53-d9fd-4ea3-b765-958f30a31101.png"></br><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><blockquote><p>스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는것이 일반적</p></blockquote><ul><li><p>Pros &amp; Cons</p><ul><li><p>데이터를 제한적으로 접근 <code>LIFO</code></p></li><li><p>구조가 단순, 구현 쉽다.</p></li><li><p>데이터 저장/읽기 속도가 빠름.</p></li><li><p>데이터 최대갯수를 미리 정해야함.</p><ul><li>파이썬의 경우 <code>재귀함수는 1000번까지만 호출</code> 가능</li></ul></li><li><p>저장공간의 낭비 발생</p><ul><li>미리 최대 갯수만큼 저장공간 확보 필요</li></ul></li></ul></li></ul><h2 id="Stack-프로세스-함수-동작-방식에서-많이-쓰인다"><a href="#Stack-프로세스-함수-동작-방식에서-많이-쓰인다" class="headerlink" title="Stack - 프로세스 함수 동작 방식에서 많이 쓰인다."></a>Stack - 프로세스 함수 동작 방식에서 많이 쓰인다.</h2><blockquote><p><code>재귀함수</code>의 동작방식과 비슷하다.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 재귀함수의 동작 방식</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursive</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> data&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ended&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        recursive(data-<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;returned&quot;</span>, data)</span><br></pre></td></tr></table></figure></br><ul><li>위 recursive 함수를 실행시켜보면, 4-0 까지 stack data에 쌓인 뒤, 0이 되면 “ended” 를 찍는다.<br>그리고 다시 stack data에서 맨 상단의 0부터 4까지 다시 꺼낸다. -&gt; “returned ~” 에 찍힌 data로 확인된다.</br></li></ul><img width="982" alt="recursive" src="https://user-images.githubusercontent.com/28856435/126072813-e13d0c9c-57f4-4e2d-bfb3-0fd9b86354ec.png"></br><h2 id="Stack-파이썬-리스트-기능을-이용"><a href="#Stack-파이썬-리스트-기능을-이용" class="headerlink" title="Stack - 파이썬 리스트 기능을 이용"></a>Stack - 파이썬 리스트 기능을 이용</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack_ = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">stack_.append(<span class="number">1</span>)</span><br><span class="line">stack_.append(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></br><img width="703" alt="1" src="https://user-images.githubusercontent.com/28856435/126073148-bffc889c-31ec-4fce-b46a-163579230b69.png"></br><h3 id="pop-push-함수-없이-직접-stack-구현"><a href="#pop-push-함수-없이-직접-stack-구현" class="headerlink" title="pop(), push() 함수 없이 직접 stack 구현"></a>pop(), push() 함수 없이 직접 stack 구현</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">data</span>):</span></span><br><span class="line">    st.append(data)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span>():</span></span><br><span class="line">    data = st[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">del</span> st[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></br><img width="611" alt="2" src="https://user-images.githubusercontent.com/28856435/126073159-616658b8-7fc9-46f4-8f20-6849afa9c9da.png"></br>]]></content>
    
    
    <summary type="html">&lt;p&gt;Queue, Stack, Recursive Funtion&lt;br&gt;큐, 스택, 재귀함수?&lt;br&gt;&lt;code&gt;#queue&lt;/code&gt; &lt;code&gt;#stack&lt;/code&gt; &lt;code&gt;#linked_list&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Algorithm" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Algorithm/"/>
    
    
    <category term="queue" scheme="http://yoursite.com/tags/queue/"/>
    
    <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Node JS 기본, 시작해보기</title>
    <link href="http://yoursite.com/2021/07/04/nodejs-start/"/>
    <id>http://yoursite.com/2021/07/04/nodejs-start/</id>
    <published>2021-07-04T08:51:11.000Z</published>
    <updated>2021-07-19T00:39:14.202Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h1 id="💡-NodeJS-시작하기"><a href="#💡-NodeJS-시작하기" class="headerlink" title="💡 NodeJS 시작하기"></a>💡 NodeJS 시작하기</h1><h2 id="시작하기"><a href="#시작하기" class="headerlink" title="시작하기"></a>시작하기</h2><ul><li>다음 설치환경이 선행되어 있음<ul><li>nvm 버전관리 모듈 설치</li><li>npm 12.14.1 버전 사용</li></ul></li></ul><ul><li>프로젝트 폴더에서 npm 초기화</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm init y</span><br></pre></td></tr></table></figure><ul><li>아래 npm 모듈을 설치해본다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install parcel-bundler -D</span><br><span class="line">&gt; npm install lodash</span><br></pre></td></tr></table></figure><blockquote><p>📌  Parcel?</p><ul><li><code>꾸러미</code> 라는 뜻을 가졌다. 짐을 싸듯이 객체를 싸는 클래스이다.</li><li>쉽고 빠른 웹/앱 bundler.<br>  (bundler: 여라 파일들을 하나의 파일로 묶어주어 네트워크의 응답속도를 빠르게 도와주고 파일 간의 병목현상을 줄여, 유지보수의 효율성 증가)</li><li>Parcel 은 파일 변화를 자동으로 감지하여 다시 빌드하고, 빠른 모듈 교체를 지원하는 내장 개발용 서버를 보유하고 있어, 신속한 개발을 가능하게 한다.</li></ul></blockquote><blockquote><p>📌  lodash?</p><ul><li>유틸리티 라이브러리로 array, collection, date, number, object등이 있으며, 데이터를 쉽게 다룰 수 있도록 도와준다.</li><li>특히 자바스크립트 배열 내부의 객체들을 핸들링할 때 유용하다.</li><li>자주 사용하는 기능 : <code>filter</code>, <code>map</code>, <code>uniqBy</code> etc…</li></ul></blockquote><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json ?"></a>package.json ?</h2><ul><li>package.json : 패키지 모듈 직접 관리</li><li>package-lock.json : 인스톨한 패키지들을 내부에서 자동으로 관리</li></ul><h2 id="옵션-D-–save-dev"><a href="#옵션-D-–save-dev" class="headerlink" title="옵션 -D, –save-dev"></a>옵션 -D, –save-dev</h2><ul><li>옵션 -D, –save-dev : <code>devDependencies</code> 에 설치됨<ul><li>개발할 때만 필요. 웹브라우저에서는 직접적으로 동작하지 않는다.</li></ul></li></ul><h2 id="브라우저에서-index-html-띄우기"><a href="#브라우저에서-index-html-띄우기" class="headerlink" title="브라우저에서 index.html 띄우기"></a>브라우저에서 index.html 띄우기</h2><ul><li>dev: index.html 을 기준으로 <code>개발용</code>으로만 활용</li><li>build: index.html 을 기준으로 <code>웹브라우저</code>에서 동작시키는 용도</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;parcel index.html&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;parcel build index.html&quot;</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>터미널에서 명령어 사용, localhost:1234 접속</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run dev</span><br></pre></td></tr></table></figure><h2 id="lodash-모듈-사용"><a href="#lodash-모듈-사용" class="headerlink" title="lodash 모듈 사용"></a>lodash 모듈 사용</h2><ul><li>아래 코드를 입력하고</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hellow&#x27;</span>);</span><br><span class="line"><span class="comment">// lodash 모듈을 사용</span></span><br><span class="line"><span class="built_in">console</span>.log(_.camelCase(<span class="string">&#x27;hello suyeon&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li> <code>npm run dev</code> 실행후 브라우저에서 접속하면 console에서 아래와 같이 적용된다.<br><img src="https://user-images.githubusercontent.com/28856435/124388083-14a34800-dd1c-11eb-8d2a-2e04b337845e.PNG" alt="node1"></li></ul></br><hr><h1 id="💡-유의적-버전-Semantic-Versioning-버전규칙"><a href="#💡-유의적-버전-Semantic-Versioning-버전규칙" class="headerlink" title="💡 유의적 버전 (Semantic Versioning) ;버전규칙"></a>💡 유의적 버전 (Semantic Versioning) ;버전규칙</h1><ul><li><p>^Major.Minor.Patch</p><ul><li>^ : Major 버전 안에서 가장 최신 버전으로 업데이트 가능<ul><li>해당 기호를 지우면 <code>npm update</code> 사용하여 업데이트 불가하다</li></ul></li><li>Major : 기존 버전과 호환되지 않는 새로운 버전</li><li>Minor : 기존 버전과 호환되는 새로운 기능이 추가된 버전</li><li>Patch : 기존 버전과 호환되는 버그 및 오타 등이 수정된 버전</li></ul></li><li><p>버전 정보 확인</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info lodash</span><br></pre></td></tr></table></figure><h2 id="버전을-낮춰서-설치하기"><a href="#버전을-낮춰서-설치하기" class="headerlink" title="버전을 낮춰서 설치하기"></a>버전을 낮춰서 설치하기</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash@4.17.20</span><br></pre></td></tr></table></figure><hr><h1 id="💡-프로젝트-버전-관리-NPM"><a href="#💡-프로젝트-버전-관리-NPM" class="headerlink" title="💡 프로젝트 버전 관리 NPM"></a>💡 프로젝트 버전 관리 NPM</h1><h2 id="패키지-재설치-package-json"><a href="#패키지-재설치-package-json" class="headerlink" title="패키지 재설치 (package.json)"></a>패키지 재설치 (package.json)</h2><ul><li>node_mudule 폴더를 지우더라도 <code>npm -i</code> 를 통해서 다시 설치 가능 (.cache, dist도 마찬가지)</li></ul><h2 id="gitignore-생성하여-버전관리-제외"><a href="#gitignore-생성하여-버전관리-제외" class="headerlink" title=".gitignore 생성하여 버전관리 제외"></a>.gitignore 생성하여 버전관리 제외</h2><ul><li>버전관리가 불필요한 파일들을 .gitignore 에 추가하여 제외할 수 있다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.cache/</span><br><span class="line">dist</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure><ul><li><code>git status</code> 명령어로 확인, <code>.gitignore</code> 에 추가한 파일은 올라가지 않는다.</li></ul><p><img src="https://user-images.githubusercontent.com/28856435/124389250-4834a100-dd21-11eb-8a41-c59cb9e7c3d2.PNG" alt="nod2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;parcel bundler를 이용하여 웹에 index.html을 띄워본다.&lt;br&gt;버전관리, package.json 등의 의미&lt;br&gt;&lt;code&gt;#nvm&lt;/code&gt; &lt;code&gt;#npm&lt;/code&gt; &lt;code&gt;#parcel&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ NodeJS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-NodeJS/"/>
    
    
    <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>python postgresql 연동</title>
    <link href="http://yoursite.com/2021/06/23/python-postgresql-%EC%97%B0%EB%8F%99/"/>
    <id>http://yoursite.com/2021/06/23/python-postgresql-%EC%97%B0%EB%8F%99/</id>
    <published>2021-06-23T04:36:02.000Z</published>
    <updated>2021-06-30T08:17:37.007Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="psycopg2-를-이용하여-Python-Database-연동"><a href="#psycopg2-를-이용하여-Python-Database-연동" class="headerlink" title="psycopg2 를 이용하여 Python Database 연동"></a>psycopg2 를 이용하여 Python Database 연동</h1><ol><li>Database 정보 config.ini 설정</li></ol><ul><li>config.ini<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DB]</span><br><span class="line">host=172.23.174.55</span><br><span class="line">database=mydatabase</span><br><span class="line">user=mydb</span><br><span class="line">password=1234</span><br><span class="line">port=5432</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>DB Load &amp; Connect</li></ol><ul><li>main.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load DB =&gt; config.&#123;.ini파일&#125;(section=&#123;해당 DB 설정변수&#125;)</span></span><br><span class="line">db=config.config(section=<span class="string">&#x27;DB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = psycopg2.connect(**db)</span><br><span class="line">    curs = conn.cursor()</span><br><span class="line">    curs.execute(query[<span class="string">&#x27;select&#x27;</span>],(user_id, phone_num))</span><br></pre></td></tr></table></figure></li></ul><h1 id="Python-Database-API"><a href="#Python-Database-API" class="headerlink" title="Python Database API"></a>Python Database API</h1><ul><li>fatchone</li><li>fatchall</li><li>fatchmany(row개수)</li></ul><h1 id="파일-데이터-처리"><a href="#파일-데이터-처리" class="headerlink" title="파일 데이터 처리"></a>파일 데이터 처리</h1><p>읽기(r), 쓰기(w 혹은 x), 추가(a), 수정(+) 모드</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python postgresql 연동&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ DataBase" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>네트워크-OSI모델, 물리계층과 데이터링크계층</title>
    <link href="http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI%EB%AA%A8%EB%8D%B8-%EB%AC%BC%EB%A6%AC%EA%B3%84%EC%B8%B5/"/>
    <id>http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI%EB%AA%A8%EB%8D%B8-%EB%AC%BC%EB%A6%AC%EA%B3%84%EC%B8%B5/</id>
    <published>2021-06-16T06:17:17.000Z</published>
    <updated>2021-06-17T09:30:11.889Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><blockquote><p>네트워크 프로토콜의 모음.<br><code>패킷 통신 방식</code>의 <code>IP</code>와<br><code>전송 조절 프로토콜</code>인 <code>TCP</code>로 이루어져 있다.</p></blockquote><ul><li><strong>TCP/IP &amp; OSI 7 Layer</strong></li></ul><table>    <thead>        <tr>            <th>TCP/IP</th>            <th>Service/Protocol</th>            <th>OSI 7Layer</th>        </tr>    </thead>    <tbody>        <tr>            <td rowspan=3>Application</td>            <td rowspan=3>HTTP, SMTP, DNS</td>            <td>Application</td>        </tr>        <tr>            <td>Presentaition</td>        </tr>        <tr>            <td>Session</td>        </tr>        <tr>          <td>Transport</td>          <td>TCP, UDP</td>          <td>Transport</td>        </tr>        <tr>          <td>Network</td>          <td>IP, ICMP, OSPF</td>          <td>Network</td>        </tr>        <tr>          <td rowspan=2>Network Interface</td>          <td rowspan=2>Ethernet</td>          <td>Data Link</td>        </tr>        <tr>          <td>Physical</td>        </tr>    </tbody></table><br><hr><h1 id="물리계층"><a href="#물리계층" class="headerlink" title="물리계층"></a>물리계층</h1><blockquote><p>OSI 7 Layer 1계층의 하드웨어</p></blockquote><ul><li>네트워크 장치의 <code>전기적, 기계적</code> 속성과 전송하는 수단</li><li><code>데이터 링크</code> 계층 프레임 –&gt; (bit를 Signal 로 인코딩) –&gt; <code>네트워크 장치</code>로 전송</li><li>통신 장치와 커넥터, 인코딩(Bit to Signal), 송수신을 담당하는 회로 등의 요소 포함</li><li>전송하는 수단인 Signaling(신호)은 전기, 광, 무선 등이 있다.</li></ul><h2 id="물리계층-장비"><a href="#물리계층-장비" class="headerlink" title="물리계층 장비"></a>물리계층 장비</h2><ul><li>허브 &amp; 리피터<ul><li>허프는 전기신호를 증폭하여 포트에 연결된 PC들끼리 통신이 가능</li><li>리피터는 현재 거의 쓰이지 않는다. 세기를 더 증폭하여 더 멀리까지 통신이 가능</li></ul></li></ul><h3 id="허브-동작방식"><a href="#허브-동작방식" class="headerlink" title="허브 동작방식"></a>허브 동작방식</h3><blockquote><p>허브는 <code>브로드캐스팅</code> 통신과 <code>CSMA/CD</code> 방식을 사용, <code>Half Duplex</code> 모드이다.</p></blockquote><ul><li>브로드캐스팅 1 : All</li><li>유니캐스트 1 : 1</li><li>멀티캐스트 1 : N</li></ul><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><blockquote><p>Carrier Sense Multiple Access / Collision Detection</p></blockquote><ol><li>Carrier Sensing: 데이터를 보내기 전에 다른 노드에서 데이터를 보내는 중인지 확인</li><li>Multiple Access: 데이터를 보내는곳이 없으면 전송</li><li>Collision Detection: 동시간대의 데이터 충돌 후 정지. 일정시간 이후 재동작</li></ol><h3 id="전송방식"><a href="#전송방식" class="headerlink" title="전송방식"></a>전송방식</h3><ol><li>Simplex: 단방향 통신으로 수신측은 송신척에 응답 불가</li><li>Half Duplex: 반이중 전송방식. 무전기.</li><li>Full Duplex: 전이중 전송방식. 전화기.</li></ol><h3 id="케이블-커넥터"><a href="#케이블-커넥터" class="headerlink" title="케이블/커넥터"></a>케이블/커넥터</h3><ul><li><code>TP</code>(Twisted Pair)<ul><li>총 8가닥의 선으로 구성. 두개의 선을 서로 꼬아놓음<ul><li>UTP(Unshield Twisted Pair), STP(Shielded Twisted Pair)</li></ul></li></ul></li><li><code>Coaxial</code>(동축)<ul><li>선 중앙에 심선있음. 전화 또는 회선망 등 사용</li></ul></li><li><code>Fiber</code>(광)  - 전기신호이 자기장이 없는 빛으로 통신하기 때문에 장거리 고속통신 가능<ul><li>모드(Single, Multi), 커넥터타입(LC, SC)</li></ul></li><li>광 트랜시버<ul><li>광통신에 사용되는 네트워크 인터페이스 모튤 커넥터<ul><li>SFP, GBIC 등</li></ul></li></ul></li></ul><h3 id="장비의-Capacity-성능"><a href="#장비의-Capacity-성능" class="headerlink" title="장비의 Capacity 성능"></a>장비의 Capacity 성능</h3><ul><li><strong>Bandwidth</strong>(대역폭)::8차선 도로<ul><li>주어진 시간대에 네트워크를 통해 이동가능한 정보의 양</li></ul></li><li><strong>Throughput</strong>(처리량)::8차선 도로를 달리는 자동차의 양<ul><li>단위 시간당 디지털 데이터 전송으로 처리하는 양</li></ul></li><li><strong>BackPlane</strong><ul><li>네트워크 장비가 최대로 처리가능한 데이터 용량</li></ul></li><li><strong>CPS</strong>(Connections Per Second): 초당 커넥션 연결수, L4</li><li><strong>CC</strong>(Concurent Connections): 최대 수용가능한 커넥션</li><li><strong>TPS</strong>(Transactions Per Seconds): 초당 트랜젝션 연결수, L7, HTTP성능</li><li>데이터 단위<ul><li>bit &amp; Byte 존재. Kilo, Mega, Giga, Tera로 표현</li></ul></li></ul><h2 id="UTP-케이블"><a href="#UTP-케이블" class="headerlink" title="UTP 케이블"></a>UTP 케이블</h2><p><strong>::Unshielded Twisted Pair, 주로 근거리 통신망에 사용되는 케이블로, 이더넷망 구성시 가장 많이 보임</strong></p><h3 id="코드배열"><a href="#코드배열" class="headerlink" title="코드배열"></a>코드배열</h3><ul><li><strong>8P8C</strong>: 8개의 선 배열에 따라 다이렉트 또는 크로스 케이블로 구성<ul><li>Direct Cable: PC to Hub -&gt; DTE to DCE</li><li>Cross Cable: PC to PC, Hub to Hub -&gt; DTE to DTE, DCE to DCE</li><li>DTE(Data <code>Terminal</code> Equipment), DCE(Data <code>Communication</code> Equipment)</li></ul></li></ul><h3 id="Auto-MDI-X"><a href="#Auto-MDI-X" class="headerlink" title="Auto MDI-X"></a>Auto MDI-X</h3><ul><li>Automatic Medium Dependent Interface Crossover</li><li>어떤 노드의 연결인지에 따라 다이렉트와 크로스 케이블을 선택하는 불편함을 개선하여, <code>케이블 타입에 관계없이</code> 노드 상호간 <code>자동</code>으로 통신 가능</li></ul><h3 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h3><ul><li>비영리 기구인 Wi-Fi Aliance의 상표로 전자기기들이 무선랜에 연결할 수 있게 하는 기술</li><li>무선랜 구성시 WIPS(보안)-AP(무선 Hub)</li></ul><h3 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h3><blockquote><p>오픈소스 패킷 분석 프로그램</p></blockquote><ul><li>인터페이스를 선택하고 실시간 패킷 확인과 저장, 분석이 가능</li><li>pcap 파일을 통해서 Fram-L2-L3-L4 정보 확인 가능</li></ul><hr><h1 id="데이터링크-계층"><a href="#데이터링크-계층" class="headerlink" title="데이터링크 계층"></a>데이터링크 계층</h1><blockquote><p>OSI 7 Layer 2계층. 인접한 네트워크 노드끼리 데이터를 전송하는 기능과 절차 제공</p></blockquote><ul><li>물리계층에서 발생가능한 오류를 감지, 수정</li><li>대표적인 프로토콜에는 <code>이더넷</code>, 장비는 <code>스위치</code></li></ul><h2 id="부계층-MAC-amp-LLC"><a href="#부계층-MAC-amp-LLC" class="headerlink" title="부계층 MAC &amp; LLC"></a>부계층 MAC &amp; LLC</h2><ul><li><strong>MAC (Media Access Control)</strong>: 물리적인 부분. 매체간의 연결방식 제어, 1계층과 연결</li><li><strong>LLC (Logical Link Control)</strong>: 논리적인 부분. Frame을 만들어 3계층과 연결</li></ul><h2 id="주요기능"><a href="#주요기능" class="headerlink" title="주요기능"></a>주요기능</h2><p><strong>:: Framing, 회선제어, 흐름제어, 오류제어</strong></p><h3 id="Framing"><a href="#Framing" class="headerlink" title="Framing"></a>Framing</h3><ul><li>데이터그램을 캡슐화하여 프레임단위로 만들고 <code>header</code> 헤더와 <code>trailer</code> 트레일러 추가</li><li>헤더: 목적지, 출발지 주소, 데이터 내용 정의</li><li>트레일러: <code>비트에러</code> 감지</li></ul><h3 id="회선제어"><a href="#회선제어" class="headerlink" title="회선제어"></a>회선제어</h3><ul><li><strong>Select 모드</strong>: 송신자가 나머지 수신자들을 선택하여 전송</li><li><strong>Poll 모드</strong>: 수신자에게 데이터 <code>수신 여부를 확인</code>하여 응답을 확인하고 전송</li></ul><h3 id="흐름제어"><a href="#흐름제어" class="headerlink" title="흐름제어"></a>흐름제어</h3><p><strong>:: 송신자와 수신자의 데이터를 처리하는 속도 차이를 해결하기 위한 제어</strong></p><ul><li>Feedback 방식의 Flow Control, 상위 계층은 Rate기반</li><li><strong>Stop &amp; Wait</strong> : 데이터를 보내고 <code>ACK</code> 응답이 올 때까지 기다림<ul><li>간단히 구현될 수 있지만 비효율적</li><li>데이터를 보내고 ACK응답이 오지 않으면 일정시간 후 <code>다시 보냄</code></li></ul></li><li><strong>Sliding window</strong>: ACK 응답 없이 여러개의 프레임 연속 전송<ul><li><ol><li>PC1: Frame 전송후 Window size축소</li></ol></li><li><ol start="2"><li>PC2: (현재ACK)-(이전ACK)= Window size</li></ol></li><li><ol start="3"><li>PC1: ACK 수신후 Window size 확장</li></ol></li></ul></li></ul><h3 id="오류제어"><a href="#오류제어" class="headerlink" title="오류제어"></a>오류제어</h3><p><strong>:: 전송중에 오류나 손실 발생시 수신측에서 에러탐지 및 재전송</strong></p><ul><li><strong>ARQ(Automatic Repeat Request)</strong>: 프레임 손상시 재전송 수행과정</li><li><strong>Stop &amp; Wait ARQ</strong><ul><li>전송측에서 <code>NAK</code> 수신시 재전송</li><li>주어진 시간에 ACK 안오면 재전송</li></ul></li><li><strong>Go Back n ARQ</strong><ul><li><ol><li>전송측 Frame 6개전송</li></ol></li><li><ol start="2"><li>수신측 NAK 3으로 손상응답</li></ol></li><li><ol start="3"><li>전송측 3이 포함된 345 재전송</li></ol></li></ul></li><li><strong>Selective Repeat ARQ</strong><ul><li>손상된 Frame만 <code>선별</code>하여 재전송</li></ul></li></ul><h2 id="이더넷-프레임-구조"><a href="#이더넷-프레임-구조" class="headerlink" title="이더넷 프레임 구조"></a>이더넷 프레임 구조</h2><h3 id="Ethernet-v2"><a href="#Ethernet-v2" class="headerlink" title="Ethernet v2"></a>Ethernet v2</h3><p><strong>::</strong> 데이터 링크 계층에서 MAC 통신과 프로토콜 형식을 정의</p><ul><li><strong>Preamble</strong>: 이더넷 프레임의 시작과 동기화</li><li><strong>Dest Addr</strong>: 목적지 MAC주소</li><li><strong>Src Addr</strong>: 출발지 MAC주소</li><li><strong>Type</strong>: 캡슐화된 패킷의 프로토콜정의</li><li><strong>Data</strong>: 상위 계층의 데이터</li><li><strong>FCS(Frame Check Sequence)</strong>: 에러체크</li></ul><h2 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h2><p><strong>:: 2계층의 대표적인 장비. MAC주소 기반 통신</strong></p><ul><li>허브의 단점을 보완<ul><li>Half duplex -&gt; Full duplex</li><li>1 Collision Domain -&gt; 포트별 Collision Domain</li></ul></li><li>L3 스위치: 라우팅 기능이 있는 스위치</li></ul><h3 id="스위치-동작방식"><a href="#스위치-동작방식" class="headerlink" title="스위치 동작방식"></a>스위치 동작방식</h3><p><strong>:: 목적지 주소를 MAC 주소 테이블에서 확인, 연결된 포트로 프레임 전달</strong></p><ol><li><strong>Learning</strong>: 출발지 주소가 MAC 테이블에 없으면 해당 주소 저장</li><li><strong>Flooding-Broadcasting</strong>: 목적지 주소가 MAC 테이블에 <strong>없으면</strong> <code>전체포트</code>로 전달</li><li><strong>Forwarding</strong>: 목적지 주소가 MAC 테이블에 <strong>있으면</strong> <code>해당 포트</code>로 전달</li><li><strong>Filtering-Collision Domain</strong>: 출발지와 목적지가 <code>같은 네트워크 대역</code>일 경우 다른 네트워크로 전달하지 않음</li><li><strong>Aging</strong>: MAC 주소 테이블의 정보를 일정시간 이후에 삭제</li></ol><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p><strong>:: ARP(Address Resolution Protocol)- IP주소를 통해 MAC주소를 알려줌</strong><br>(ARP Request – ARP Reply)</p><h3 id="ARP-동작과정"><a href="#ARP-동작과정" class="headerlink" title="ARP 동작과정"></a>ARP 동작과정</h3><ol><li><strong>PC1(172.10.10.1) –&gt; PC2(172.10.10.9) 패킷전송</strong> 시도</li></ol><ul><li>PC1 자신의 <code>ARP Cache Table</code> 에서 목적지 <code>MAC주소</code> 확인</li></ul><ol start="2"><li>ARP Cache Table 에 있을경우: 패킷전송<br>ARP Cache Table 에 <strong>없을경우</strong>: <code>ARP Request</code>-Broadcasting</li><li>PC2(172.10.10.9) 에서 목적지 MAC주소 <code>ARP Reply</code></li><li>목적지 MAC주소 ARP Cache Table 에 <code>저장</code>, <code>패킷 전송</code></li></ol><h3 id="ARP-헤더구조-pcap"><a href="#ARP-헤더구조-pcap" class="headerlink" title="ARP 헤더구조(pcap)"></a>ARP 헤더구조(pcap)</h3><ul><li>Hardware Type: ARP 동작하는 네트워크 환경, 이더넷</li><li>Protocol Type: 프로토콜 종류</li><li>Hardware &amp; Protocol Length</li><li>Operation: 명령코드, 1=ARP Request, 2=ARP Reply</li><li>Hardware Address=MAC, Protocol Address=IP</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OSI모델의 물리계층? 우리가 알던 그 장비.&lt;br&gt;항상 접하던 Ethernet, 스위치, ARP 프로토콜에 대하여.&lt;br&gt;&lt;code&gt;#osi_7_layer&lt;/code&gt; &lt;code&gt;#tcp_ip&lt;/code&gt; &lt;code&gt;#csma_cd&lt;/code&gt; &lt;code&gt;#switch&lt;/code&gt; &lt;code&gt;#ethernet&lt;/code&gt; &lt;code&gt;#arp&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Network" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Network/"/>
    
    
    <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
    <category term="osi_7_layer" scheme="http://yoursite.com/tags/osi-7-layer/"/>
    
  </entry>
  
  <entry>
    <title>네트워크-OSI모델, 물리계층과 데이터링크계층</title>
    <link href="http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A7%81%ED%81%AC%EA%B3%84%EC%B8%B5/"/>
    <id>http://yoursite.com/2021/06/16/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A7%81%ED%81%AC%EA%B3%84%EC%B8%B5/</id>
    <published>2021-06-16T06:17:17.000Z</published>
    <updated>2021-07-19T00:39:14.203Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><ul><li>물리적 구성이 아닌 논리적인 가상의 LAN</li></ul><h2 id="VLAN-종류"><a href="#VLAN-종류" class="headerlink" title="VLAN 종류"></a>VLAN 종류</h2><ol><li><p>Port기반 VLAN</p><ul><li>여러개의 VLAN을 설정하고 각각의 LAN에 물리적인 포트를 지정</li></ul></li><li><p>MAC주소 기반</p></li><li><p>IP주소 기반</p></li></ol><h2 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h2><blockquote><p>물리적 스위치간 VLAN 연결시 하나의 물리적 연결로 VLAN 그룹들 공유</p></blockquote><h3 id="트렁크-프로토콜"><a href="#트렁크-프로토콜" class="headerlink" title="트렁크 프로토콜"></a>트렁크 프로토콜</h3><ul><li><p>이더넷 프레임에 식별용 <code>VLAN ID</code> 삽입하여 데이터를 구분해 통신 및 제어</p></li><li><p>VLAN Tagging: VLAN ID 정보</p><ul><li>eg. VLAN 100, VLAN 200, VLAN 300</li></ul></li><li><p>TPID(Tag Protocol IDentifier): 태그되지 않은 프레임과 태깅된 프레임을 구별</p></li><li><p>TCI(Tag Contol Information): 태그 제어 정보</p></li></ul><ol><li>PCP(Priority Code Point)</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;OSI모델의 물리계층? 우리가 알던 그 장비.&lt;br&gt;항상 접하던 Ethernet, 스위치, ARP 프로토콜에 대하여.&lt;br&gt;&lt;code&gt;#osi_7_layer&lt;/code&gt; &lt;code&gt;#tcp_ip&lt;/code&gt; &lt;code&gt;#csma_cd&lt;/code&gt; &lt;code&gt;#switch&lt;/code&gt; &lt;code&gt;#ethernet&lt;/code&gt; &lt;code&gt;#arp&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Network" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Network/"/>
    
    
    <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
    <category term="osi_7_layer" scheme="http://yoursite.com/tags/osi-7-layer/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터구조-멀티프로세서</title>
    <link href="http://yoursite.com/2021/06/12/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C/"/>
    <id>http://yoursite.com/2021/06/12/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C/</id>
    <published>2021-06-12T01:50:54.000Z</published>
    <updated>2021-06-16T06:07:51.864Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="Serial-vs-Parallel"><a href="#Serial-vs-Parallel" class="headerlink" title="Serial vs Parallel"></a>Serial vs Parallel</h1><ul><li>Serial Process system<ul><li>CPU 가 하나뿐인 시스템</li><li>기계적, 논리적 프로세싱으로 가장 효율적</li></ul></li><li>Parallel Process system<ul><li>동시에 여러작업 실행가능한 병렬처리 시스템</li><li>=병렬구조</li><li>병렬처리 소프트웨어가(병렬 운영체제, 병렬 컴파일러, 메모리 공유) 과거에 비해 비약적인 발전을 이루고 있음</li></ul></li></ul><h2 id="Parallel-Process-system"><a href="#Parallel-Process-system" class="headerlink" title="Parallel Process system"></a>Parallel Process system</h2><ul><li><strong>다중장치 구조</strong><ul><li><code>다수의 CPU</code>로 동시에 여러개의 작업을 병렬로 처리</li><li><code>공간적</code> 병렬성</li></ul></li><li><strong>파이프라인 구조</strong><ul><li><code>다수의 작업</code>을 각기 다른 실행단계에서 병렬로 처리</li><li><code>시간적</code> 병렬성</li></ul></li></ul><h2 id="멀티프로세서"><a href="#멀티프로세서" class="headerlink" title="멀티프로세서"></a>멀티프로세서</h2><ul><li>메모리와 I/O 장치를 공유하는 <code>두 개 이상의 CPU</code>를 갖는 시스템</li><li>다중명령어 &amp; 다중데이터 = <code>MIMD</code> 시스템에 포함된다.</li><li><code>하나의 운영체제</code>에 의해 프로세서-다른요소들 사이의 동작이 제어된다.<ul><li>동일한 문제해결을 위해 모든 요소들이 협력</li></ul></li><li><strong>시스템 신뢰성 향상</strong><ul><li><code>다수의 독립적 작업</code>들이 <code>병렬</code>적으로 처리된다.</li><li><code>하나의 작업</code>이 여러 부분들로 나눠져 <code>병렬</code>로 처리된다.</li></ul></li><li>사용자가 명시적으로 병렬실행 가능한 작업을 선언한다.</li><li>컴파일러가 자동적으로 프로그램의 <code>병렬성을 감지</code>하여 처리한다.</li></ul><h3 id="멀티프로세서-분류"><a href="#멀티프로세서-분류" class="headerlink" title="멀티프로세서 분류"></a>멀티프로세서 분류</h3><ul><li>Shared memory ;공유메모리(=밀착결합 멀티프로세서): 연관성이 있는 작업을 할때</li><li>Distributed memory: 프로세서마다 독립된 시스템</li><li>Loosely coupled: 프로세서가 옮겨다니는 형식. 어느 경우에는 하나의 프로세서만 적용될 수 있음</li></ul><hr><h2 id="멀티프로세서-상호연결-구조"><a href="#멀티프로세서-상호연결-구조" class="headerlink" title="멀티프로세서 상호연결 구조"></a>멀티프로세서 상호연결 구조</h2><ul><li>CPU, IOP(I/O Processor) 그리고 여러 모듈로 분리된 메모리 장치에 의해 구성된다.</li><li>공유 메모리 시스템: <code>프로세스와 메모리 사이</code>의 경로 수에 따름</li><li>느슨히 결합된 시스템: <code>프로세싱 요소들 사이</code>의 전송경로 수에 따라 물리적으로 다른 구성</li></ul><h3 id="1-시분할-공통버스"><a href="#1-시분할-공통버스" class="headerlink" title="1) 시분할 공통버스"></a>1) 시분할 공통버스</h3><ul><li><strong>단일</strong> 공통버스 시스템<ul><li>주어진 시간에 <code>하나의 프로세서만</code>이 시스템 버스를 사용</li><li><code>충돌 발생시</code> 버스제어기에 의해 해결가능</li><li>시스템 전체 전송률이 단일 경로의 속도에 <code>제한</code>된다</li></ul></li><li><strong>이중</strong> 버스 구조<ul><li>주어진 시간에 <code>하나의 프로세서만</code>이 시스템 버스를 사용</li><li>시스템 버스 제어기에 각 <code>로컬버스</code>를 연결</li><li>각 프로세서들의 대기시간 감소</li><li>여러개의 버스 <code>동시전송</code> 가능</li><li>시스템 구축 비용과 <code>복잡도</code>가 증가</li></ul></li></ul><h3 id="2-다중-포트-메모리"><a href="#2-다중-포트-메모리" class="headerlink" title="2) 다중 포트 메모리"></a>2) 다중 포트 메모리</h3><ul><li>CPU or IOP 와 각 메모리 모듈이 버스라인을 갖고 있는 시스템</li><li>각 모듈은 주어진 시간에 <code>어떤 포트가 메모리에 접근할 수 있을지</code> 결정하는 내부 <code>논리회로</code> 보유</li><li>메모리 접근을 위한 <code>우선순위는 포트의 위치</code>에 따라 결정</li><li><code>고가</code>의 메모리 제어 논리회로와 전선 커넥터</li></ul><h3 id="3-크로스바-스위치-Crossbar-switch"><a href="#3-크로스바-스위치-Crossbar-switch" class="headerlink" title="3) 크로스바 스위치 (Crossbar switch)"></a>3) 크로스바 스위치 (Crossbar switch)</h3><ul><li><em>프로세스 버스</em> 와 <em>메모리 모듈</em> 통로간의 <code>교차점</code>에 위치한 여러개의 크로스포인트로 구성</li><li><code>크로스포인트</code>(crosspoints)<ul><li>프로세서와 메모리 모듈간의 <code>통로를 결정</code>하는 스위치</li><li>버스에 실린 주소를 확인하여 통로를 열어주며, 주어진 <code>순위</code>에 따라 중재도 가능</li></ul></li></ul><h3 id="4-다단-교환망"><a href="#4-다단-교환망" class="headerlink" title="4) 다단 교환망"></a>4) 다단 교환망</h3><ul><li>2입력, 2출력 상호교환 스위치</li><li>2개 입력 중 하나만을 선택하여 전체 경로를 연결</li><li>충돌 중재</li><li>입출력 단자를 연결할 수 있는 제어신호 필요</li></ul><h3 id="5-하이퍼-큐브-상호연결"><a href="#5-하이퍼-큐브-상호연결" class="headerlink" title="5) 하이퍼 큐브 상호연결"></a>5) 하이퍼 큐브 상호연결</h3><ul><li>2<super>n</super>개의 프로세서가 <em>n차원 이진 큐브</em> 로 연결되어 느슨히 결합된 시스템</li><li>각 프로세서는 큐브의 <code>노드</code>를 형성. 이 노드에는 <code>CPU</code> 뿐 아니라 <code>로컬 메모리</code>나 <code>I/O 인터페이스</code>도 포함</li></ul><hr><h2 id="중재-프로세스"><a href="#중재-프로세스" class="headerlink" title="중재 프로세스"></a>중재 프로세스</h2><ul><li>공유 메모리 멀티프로세서 시스템에서 각 자원의 <code>효율적 분배</code>와 <code>상호 충돌을 배제</code>할 수 있는 <code>중재 프로세스</code>는 전체 시스템에 큰 영향을 준다.</li></ul><h3 id="중재-알고리즘"><a href="#중재-알고리즘" class="headerlink" title="중재 알고리즘"></a>중재 알고리즘</h3><ul><li>일반적으로 시스템 버스는 100여개의 신호라인으로 구성. 이 명령라인에 의해 논리가 성립.<ul><li>직렬 중재절차 (daisy-chain)<ul><li>순서가 정해져 있다. 우선순위가 높아도 작업이 끝날때까지 기다려야한다.</li></ul></li><li>병렬 중재논리<ul><li>순서가 정해져 있다.</li></ul></li><li>동적 중재논리<ul><li>큐를 설치</li></ul></li></ul></li></ul><hr><h1 id="프로세서간-통신과-동기화"><a href="#프로세서간-통신과-동기화" class="headerlink" title="프로세서간 통신과 동기화"></a>프로세서간 통신과 동기화</h1><ul><li>멀티 프로세서 시스템의 다양한 프로세서들은 <code>공통의 입출력 채널</code>을 통해 통신</li><li><strong>공통 메모리의 역할</strong><ul><li>메모리의 일부를 모든 프로세서가 접근가능하도록 할당한 공간</li><li><code>송신 프로세서</code>: 요구, 메시지, 프로시저 저장하여 의미있는 정보의 유무를 공지</li><li><code>수신 프로세서</code>: 폴링방식에 의해 주기적 점검<ul><li>더 효율적인 통신방식? <code>인터럽트 신호</code>를 통하여 정보를 지정하여 통신</li></ul></li></ul></li></ul><h2 id="프로세서간-통신"><a href="#프로세서간-통신" class="headerlink" title="프로세서간 통신"></a>프로세서간 통신</h2><ul><li><strong>주종모드</strong><ul><li>주프로세서: OS 기능수행</li><li>종프로세서: 필요에 의한 인터럽트 요청</li></ul></li><li><strong>분리 운영체제</strong><ul><li>모든 프로세서가 자신의 운영체제 보유</li><li>느슨한 결합 시스템에 적합</li></ul></li><li><strong>분산 운영체제</strong><ul><li>부동 운영체제: OS의 특정기능은 한 순간에 하나의 프로세서에만 작동</li><li>운영체제가 여러 프로세서에 분산</li></ul></li></ul><h2 id="프로세서간-동기화"><a href="#프로세서간-동기화" class="headerlink" title="프로세서간 동기화"></a>프로세서간 동기화</h2><ul><li>멀티프로세서의 명령어 집합에는 동작하는 <strong>프로세서와의 통신</strong> 과 <strong>동기화</strong> 를 구현하는 명령어를 포함한다.</li><li>동기화의 필요성<ul><li>처리될 작업들간 순서를 유지할 수 있다.</li><li>공통 변수에 대한 상호배제적 접근을 보장한다.</li></ul></li><li>동기화를 위해 가장 많이 활요되는 기법에 <code>이진 세마포</code>가 있다.</li></ul><h1 id="캐시의-일관성"><a href="#캐시의-일관성" class="headerlink" title="캐시의 일관성"></a>캐시의 일관성</h1><ul><li><strong>cache coherence</strong><ul><li>공유 메모리 멀티프로세서 시스템에서도 각 프로세서는 로컬 메모리를 운영한다.</li><li>정확한 메모리 동작을 위해 이 내용들이 모두 동일하게 유지되어야 한다.</li></ul></li><li>메모리에 쓰기동작시 메모리 갱신<ul><li>write-through: 쓰기동작 발생시 <code>cache 와 주기억장치 모두 갱신</code></li><li>write-back: <code>cache만 갱신</code>하고 메모리로 전달가능한 위치 표시</li></ul></li></ul><h2 id="캐시-일관성에-대한-헤결책"><a href="#캐시-일관성에-대한-헤결책" class="headerlink" title="캐시 일관성에 대한 헤결책"></a>캐시 일관성에 대한 헤결책</h2><ul><li>각 프로세서에 개별적 cache를 허용하지 않고 주기억장치에 <code>공용 cache 메모리를 둔다.</code><ul><li>평균접근시간을 증가시킨다.</li></ul></li><li><strong>캐시가능(cachable)</strong><ul><li>비 공유적, <code>읽기 전용 데이터</code>에 한해 cache 데이터에 저장하도록 한다.</li></ul></li><li><strong>스누피 캐시 제어기</strong><ul><li>기본적으로 버스에 부착된 cache에 대해 <code>버스-감시 기능을 유지</code> 하도록 설계된 하드웨어 장치이다.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;병렬처리 시스템, 멀티 프로세서의 상호연결 구조에는 어떤 것들이 있는지 알아본다.&lt;br&gt;&lt;code&gt;#parallel_system&lt;/code&gt; &lt;code&gt;#multi_processor&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>⛓ 컴퓨터구조-Memory System</title>
    <link href="http://yoursite.com/2021/06/09/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5/"/>
    <id>http://yoursite.com/2021/06/09/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5/</id>
    <published>2021-06-08T16:50:54.000Z</published>
    <updated>2021-06-16T00:47:39.620Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="메모리-계층"><a href="#메모리-계층" class="headerlink" title="메모리 계층"></a>메모리 계층</h1><h2 id="기억장치-MMU-buffer-AMU"><a href="#기억장치-MMU-buffer-AMU" class="headerlink" title="기억장치 (MMU, buffer, AMU)"></a>기억장치 (MMU, buffer, AMU)</h2><blockquote><p>CPU에 의하여 수행될 프로그램이 저장되는 곳.</p></blockquote><ul><li><strong>주기억 장치 (Main memory Unit)</strong><ul><li><strong>RAM</strong> Random Access Memory (마더보드에 장착)<ul><li>비교적 대용량이며 고속, <code>휘발성</code></li></ul></li><li><strong>ROM</strong> Read Only Memory<ul><li>주기억장치의 일종</li></ul></li></ul></li><li><strong>캐쉬 메모리</strong> Cache memory, buffer<ul><li>수행중인 프로그램의 <code>사용빈도가 높은 임시데이터</code>를 저장한다.</li></ul></li><li><strong>보조기억 장치 (Auxiliary memory Unit)</strong><ul><li>대용량 자료보관 가능, 저속</li><li>CPU 가 컨트롤 하지 못한다.</li><li>보조기억 내의 필요한 자료는 <code>주기억장치</code>로 <code>Loading</code> ;옮겨진다.</li><li><strong>SRAM</strong>: 캐시메모리, CPU와 1:1 정도의 속도</li><li><strong>DRAM</strong>: 일반적 주기억장치, 상대적으로 느리다. 7배정도 기다려야 메인메모리가 기다려준다.</li><li>Magnetic Tape, USB, SDcard : 파일 생성/삭제</li><li>Magnetic drum, disk : 백업 저장장치</li></ul></li></ul><blockquote><p>@ 메모리를 계층별로 나누는 이유?</p><ul><li>입출력의 경제성 때문이다.</li></ul></blockquote><h3 id="RAM-의-동작"><a href="#RAM-의-동작" class="headerlink" title="RAM 의 동작"></a>RAM 의 동작</h3><p>⏬ <strong>MAR</strong> Memory Address Register 로 신호가 들어오면,<br>⏬ <strong>주소 디코더</strong> 에 의해서 <code>번지</code> 지정<br>⏬ <code>정보</code>에 의헤서 읽기/쓰기 수행: <strong>CS(Clock Segnal)=0/1, RD(Read)=0/1. WR(Write)=0/1</strong><br>⏬ <strong>MBR</strong> Memory Buffer Register 에 의해 출력된다.</p><h3 id="보조기억-장치"><a href="#보조기억-장치" class="headerlink" title="보조기억 장치"></a>보조기억 장치</h3><blockquote><p>섹터, 트랙, 헤드, 실린더<br><code>접근시간</code>: 메모리내의 기억장소에 도달하여 응답을 받는데까지 요구되는 평균시간</p></blockquote><ul><li><strong>시크타임</strong>: read/write head가 지정된 기억장소에 <code>도달하기까지 소요 시간</code></li><li><strong>트랜스퍼 타임</strong>: 추출된 데이터를 장치내/외 필요한 곳으로 <code>전송하는 시간</code></li><li><strong>레코드</strong>: 데이터가 기록되는 <code>단위, 시크타임을 체크</code>하는 기준.</li><li><strong>전송률</strong>: 장치가 레코드의 시작점에 위치하고서부터 <code>전송 가능한 문자/워드 수</code></li></ul><hr><h1 id="효율적인-메모리-관리"><a href="#효율적인-메모리-관리" class="headerlink" title="효율적인 메모리 관리"></a>효율적인 메모리 관리</h1><h2 id="Associative-memory"><a href="#Associative-memory" class="headerlink" title="Associative memory"></a>Associative memory</h2><blockquote><p><code>내용</code>에 의해 접근하는 <code>메모리 장치</code></p><ul><li>메모리 장치? 자료의 저장과 접근을 용이하게 함</li><li>이제는, <strong>효율적 탐색(search)</strong> 이 필요 : <code>병렬 탐색</code>을 하기에 적합</li><li>외부인자와 <code>내용</code>을 비교할 수 있는 논리회로보유. ::RAM보다 비싸다.</li></ul></blockquote><ul><li>Argument register</li><li>Key register 역할<ul><li>인자워드의 특정 영역이나 키를 선택하기 위한 <code>마스크</code>를 제공한다.</li></ul></li></ul><h2 id="캐쉬-메모리-Cache-memory"><a href="#캐쉬-메모리-Cache-memory" class="headerlink" title="캐쉬 메모리 (Cache memory)"></a>캐쉬 메모리 (Cache memory)</h2><blockquote><p><strong>참조의 국한성</strong> : 프로그램 수행중 메모리 참조는 <code>국한된 영역</code>에서만 이루어진다.</p><ul><li>프로그램 루프, 서브루틴 빈번</li><li>순차적 프로그램 실행</li></ul></blockquote><ul><li><p><strong>캐쉬 메모리의 동작/성능</strong></p><ul><li>Cache를 체크한다.<ul><li>워드가 발견되면(<code>hit</code>) 읽고</li><li>없으면(<code>miss</code>) 주기억장치에 접근</li></ul></li><li>히트율</li></ul></li><li><p><strong>효율적인 메모리관리</strong></p><ul><li>associative mapping<ul><li>associative memory로 캐쉬를 만든다.</li><li>가장 빠르고 융통성 있다.</li><li><code>miss</code> 일 경우 <code>주기억장치</code>에서 해당자료를 찾아 옮긴다.</li><li>여유공간이 있다면 그공간에 저장하지만<ul><li>여유공간이 없다면, 주어진 알고리즘에 의해 해당 주소-데이터 쌍이 새로운 정보로 <code>대체</code>된다.</li></ul></li></ul></li></ul><p>  @@@@@@@@@@@@@ 사진 예시</p><ul><li>Direct mapping<ul><li>SRAM 에 만든다. 하나의 공간에 하나씩 저장한다.</li><li>동일한 인덱스를 보유한 워드가 반복접근시, <code>히트율 감소</code></li></ul></li><li>Set-associative mapping<ul><li>주어진 공간에 <code>병렬</code>로 여러개씩 저장한다.</li><li>복잡한 알고리즘을 필요로한다.</li></ul></li></ul></li></ul><hr><h1 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h1><h2 id="가상메모리-VS-캐쉬메모리"><a href="#가상메모리-VS-캐쉬메모리" class="headerlink" title="가상메모리 VS 캐쉬메모리"></a>가상메모리 VS 캐쉬메모리</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;메모리 시스템&lt;br&gt;&lt;code&gt;#&lt;/code&gt; &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>⛓ 컴퓨터구조-파이프라인</title>
    <link href="http://yoursite.com/2021/06/07/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"/>
    <id>http://yoursite.com/2021/06/07/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/</id>
    <published>2021-06-07T01:50:54.000Z</published>
    <updated>2021-06-16T00:47:39.620Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="병렬처리"><a href="#병렬처리" class="headerlink" title="병렬처리"></a>병렬처리</h1><blockquote><p>컴퓨터 시스템의 계산 속도의 향상을 목적으로 동시 데이터 처리기능을 제공하는 광범위한 개념의 기술.</p><ul><li>다중 기능장치를 가진 레지스터</li><li>실행 장치를 동시에 동작되는 8개의 기능장치로 나눔</li></ul></blockquote><h2 id="병렬처리-구조-분류방법-by-M-J-Flynn"><a href="#병렬처리-구조-분류방법-by-M-J-Flynn" class="headerlink" title="병렬처리 구조 분류방법 by M.J Flynn"></a>병렬처리 구조 분류방법 by M.J Flynn</h2><ul><li>SISD : 단일 명령어, 단일 데이터</li><li>SIMD : 단일 명령어, 다중 데이터</li><li>MISD : 다중 명령어, 단일 데이터</li><li>MIMD : - 다중 명령어, 다중 데이터<ul><li>여러 프로그램 동시수행 능력</li><li>대부분의 다중 프로세서와 다중 컴퓨터 시스템</li></ul></li></ul><hr><h1 id="파이프-라인"><a href="#파이프-라인" class="headerlink" title="파이프 라인"></a>파이프 라인</h1><h2 id="파이프라인-구조-성능"><a href="#파이프라인-구조-성능" class="headerlink" title="파이프라인 구조 성능"></a>파이프라인 구조 성능</h2><ul><li>파이프 라인의 동작은 공간, 시간표에 의해 설명되는데, 이것은 시간에 대한 함수로서 <strong>세그먼트의 사용현황</strong> 을 나타낸다.</li><li>동일한 복잡도의 <code>부연산</code>들로 이루어지는 연산동작도 구현가능하다.</li><li>매번 다른 집합을 동일한 태스크에 적용해, <code>반복적인 일에 효과적</code>이다.</li><li><strong>그러나,</strong> 각 레지스터 Ri 에 분리되는 작업들의 업무강도가 비슷해야 한다. 업무강도가 가장 높은 작업에 비중을 둘 수 밖에 없어서 <code>유휴시간</code>이 생긴다.</li></ul><blockquote><p>파이프라인의 <code>이론적 최대속도 증가율</code>은 <code>세그먼트 수와 같다.</code></p><ul><li>그렇다면, 세그먼트가 많을 수록 효과적일까?</li></ul></blockquote><h2 id="클럭-사이클시간"><a href="#클럭-사이클시간" class="headerlink" title="클럭 사이클시간"></a>클럭 사이클시간</h2><img width="630" alt="파이프라인1" src="https://user-images.githubusercontent.com/28856435/121041772-0251ef00-c7ee-11eb-90d2-5493c5ee541b.PNG"><br><blockquote><p>위와 같은 파이프라인의 클럭 사이클시간을 구하는 공식은 아래와 같다.<br>k + (n-1)<br>(= k개의 세그먼트 파이프라인에서 n개의 데스크를 수행)<br>즉 위의 식에 대입하면 4 + (6-1)= 9<br><code>:: 9개의 클럭사이클을 수행한다.</code></p></blockquote><h2 id="파이프라인-구현"><a href="#파이프라인-구현" class="headerlink" title="파이프라인 구현"></a>파이프라인 구현</h2><ul><li><p>하나의 프로세스를 서로 다른 기능을 가진 서브프로세스로 나누어 각 프로세스가 <code>동시에</code> 서로 다른 데이터를 취급하도록 하는 기법</p></li><li><p>각 세그먼트에서 수행된 연산결과는 다음 세그먼트로 연속적으로 넘어간다.</p><ul><li>마지막 세그먼트를 통과하게되면 최종 연산결과를 얻는다.</li><li>하나의 프로세스를 다양한 연산으로 중복시킬 수 있는 근간은 <code>세그먼트</code>마다의 <code>레지스터</code>이다.</li></ul></li><li><p>곱셈과 덧셈이 섞인 다항식 연산<br><strong>Ai X Bi + Ci (i= 1,2,3 …7)</strong></p></li><li><p>R1 ~ R5 레지스터와 조합논리회로 (Adder, Multiplier) 구성</p></li></ul><img width="693" alt="파이프라인2" src="https://user-images.githubusercontent.com/28856435/121041793-08e06680-c7ee-11eb-9c19-daec02459cc3.PNG"><br><ul><li>수도코드<table><thead><tr><th>수도코드</th><th>설명</th></tr></thead><tbody><tr><td>R1 &lt;- Ai, R2 &lt;- Bi</td><td>Ai와 Bi의 입력</td></tr><tr><td>R1 &lt;- R1 X R2, R4 &lt;- Ci</td><td>곱셈과 Ci의 입력</td></tr><tr><td>R1 &lt;- R3 + R4</td><td>곱셈 결과와 Ci의 덧셈</td></tr></tbody></table></li></ul><br><br><ul><li><strong>세번의 clock pulse이후부터 R5의 첫번째 결과획득</strong> 및 파이프 <strong>라인상에서 데이터 이동시작</strong></li></ul><img width="533" alt="파이프라인3" src="https://user-images.githubusercontent.com/28856435/121213896-9fc62500-c8b9-11eb-8eaa-582963e0c47c.PNG"><h2 id="파이프라인-데이터-처리"><a href="#파이프라인-데이터-처리" class="headerlink" title="파이프라인 데이터 처리"></a>파이프라인 데이터 처리</h2><blockquote><ul><li>예시<ul><li>각 세그먼트에서 부연산 수행 소요시간: t<sub>p</sub>= <code>20ns</code></li><li>파이프 라인은 <code>k=4</code> 세그먼트</li><li>태스크의 수: <code>n=100</code></li></ul></li></ul></blockquote><p><strong>파이프라인 구조를 활용한 경우 총 소요시간</strong></p><ul><li>(k+ n-1)t<sub>p</sub> = (4+100-1) X 20 = 2060ns</li></ul><p><strong>비파이프라인 시스템</strong></p><ul><li>각 태스크 완료시간: t<sub>n</sub>= kt<sub>p</sub> = 4 X 20 = 80ns</li><li>전체 태스크 완료시간: nkt<sub>p</sub> = 100 X 80 = 8000ns</li></ul><p><strong>:: 속도 증가율을 확인할 수 있다.</strong></p><ul><li>8000/2060 = 3.88 ~= 4</li></ul><hr><h1 id="현실적인-파이프라인"><a href="#현실적인-파이프라인" class="headerlink" title="현실적인 파이프라인"></a>현실적인 파이프라인</h1><h2 id="파이프라인-VS-병렬-다중기능-장치"><a href="#파이프라인-VS-병렬-다중기능-장치" class="headerlink" title="파이프라인 VS 병렬 다중기능 장치"></a>파이프라인 VS 병렬 다중기능 장치</h2><ul><li><strong>파이프라인</strong><ul><li>실제 파이프라인 구조는 <strong>이론적인 최대속도 구현 불가</strong><ul><li>각 세그먼트들이 <code>부연산을 수행하는 시간</code>이 다르기 때문이다.</li></ul></li><li><code>최대 전파시간</code>을 갖는 세그먼트의 지연시간에 맞춰야한다.</li></ul></li><li><strong>병렬 다중기능 장치</strong><ul><li>그래서, 병렬적인 다중기능장치를 고려 할 수 있다.</li><li>순차적 처리가 아닌, 데이터를 <code>동시입력</code> 받아 태스크를 <code>동시에 처리</code>한다. (SIMD구조)</li></ul></li></ul><h2 id="파이프라인-구조"><a href="#파이프라인-구조" class="headerlink" title="파이프라인 구조"></a>파이프라인 구조</h2><h3 id="산술-파이프라인"><a href="#산술-파이프라인" class="headerlink" title="산술 파이프라인"></a>산술 파이프라인</h3><ul><li><p>산술 연산들을 <code>부연산으로 나누어</code> 파이프라인의 <code>세그먼트</code>에서 수행</p><ul><li>불필요한 작업을 줄일 수 있다.</li><li>eg. 부동 소수점 연산, 과학계산 등</li></ul></li><li><p>부동 소수점 덧셈/뺄셈을 위한 파이프라인</p><ul><li>초기값이 아래와 같은 X, Y 의 ADD 연산을 산술파이프라인을 사용한다면, 표와같이 나타난다.<br>X = 0.2345 X 10<sub>3</sub><br>Y = 0.1200 X 10<sub>2</sub></li></ul></li></ul><table><thead><tr><th>segment</th><th>result</th></tr></thead><tbody><tr><td>Segment 1</td><td>값이 큰 지수에 맞춘다:3</td></tr><tr><td>Segment 2</td><td><strong>X</strong> = 0.2345 X 10<sub>3</sub> <strong>Y</strong> = 0.0120 X 10<sub>3</sub></td></tr><tr><td>Segment 1</td><td>Z = 0.2465<sub>3</sub></td></tr><tr><td>Segment 1</td><td>정규화(항상 0으로 표현): <strong>Z</strong> = 0.02465<sub>4</sub></td></tr></tbody></table><h3 id="명령어-파이프라인"><a href="#명령어-파이프라인" class="headerlink" title="명령어 파이프라인"></a>명령어 파이프라인</h3><blockquote><p>명령어 사이클의 fetch, 디코드, 실행단계를 <code>중첩</code>사켜 명령어 흐름에 <code>동시에</code> 동작</p></blockquote><ul><li><p><strong>취약점</strong> </p><ul><li>하지만 현재 파이프라인은 <code>모두 비워져</code> 있어야한다.</li><li>분기명령(<code>Branch</code>) 이후의 명령어는 무시된다.</li><li>세그먼트 수행시간이 서로다르다.</li></ul></li><li><p><strong>효율적인 명령어 파이프라인?</strong></p><ul><li>명령어 fetch장치<ul><li><code>FIFO</code> 에 의한 큐로 구성하여 queuing 기법으로, 메모리를 참조 하도록 하여 접근시간을 줄인다.</li></ul></li><li>두개 이상의 세그먼트에 의해 주소참조 충돌이 일어날 수 있다.<ul><li>우선권을 주는 로직 필요</li></ul></li></ul></li></ul><hr><h1 id="파이프라인-CPU"><a href="#파이프라인-CPU" class="headerlink" title="파이프라인 CPU"></a>파이프라인 CPU</h1><h2 id="파이프라인-분기예측"><a href="#파이프라인-분기예측" class="headerlink" title="파이프라인 분기예측"></a>파이프라인 분기예측</h2><ul><li><p>명령어 파이프라인이 비정상적인 동작을 하는 요인</p><ul><li><strong>1) 자원충돌</strong> <ul><li>명령어 메모리와 데이터 메모리를 <code>분리</code>하여 해결</li></ul></li><li><strong>2) 데이터 의존성</strong>: 아직 준비되지 않은 데이터를 기다림<ul><li><em>하드웨어 인터락</em><ul><li><code>피연산자</code>가 먼저 앞선 명령어의 목적지와 일치하는지 검사</li><li>피연산자가 준비되지 않았다면 충돌을 충분히 피할만큼의 <code>클럭사이클</code>을 둔다.</li></ul></li><li><em>오퍼랜드 포워딩</em> : 충돌시 특별한 <code>통로</code>를 통해서 직접 세그먼트에 전달.</li></ul></li><li><strong>3) 주소 의존성</strong>: 간접모드를 사용하는 명령어는 주소를 참조할 경우 메모리로부터 바로 fetch 되지 못한다.</li><li><strong>4) 분기 곤란</strong>: 분기 명령어같이 PC값을 바꾸려는 명령어에 의해 발생</li></ul></li><li><p>분기 명령어 처리</p><ul><li>조건,무조건 분기는 파이프라인의 정상적인 프로그램 순서를 바꿔버린다.<ul><li>컴퓨터 성능 저하</li></ul></li><li><em>분기 목표 버퍼 (branch target buffer, BTB)</em><ul><li>fetch 세그먼트에 속해있는 associative memory(주소가 아닌 내용에 의해 검색가능한 장치)</li><li>일종의 <code>레지스터</code>로, 이전에 실행된 <code>분기 명령어와 목표 명령어를 저장</code>하여 활용한다. (loop buffer)</li></ul></li></ul></li></ul><h2 id="RISC-Processor"><a href="#RISC-Processor" class="headerlink" title="RISC Processor"></a>RISC Processor</h2><blockquote><p>실행 명령어 수는 증가, 작업 처리시간 감소 가능<br>명령어당 실행 클록수와 클록주기를 파이프라인 구조로 감소 가능</p></blockquote><ul><li><strong>RISC Processor 구조적 특징</strong><ul><li>명령어 1사이클 실행을 위한 <code>온칩 캐쉬</code></li><li>간단한 명령코드, 주소지정 모드</li><li>신속한 오퍼랜드 참조/문맥 전환을 위한 레지스터 집합</li></ul></li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><blockquote><p>파이프라인의 <code>이론적 최대속도 증가율</code>은 <code>세그먼트 수와 같다.</code></p><ul><li>그렇다면 세그먼트가 많을 수록 효과적일까?<br><strong>실제 상황은 그렇지 않다.</strong></li></ul></blockquote><ul><li>모든 명령어는 <code>동일한 처리 과정</code>으로 처리되어야 한다.</li><li>파이프라인을 구성하는 각 단계의 <code>처리시간이 일정</code>해야한다.</li><li>모든 명령어는 <code>순차적</code>으로 실행되어야 한다.</li><li>각 명령어 사이에는 <code>의존성이 없어야 </code>한다.</li><li>명령어들 처리시 공유자원의 <code>충돌이 없어야</code> 한다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;파이프라인은 무조건 성능이 좋을까?&lt;br&gt;세그먼트 수가 많을 수록 효과적인걸까?&lt;br&gt;&lt;code&gt;#segment&lt;/code&gt; &lt;code&gt;#RISC_Processor&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>🖨 컴퓨터구조-입출력과 프로그래밍</title>
    <link href="http://yoursite.com/2021/06/05/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0__%EC%9E%85%EC%B6%9C%EB%A0%A5/"/>
    <id>http://yoursite.com/2021/06/05/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0__%EC%9E%85%EC%B6%9C%EB%A0%A5/</id>
    <published>2021-06-05T01:50:54.000Z</published>
    <updated>2021-06-08T04:48:49.605Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="입출력-구성"><a href="#입출력-구성" class="headerlink" title="입출력 구성"></a>입출력 구성</h1><blockquote><ul><li>컴퓨터는 사용자와 통신하기 위해, 외부장치를 사용한다.</li><li>즉 메모리로 데이터와 명령어를 읽어들일 입력장치와 계산결과를 사용자에게 출력장치를 통해 표시해주어야 한다.</li></ul></blockquote><h2 id="입출력-과정"><a href="#입출력-과정" class="headerlink" title="입출력 과정"></a>입출력 과정</h2><ul><li>OUTR, AC, INPR, FGI는 모두 <code>병렬로 연결</code>되어 있다.</li></ul><ol><li><strong>Keyboard</strong> 입력이 들어가면</li><li><strong>Transmitter Interface</strong>  를 통해서 </li><li><strong>INPR</strong> 에 시프트되어 들어간다.<ul><li>flag bit<ul><li><strong>FGI</strong>(입력용 제어 플립플롭)<ul><li><code>0</code>: Key in 8bit code. 8비트가 채워지면  FGI는 1로 변경된다.</li><li><code>1</code>: INPR 값은 바꿀 수 없다. 이후 플래그가 1이면 AC로 <code>병렬 전송</code>을 하고 FGI를 클리어 시킨다. 이후 새로운 정보가 INPR에 들어갈 수 있다.</li></ul></li></ul></li></ul></li></ol><ul><li><strong>AC(Accumulator)</strong> : 명령어의 출발지이자 Destination(결과저장) 이다. FGI의 플래그가 1일경우, INPR 로부터 병렬전송을 받는다.</li><li><strong>OUTR</strong><ul><li>flag bit<ul><li><strong>FGO</strong>(출력용 제어 플립플롭)<ul><li><code>0</code>: 출력 장치가 사용중</li><li><code>1</code>: OUTR 가 AC 값을 reciever를 통해 출력</li></ul></li></ul></li></ul></li></ul><h2 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h2><h3 id="IEN-Interrupt-Enable-flip-flop"><a href="#IEN-Interrupt-Enable-flip-flop" class="headerlink" title="IEN : Interrupt Enable flip-flop"></a>IEN : <code>Interrupt Enable flip-flop</code></h3><ul><li>프로그램 제어전송 대신에 <code>외부장치의 전송작업이 준비되었을 때 컴퓨터에 알리는</code> 방법에 활용되는 플리플롭이다.</li><li>프로그램 실행 도중 플래그를 체크하지 않고, 플래그(=1)가 들어오면 실행중이던 작업을 중단하고 우선순위가 높은 작업부터 처리하게 된다.</li><li>IEN 는 인터럽트를 가능하게 해준다.</li></ul><h3 id="인터럽트-수행과정"><a href="#인터럽트-수행과정" class="headerlink" title="인터럽트 수행과정"></a>인터럽트 수행과정</h3><ul><li>인터럽트 시에는 ?</li><li>PC &lt;- 1</li><li>IEN &lt;- 0</li><li>R &lt;- 0</li></ul><p><img src="https://user-images.githubusercontent.com/28856435/120877206-31027680-c5f0-11eb-82c1-fa8615579088.jpg" alt="interrupt"></p><br><h3 id="컴퓨터-실행속도-VS-입출력장치-속도"><a href="#컴퓨터-실행속도-VS-입출력장치-속도" class="headerlink" title="컴퓨터 실행속도 VS 입출력장치 속도"></a>컴퓨터 실행속도 VS 입출력장치 속도</h3><blockquote><p><strong>QESTION. 입출력 장치는 작업 수행시 몇번의 플래그 체크를 수행할까?</strong></p><ul><li>컴퓨터의 프로세스 처리속도는 <code>10μs fetch and execute cycle time</code>(하나의 instruction을 처리하는데 10μs가 걸림) 라 하고.</li><li>입출력장치의 처리속도는 10문자/초 가 걸리며, 1문자당 0.1초= 100,000μs 라 한다.<br><code>(1sec = 1000ms = 1000,000μs 이다.)</code></li><li><strong>결론</strong><br> :: 플래그 체크 횟수는 1문자당 입력/출력이 함께 일어난다고 생각하면, 하나의 명령을 처리할 때 100,000μs/10μs = 10,000 번 체크를 하게된다.<br> :: 입력과 출력 각 <code>5000번의 체크</code>가 일어나게 된다.</li></ul></blockquote><hr><h1 id="프로그램의-종류"><a href="#프로그램의-종류" class="headerlink" title="프로그램의 종류"></a>프로그램의 종류</h1><ul><li><p>소프트웨어는 <code>시스템 소프트웨어</code>와 <code>응용 프로그램</code>으로 나눠져있다.</p></li><li><p><strong>시스템 소프트웨어</strong></p><ul><li>운영체제<ul><li>Job 관리</li><li>스케줄 관리</li><li>네트워크 관리</li><li>입출력 관리</li></ul></li><li>언어번역 프로그램<ul><li>컴파일러</li><li>어셈블러</li><li>인터프리터</li></ul></li><li>유틸리티 프로그램<ul><li>DBMS</li><li>VCCINE</li><li>드라이버 관리 프로그램</li></ul></li></ul></li><li><p><strong>응용 소프트웨어</strong></p><ul><li>Application/ App</li><li>Mobile App</li></ul></li></ul><h2 id="프로그램-처리과정"><a href="#프로그램-처리과정" class="headerlink" title="프로그램 처리과정"></a>프로그램 처리과정</h2><blockquote><p>고급언어 프로그램 - 어셈블리 프로그램 - 기계어 프로그램</p></blockquote><ul><li><p><strong>기계어</strong>(처리중심)</p><ul><li>1100 0001 1010 0000</li></ul></li><li><p><strong>어셈블리 언어</strong>(처리중심): 모든 컴퓨터는 각각의 어셈블리 언어를 가지고 있으며 이 규틱은 컴퓨터 제조업체로부터 출판되어진다.</p><ul><li> 니모닉(mnemonic) : 기억하기 용이한 형태로 정해진 기호. (ADD, LDA …)</li><li>라벨필드: 기호주소나 빈칸</li><li>명령어 필드: 기계어나 수도명령어 기술<ul><li>메모리 참조 명령어</li><li>레지스터 참조/입출력 명령어</li><li>sudo 명령어</li></ul></li></ul></li><li><p><strong>고급언어</strong>(문제중심)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    a= <span class="number">5</span>, b=<span class="number">-2</span>;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b = %d&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="프로그래밍-구현"><a href="#프로그래밍-구현" class="headerlink" title="프로그래밍 구현"></a>프로그래밍 구현</h1><h2 id="소프트웨어-개발-패러다임"><a href="#소프트웨어-개발-패러다임" class="headerlink" title="소프트웨어 개발 패러다임"></a>소프트웨어 개발 패러다임</h2><p>⬇️ 구조적 기법<br>⬇️ 객체지향 기법: 객체지향<br>⬇️ 컴포넌트 기법: 외부와 Interface를 통해 동작구현. 시스템의 단순성.<br>⬇️ 분산객체 프레임워크: 이종 분산환경에서 여러종류의 Application을 쉽게 통합</p><h2 id="컴퓨터-네트워크-환경"><a href="#컴퓨터-네트워크-환경" class="headerlink" title="컴퓨터 네트워크 환경"></a>컴퓨터 네트워크 환경</h2><ul><li><p>Wireshark 패킷 분석툴</p><ul><li>Explorer가 운영체제의 한 축을 담당하게 된 순간부터 컴퓨터는 이미 통신기계로 분류되고 있다.</li><li>통신기계로서의 hexadecimal 표현</li><li>NOS (New technology Operating Systerm)</li></ul>  <img width="837" alt="wireshark" src="https://user-images.githubusercontent.com/28856435/120879375-d96b0780-c5fd-11eb-9158-1985d5af3fb1.png">  <br></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;프로그래밍 입출력은 어떻게 수행되는걸까?&lt;br&gt;&lt;code&gt;#FGI&lt;/code&gt; &lt;code&gt;#FGO&lt;/code&gt; &lt;code&gt;#IEN&lt;/code&gt; &lt;code&gt;#Flip-Flop&lt;/code&gt; &lt;code&gt;#프로그램_언어_패러다임&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>📱 CPU구조_레지스터</title>
    <link href="http://yoursite.com/2021/06/03/CPU%EA%B5%AC%EC%A1%B0-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/"/>
    <id>http://yoursite.com/2021/06/03/CPU%EA%B5%AC%EC%A1%B0-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/</id>
    <published>2021-06-02T15:35:59.000Z</published>
    <updated>2021-06-08T04:34:02.853Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="CPU-구성요소"><a href="#CPU-구성요소" class="headerlink" title="CPU 구성요소"></a>CPU 구성요소</h1><blockquote><p>중앙처리장치 = CPU(Central Processing Unit)</p><ul><li>레지스터 세트 (Register set) : 명령어를 실행시 필요한 데이터를 보관</li><li>산술논리장치 (ALU; Arithmetic Logic Unit) : 명령어를 실행하기 위한 <code>마이크로 연산</code> 수행</li><li>마이크로 연산 종류- shift, count, clear, load</li><li>제어장치 (Contol Unit) : RS 간의 정보전송 감시, ALU에 수행할 동작 지시. ID(명령어해독기) 로부터 보내진 신호를 기준으로 명령어 실행</li></ul></blockquote><h2 id="각-레지스터들의-기능"><a href="#각-레지스터들의-기능" class="headerlink" title="각 레지스터들의 기능"></a>각 레지스터들의 기능</h2><ul><li><code>MAR</code> Memory Address Register : 메모리의 <code>상태</code></li><li><code>MBR</code> Memory Buffer Register : 메모리 <code>임시저장공간</code></li><li><code>IR</code> Instruction Register 명령어 레지스터 : 계수기가 지정하는 주소에 기억된 <code>명령어를 해독</code>하기 위해 <code>임시 기억</code><ul><li><code>ID</code> Instruction decoder 명령어 해독기: IR에 들어있는 명령코드의 해석</li></ul></li><li><code>PC</code> (Program Counter) 프로그램 계수기 : <code>다음 수행될 명령어</code>가 들어있는 주소(주기억장치)를 기억.</li><li><code>SR</code> Status Register 상태레지스터: CPU의 상태를 나타내는 특수목적의 레지스터. flag 정보를 저장한다.<ul><li>연산결과 상태</li><li>0(Z; Zero), 부호(S; sign), 오버플로우(V; overflow), 캐리(C; carry), 인터럽트(I; interrupt)</li></ul></li><li><code>WR</code> Work Register 작업레지스터: <code>산술논리연산</code>을 실행할 수 있게 자료 및 결과 저장. (GPR 은 ALU를 사용하지 않는다.)</li><li><code>GR</code> General Purpose Register 범용 레지스터 : 작업 레지스터에서 <code>데이터가 용이하게 처리</code>되도록 임시자료 저장</li></ul><p><strong>ADD 명령의 실행예</strong></p><table><thead><tr><th>seq</th><th>stage</th><th>flow</th><th>function</th></tr></thead><tbody><tr><td>1</td><td>FETCH</td><td>MAR &lt;- PC</td><td>다음 실행할 명령어의 주소를 <code>MAR</code>로 이동</td></tr><tr><td>2</td><td>FETCH</td><td>MBR &lt;- 기억장치[MAR]</td><td>MAR 이 지정하는 주소의 내용을 <code>MSR</code>로 이동</td></tr><tr><td>3</td><td>FETCH</td><td>IR &lt;- MBR</td><td>MBR의 내용을 <code>IR 명령어 레지스터</code>로 이동</td></tr><tr><td></td><td></td><td><em>&lt;어떤 명령인가 ?&gt;</em></td><td></td></tr><tr><td>4</td><td>EXECUTE</td><td>MAR &lt;- IR[OPRD]</td><td>명령어 레지스터의 주소 부분을 <code>MAR</code>로 이동</td></tr><tr><td>5</td><td>EXECUTE</td><td>MBR &lt;- 기억장치[MAR]</td><td>ADD 할 내용을 <code>MBR</code>로 이동</td></tr><tr><td>6</td><td>EXECUTE</td><td>WR &lt;- GR[IR]</td><td>IR에서 지정하는 GR의 내용을 <code>WR</code>로 이동</td></tr><tr><td>7</td><td>EXECUTE</td><td>WR &lt;- WR + MBR</td><td><code>ADD 작업</code>: data(WR) + data(MBR)</td></tr><tr><td>8</td><td>EXECUTE</td><td>GR[IR] &lt;- WR</td><td>WR의 결과를 <code>GR</code>로 이동</td></tr><tr><td>9</td><td>EXECUTE</td><td>PC &lt;- PC+1</td><td>다음 명령어 수행 위해 <code>PC값 증가</code></td></tr></tbody></table><h2 id="CPU-내부-구조"><a href="#CPU-내부-구조" class="headerlink" title="CPU 내부 구조"></a>CPU 내부 구조</h2><blockquote><p>명령어 구성 및 실행</p></blockquote><ul><li>레지스터 간의 전송문으로 나타나는 컴퓨터의 각 연산이 어떻게 동작하는가?</li><li><strong>컴퓨터의 구조</strong>: 내부 레지스터, 타이밍, 제어구조 명령어 집합에 의해 정의</li></ul><h3 id="레지스터-전송-언어"><a href="#레지스터-전송-언어" class="headerlink" title="레지스터 전송 언어"></a>레지스터 전송 언어</h3><ul><li><code>마이크로 연산</code> : 레지스터에 저장된 데이터 조작을 위해 실해되는 동작</li><li>하나의 <code>Clock Pulse</code> 클럭 펄스 내에서 실행.<ul><li>shift, count, clear, road etc.</li></ul></li></ul><h3 id="레지스터-전송"><a href="#레지스터-전송" class="headerlink" title="레지스터 전송"></a>레지스터 전송</h3><ul><li>레지스터 전송의 기본기호</li></ul><img width="473" alt="레지스터_전송_기호" src="https://user-images.githubusercontent.com/28856435/120518845-f7bde100-c40c-11eb-9643-9e9cac53d0dc.PNG"><br><ul><li>R1 -&gt; R2 : 치환연산자를 이용한 레지스터간 정보 전송</li><li><em>P: R1 -&gt; R2</em><ul><li><code>if(P=1) then(R1-&gt;R2)</code></li><li><code>소스</code>레지스터로부터 <code>목적</code>레지스터까지의 연결.</li><li>목적 레지스터애는 조건부 처리 가능한 <code>병렬로드</code> 기능이 있어야한다.</li></ul></li></ul><blockquote><p>레지스터 전송을 나타내는 각 문장들은 그 전송을 수행하는 <code>하드웨어가 구성되어 있음</code>을 의미한다.</p></blockquote><h3 id="CPU-디자인"><a href="#CPU-디자인" class="headerlink" title="CPU 디자인"></a>CPU 디자인</h3><ul><li>다양한 <code>디바이스들 간</code> 상호 연결<ul><li><code>직접연결</code>: 연결 복잡도가 장치수의 <code>제곱</code>에 비례</li><li><code>버스연결</code><ul><li><code>공용선</code>에 의한 연결 -&gt; MUX (멀티플렉서) 를 이용한다.</li><li><code>디코더</code> decoder 이용 -&gt; 코드화된 데이터로부터 정보를 찾아내는 논리회로</li><li>가성비가 높다.</li><li>관리를 위한 다양한 방식이 존재한다.</li></ul></li></ul></li><li>자료구조<ul><li>스택(stack): 주 함수에서 <code>서브루틴</code>을 호출할 경우(콜스택)</li><li>큐(queue): 버퍼(buffer) 등과 같이 <code>순차적 처리</code>를 요하는 자료의 대기시에 활용</li><li>데크(deque): 스택과 큐의 동작을 동시에 가능. (*이건 잘 모르겠다..)<ul><li>입력제한 데크: scroll</li><li>출력제한 데크: shelf</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CPU 구성과 디자인 그리고 레지스터들의 종류와 기능을 알아본다.&lt;br&gt;&lt;code&gt;#MBR&lt;/code&gt; &lt;code&gt;#register&lt;/code&gt; &lt;code&gt;#마이크로_연산&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>ㅊ 컴퓨터구조-데이터의 종류, 논리회로</title>
    <link href="http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%EC%A2%85%EB%A5%98/"/>
    <id>http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%EC%A2%85%EB%A5%98/</id>
    <published>2021-06-01T14:50:54.000Z</published>
    <updated>2021-07-19T00:39:14.206Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="데이터의-종류"><a href="#데이터의-종류" class="headerlink" title="데이터의 종류"></a>데이터의 종류</h1><h2 id="진법-amp-진법변환"><a href="#진법-amp-진법변환" class="headerlink" title="진법 &amp; 진법변환"></a>진법 &amp; 진법변환</h2><blockquote><ul><li>1nibble = 4bit</li><li>1byte = 8bit</li><li>1btye = 1문자(character)</li><li>1워드: 특정 CPU에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수.<ul><li> HalfWord=2byte, FullWord=4byte, DoubleWord=8byte</li></ul></li></ul></blockquote><ul><li><p>8/16진수와 2진수</p><ul><li>8진수: 2진수를 3자리씩 묶어서 표현한다.<ul><li>111101111(2) -&gt; 757(8)</li></ul></li><li>16진수: 2진수를 4자리씩 묶어서 표현한다.<ul><li>111101111(2) -&gt; 1EF(16)</li></ul></li></ul></li><li><p>분수의 변환</p><ul><li>0.75<ul><li>0.75 x 2 = <code>1</code>.5</li><li>1.5 x 2 = <code>1</code>.0</li></ul></li><li>0.75 =&gt; 0.<code>11</code></li></ul></li></ul><h2 id="보수"><a href="#보수" class="headerlink" title="보수"></a>보수</h2><ul><li>양/음수로 활용</li><li>연산에 활용</li><li>1의 보수: <code>최대값</code>을 형성하는데 서로 보완 관계에 있는 두 수 사이의 관계를 1의 보수라고 한다.<ul><li>0111(2) 의 1의 보수 = 1000(2)</li></ul></li><li>2의 보수: MODULUS(<code>최대 표현자리 수</code>)형성하는데 서로 보완관계에 있는 두수 사이읙 관계<ul><li>1의 보수 1000(2)에 1을 더한다.</li><li>0111(2) 의 2의 보수 = 1001(2)</li></ul></li></ul><h3 id="정수-표현"><a href="#정수-표현" class="headerlink" title="정수 표현"></a>정수 표현</h3><ul><li>고정 소수점, FIXED POINT NUMBER</li><li>10진수형 정수표현<ul><li><code>Unpacked decimal</code>: 1byte 에 10진수 <code>1개 자리</code>만 표현.</li><li>zoned decimal 이라고 하며,<ul><li>연산에는 이용될 수 없지만, 10진수 데이터를 <code>입출력용</code>.</li><li>쉽게 입력하기 위해서 unpacked형으로 변환시킨것을 packed로 변환.</li></ul></li><li><code>Packed decimal</code>: 1byte 에 <code>2개 자리</code>의 10진수를 표현. (<code>BCD code</code>이용)<ul><li>마지막 4개의 비트는 부호표현</li><li><code>연산</code>에 이용하며, 입출력은 불가하다.</li></ul></li></ul></li></ul><h3 id="실수표현-부동소수점-Floating-ponint"><a href="#실수표현-부동소수점-Floating-ponint" class="headerlink" title="실수표현 (부동소수점, Floating-ponint)"></a>실수표현 (부동소수점, Floating-ponint)</h3><ul><li>과학적 표기의 지수를 사용하여 <code>소수점의 위치를 이동</code>시킬 수 있는 표현 방법이다.</li></ul><h3 id="디지털-코드"><a href="#디지털-코드" class="headerlink" title="디지털 코드"></a>디지털 코드</h3><ul><li>BCD 코드 (Binary Coded Decimal Code, 2진화 10진 코드)</li></ul><br><img width="505" alt="BCD_code" src="https://user-images.githubusercontent.com/28856435/120340687-38482c80-c331-11eb-8b65-234e6c092496.png"><br><ul><li>3초화 코드</li><li>오류 검출 코드<ul><li>패리티 비트</li><li>해밍 비트</li></ul></li></ul><hr><h1 id="논리-게이트-Logical-gate"><a href="#논리-게이트-Logical-gate" class="headerlink" title="논리 게이트(Logical gate)"></a>논리 게이트(Logical gate)</h1><ul><li>논리 연산을 수행하는 전자소자로서, 주어진 입력 변수값에 대하여 정해진 논리 함수를 수행한다. 그 함수의 경과와 동일한 결과값을 출력하는 하드웨어이다.</li></ul><h2 id="스위칭-이론"><a href="#스위칭-이론" class="headerlink" title="스위칭 이론"></a>스위칭 이론</h2><ul><li>논리곱(AND)<ul><li>A B 가 모두 1일 때만 1이다.</li></ul></li><li>논리합(OR)<ul><li>A B 증 하나만 1이라면, 1이다.</li></ul></li><li>논리부정(NOT)<ul><li>A가 0일 때, B는 1.</li><li>A가 1일 때, B는 0.</li></ul></li><li>배타적 논리합(exclusive OR = XOR)<ul><li>A B 값이 같을 때는 0, 다를때는 1이다.</li></ul></li></ul><h2 id="반가산기-Half-addr"><a href="#반가산기-Half-addr" class="headerlink" title="반가산기(Half addr)"></a>반가산기(Half addr)</h2><ul><li>1bit 덧셈의 구현</li><li>a+b=S 기본연산을 구현하고자 하는경우</li></ul><hr><h1 id="부울대수-Boolean-Algebra"><a href="#부울대수-Boolean-Algebra" class="headerlink" title="부울대수(Boolean Algebra)"></a>부울대수(Boolean Algebra)</h1><ul><li>참과 거짓을 판별할 수 있는 논리적 명제를 수학적 표현으로.</li><li>논리회로의 형태와 구조를 기술하는데 필요한 수학적인 이론.</li><li>변수들의 진리표 관계를 대수식으로 표현하기에 용이.</li><li>동일한 성능을 갖는 간단한 회로를 만들기 편리.</li></ul><h2 id="부울대수-법칙"><a href="#부울대수-법칙" class="headerlink" title="부울대수 법칙"></a>부울대수 법칙</h2><ul><li>기본법칙<ul><li>A<em>B = B</em>A</li><li>A+B = B+A</li></ul></li><li>결합법칙<ul><li>A*(B<em>C) = (A</em>B)*C</li><li>(A+B)+C = A+(B+C)</li></ul></li><li>분배법칙<ul><li>A*(B+C) = AB + AC</li></ul></li><li>드모르간의 법칙 (DeMorgan’s Theorem)<ul><li>A+B 부정 = A부정 * B부정</li><li>(A*B)부정 = A부정 + B부정 </li></ul></li></ul><br><img width="369" alt="드모르간" src="https://user-images.githubusercontent.com/28856435/120344270-6844ff00-c334-11eb-8a49-12b1b1164c27.PNG"><br><h2 id="부울식-간략화-예제"><a href="#부울식-간략화-예제" class="headerlink" title="부울식 간략화 예제"></a>부울식 간략화 예제</h2><pre><code>eg. E = (a&#39; + bc)(a+b)    = aa&#39; + a&#39;b + abc + bbc ;`aa&#39;=0`    = a&#39;b + abc + bc ;`bbc=bc`    = (a+1)bc + a&#39;b ;`a+1=0`    = bc + a&#39;b</code></pre><h2 id="논리식-간편화-카르노맵-Karnaugh-Map"><a href="#논리식-간편화-카르노맵-Karnaugh-Map" class="headerlink" title="논리식 간편화 카르노맵 (Karnaugh-Map)"></a>논리식 간편화 카르노맵 (Karnaugh-Map)</h2><ul><li>복잡한 논리식을 좀 더 편리하게 간소화할 수 있는 방법 중 하나이다.</li><li>eg. E = a’b + abc + bc</li></ul><img width="305" alt="카노맵" src="https://user-images.githubusercontent.com/28856435/120344782-ddb0cf80-c334-11eb-8764-6f5dd7ced2f1.PNG"><br><h3 id="카르노맵-사용순서"><a href="#카르노맵-사용순서" class="headerlink" title="카르노맵 사용순서"></a>카르노맵 사용순서</h3><ol><li>변수의 개수를 파악하고 2^n개의 테이블을 생성.</li><li>테이블에 식을 분석하여 0과 1을 채워준다.</li><li>인접한 것끼리 묶어준다.</li><li>간소화된 식을 도출 할수 있다.</li></ol><hr><h1 id="조합-논리회로"><a href="#조합-논리회로" class="headerlink" title="조합 논리회로"></a>조합 논리회로</h1><ul><li><code>입력</code>과 <code>출력</code>값을 가진 <code>논리 게이트의 집합</code></li><li>출력은 현재의 <code>입력값</code>과 <code>조합의 함수(AND/XOR ...)</code>이다.</li><li><code>순차 논리회로</code>는 게이트뿐 아니라 기억능력이 있는 <code>플립플롭(Flip-Flop)</code>으로 구성된다.</li></ul><h2 id="조합논리-회로-설계절차"><a href="#조합논리-회로-설계절차" class="headerlink" title="조합논리 회로 설계절차"></a>조합논리 회로 설계절차</h2><ol><li>문제 제시</li><li>입력/출력 변수에 문자기호를 부여</li><li>입력/출력 사이의 관계를 정의하는 진리표 유도</li><li>각 출력에 대한 부울식을 간소화</li><li>논리도 작성</li></ol><h3 id="대표적인-조합회로"><a href="#대표적인-조합회로" class="headerlink" title="대표적인 조합회로"></a>대표적인 조합회로</h3><ul><li><strong>가산기(Adder):</strong> 반가산기, 전가산기</li><li><strong>멀티플렉서(Multiplexer):</strong> <code>다수의 입력선</code> 중 <code>하나만</code>을 선별적으로 출력 가능 (시그널 조작)</li><li><strong>디멀티플렉서(Demultiplexer):</strong> 하나의 입력선을 <code>다수개의 출력선으로 분해</code>하는 기능 (멀티플렉서의 역기능)</li></ul><h2 id="순차회로"><a href="#순차회로" class="headerlink" title="순차회로"></a>순차회로</h2><ul><li>플립플롭과 게이트를 서로 연결한것.</li><li>게이트들로만 이루어진 회로는 조합회로이지만 플립플롭이 포함될 경우 순차회로가 된다.</li><li>순차회로의 특성은 입력, 출력 및 플리플롭의 상태로부터 지어진다. -&gt; <code>상태표, 상태도</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;플리플롭(Flip-Flop) 이란 무엇일까?&lt;br&gt;부울대수 그리고 카르노맵&lt;br&gt;&lt;code&gt;#Pthread&lt;/code&gt; &lt;code&gt;#부울대수&lt;/code&gt; &lt;code&gt;#karnaugh_map&lt;/code&gt; &lt;code&gt;#Flip-Flop&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>💻 컴퓨터구조-컴퓨터 구성요소</title>
    <link href="http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"/>
    <id>http://yoursite.com/2021/06/01/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/</id>
    <published>2021-06-01T14:40:54.000Z</published>
    <updated>2021-06-02T02:10:14.784Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="중앙처리-장치와-보조기억장치"><a href="#중앙처리-장치와-보조기억장치" class="headerlink" title="중앙처리 장치와 보조기억장치"></a>중앙처리 장치와 보조기억장치</h1><h2 id="중앙처리장치-Central-Processing-Unit"><a href="#중앙처리장치-Central-Processing-Unit" class="headerlink" title="중앙처리장치(Central Processing Unit)"></a>중앙처리장치(Central Processing Unit)</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li>마더보드(Mother board)<ul><li>산술논리 연산장치(ALU)</li><li>제어장치(CU)</li></ul></li></ul><h3 id="MPU-Micro-Processor-Unit"><a href="#MPU-Micro-Processor-Unit" class="headerlink" title="MPU (Micro Processor Unit)"></a>MPU (Micro Processor Unit)</h3><ul><li>CPU를 LSI(고밀도 집적회로)화 한 일종의 통합장치</li><li>기계어 명령의 길이와 형식에 따라 CISC(Complex Instruction Set Computer)/RISC(Reduced Instruction Set Computer) 로 나뉜다.</li><li>Bit Slice MPU 등이 존재한다.</li><li><strong>CISC</strong><ul><li>컴파일러 작성이 쉬우며 <code>복잡한 명령</code>도 실행 <code>효율</code>이 좋다.</li><li>명령어가 <code>복잡하고 종류가 많다</code>. 디코딩 시간이 오래걸린다.</li></ul></li><li><strong>RISC</strong><ul><li><code>고정된 명령어</code> 길이를 사용하고 <code>종류가 적다</code>. 속도가 빠르다. 효율은 낮다.</li><li>명령수행 속도가 빠르다. 전력 소모가 적다. -&gt; 임베디드 프로세서에 많이 사용한다.</li><li>단순화되어서 연속적으로 중복 수행하는 <code>파이프라인 성능</code>에 최적화 된다.</li><li>단순 -&gt; 설계비용이 줄어든다.</li><li>적은수의 명령어 셋을 이용해 쉽게 프로그래밍 할 수 있다.</li><li>컴파일 최적화 과정이 복잡하다.</li></ul></li></ul><h3 id="사물인터넷-IoT-H-W-플랫폼"><a href="#사물인터넷-IoT-H-W-플랫폼" class="headerlink" title="사물인터넷(IoT) H/W 플랫폼"></a>사물인터넷(IoT) H/W 플랫폼</h3><ul><li>아두이노</li></ul><hr><h2 id="주변장치"><a href="#주변장치" class="headerlink" title="주변장치"></a>주변장치</h2><h3 id="기억장치-Memory-Unit"><a href="#기억장치-Memory-Unit" class="headerlink" title="기억장치(Memory Unit)"></a>기억장치(Memory Unit)</h3><pre><code>- RAM (Random Access Memory)    - DRAM(Dinamic RAM)    - SRAM- ROM (Read Only Memory)    - ROM BIOS 부팅으로 하드디스크에 있는 운영체제를 불러온다.    - 외부에 있는 프로그램을 불러들일 수 있게끔 작동하는 기억장치.</code></pre><h4 id="주기억장치-보조기억장치-관계"><a href="#주기억장치-보조기억장치-관계" class="headerlink" title="주기억장치-보조기억장치 관계"></a>주기억장치-보조기억장치 관계</h4><ol><li>전원 부팅시 CPU는 자동으로 ROM에 있는 프로그램 실행.</li><li>보조기억장치-&gt; RAM <code>적재(load)</code></li><li>RAM &lt;-&gt; CPU 메모리로부터 실행할 명령어와 데이터를 가지고 와서 처리한다.</li><li>RAM -&gt; 보조기억장치 <code>저장(save)</code></li></ol><h3 id="보조기억장치"><a href="#보조기억장치" class="headerlink" title="보조기억장치"></a>보조기억장치</h3><pre><code>- 동작속도 : 저속- 가격: 저렴- 종류    - 플래시 기억장치(RAM과 ROM의 중간위치)    - USB 기억장치    - SD card    - 메모리 스틱</code></pre><h3 id="입출력장치"><a href="#입출력장치" class="headerlink" title="입출력장치"></a>입출력장치</h3><pre><code>- 키보드, 마우스, 스캐너, 터치스크린 등</code></pre><hr><h1 id="컴퓨터-구조와-통신"><a href="#컴퓨터-구조와-통신" class="headerlink" title="컴퓨터 구조와 통신"></a>컴퓨터 구조와 통신</h1><ul><li>혁신적 네트워크 발전 (양자컴퓨터)<ul><li><code>NOS</code>(Network Operating System) 의 역할 확대</li></ul></li></ul><h2 id="비지니스환경의-통신과-네트워킹"><a href="#비지니스환경의-통신과-네트워킹" class="headerlink" title="비지니스환경의 통신과 네트워킹"></a>비지니스환경의 통신과 네트워킹</h2><ul><li>4차 산업혁명을 실현하기 위한 핵심 인프라</li><li>유무선 통신, 방송 통신, 컴퓨터의 융합 등 컨버전스가 가능</li><li>소프트웨어 기술과 고밀도 집적기술의 발달 - 신형 서비스/장비</li><li>사용자 중심의 신기술 발전</li></ul><h2 id="양자-컴퓨터"><a href="#양자-컴퓨터" class="headerlink" title="양자 컴퓨터"></a>양자 컴퓨터</h2><ul><li>중첩(superposition), 얽힘(entanglement) 등 고유한 양자의 물리학적 특성으로, 다수의 정보를 동시에 처리할 수 있는 새로운 컴퓨터</li><li>누전 설류로 인한 고전컴퓨터 성능 한계돌파를 위한 대안</li></ul><h2 id="글로벌인터넷"><a href="#글로벌인터넷" class="headerlink" title="글로벌인터넷"></a>글로벌인터넷</h2><ul><li>1세대: www디렉토리 검색</li><li>2세대: 개방, 참여정신을 바탕으로 쌍방향 웹기술이 가능</li><li>3세대: 시맨틱 웹기술을 활용하여 개인 맞춤형 정보를 제공하는 지능형 웹기술</li><li>4세대: 현실과 가상이 연결되는 초연결 지능화 웹기술</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;기본적인 컴퓨터의 구성요소&lt;br&gt;&lt;code&gt;#CPU&lt;/code&gt; &lt;code&gt;#MPU&lt;/code&gt; &lt;code&gt;#ROM&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="computer_science" scheme="http://yoursite.com/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>🛢 메모리_mmap</title>
    <link href="http://yoursite.com/2021/05/31/%EB%A9%94%EB%AA%A8%EB%A6%AC-mmap/"/>
    <id>http://yoursite.com/2021/05/31/%EB%A9%94%EB%AA%A8%EB%A6%AC-mmap/</id>
    <published>2021-05-31T08:44:06.000Z</published>
    <updated>2021-06-02T02:10:14.783Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h1 id="메모리-amp-mmap"><a href="#메모리-amp-mmap" class="headerlink" title="메모리 &amp; mmap"></a>메모리 &amp; mmap</h1><h2 id="mmap-함수-사용"><a href="#mmap-함수-사용" class="headerlink" title="mmap 함수 사용"></a>mmap 함수 사용</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fildes, <span class="keyword">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addr: 매핑할 메모리 <code>주소</code></li><li>len: 메모리 <code>공간의 크기</code></li><li>prot: 보호 모드</li><li>flags: 매핑된 데이터의 처리 방법을 지정하는 상수</li><li>fildes: 파일 기술자</li><li>off: 파일 오프셋</li></ul><p><strong><code>문제</code></strong></p><ul><li>기존에 <code>파일 - 프로세스</code> 에 접근할경우,</li><li>프로세스에서는 시스템콜, 스케줄러, 인터럽트 등의 기법을 사용하기 위해 OS가 <code>처리할일이 많아서</code> </li><li>파일을 가지고 있는 CPU에서는 DMA 나 SystemBus 를 사용해야 한다.</li><li>즉, <code>성능이 떨어질 수 밖에</code> 없다.</li></ul><p><strong><code>해결</code></strong></p><ul><li><code>파일 - 메모리 - 프로세스</code> : 중간에 메모리를 두어, 파일의 특정공간을 미리 메모리 영역에 매핑해둔다.</li><li>자주 엑세스할 파일이 있다면, 프로세스는 메모리 영역에 접근하여 빠르게 읽어올 수 있다.</li><li>mmap는 프로세스의 주소공간을 파일에 대응시킨다. 파일은 운영체제 전역적인 자원이므로 당연히 어렵잖게 <code>다른 프로세스와 공유</code>해서 사용할 수 있을 것이다.</li></ul><h2 id="mmap-동작"><a href="#mmap-동작" class="headerlink" title="mmap 동작"></a>mmap 동작</h2><ol><li>mmap 실행시, 가상 메모리 주소에 file 주소를 매핑한다. (페이지 디렉토리)</li><li>해당 메모리 접근시(요구페이징, lazy allocation)</li></ol><ul><li><code>페이지폴트 인터럽트</code> 발생</li><li>OS에서 file data 를 복사해서 물리메모리 페이지에 넣어준다.</li></ul><ol start="3"><li>메모리 read: 해당 물리 페이지 데이터를 읽음</li><li>메모리 write: 해당 물리 페이지 데이터 수정후, 페이지 상태 flag 중 dirty bit를 1로 수정</li><li>파일 close: 물리 페이지 데이터가 file에 업데이트됨. (dirty bit 가 1인곳)</li></ol><h3 id="파일-메모리-가상메모리"><a href="#파일-메모리-가상메모리" class="headerlink" title="파일, 메모리 가상메모리"></a>파일, 메모리 가상메모리</h3><ul><li>장점</li><li>read(), write 시에 반복적인 파일접근을 방지하여 성능을 개선한다.</li><li>mapping 된 영역은 파일 처리를 위한 lseek() <code>file-&gt;data주소 찾아가는 함수</code>를 사용하지 않고 간단한 포인터 조작으로 탐색.</li></ul><p>단점</p><ul><li>mmap은 내부적으로 가상메모리와 연관되어 <code>페이지 사이즈 단위로 매핑</code>된다. 그런데 고정된 페이지 사이즈 단위보다 클 경우 추가공간이 필요하고, 적을 경우 공간낭비(0으로 채움)가 일어난다.</li></ul><h2 id="파일처리-성능개선-munmap"><a href="#파일처리-성능개선-munmap" class="headerlink" title="파일처리 성능개선 munmap"></a>파일처리 성능개선 munmap</h2><ul><li>*addr 에 mapping 된 물리 메모리 주소를 해제한다.</li><li>lenght: mapping된 메모리크기 (mmap과 동일값)</li></ul><h2 id="맵핑된-메모리-영역을-동기화-하는-방법"><a href="#맵핑된-메모리-영역을-동기화-하는-방법" class="headerlink" title="맵핑된 메모리 영역을 동기화 하는 방법"></a>맵핑된 메모리 영역을 동기화 하는 방법</h2><ul><li>MS_ASYNC: 비동기 방식으로 결과에 관계 없이 프로그램 속행</li><li>MS_SYNC: 동기 방식으로 결과를 확인 후 프로그램 속행</li><li>MS_ALERT: 동기화 후 시그널을 통해 알림.</li><li>MS_INVALIDATE: 현제 메모리 맵을 무효화함.</li></ul><hr><h1 id="inode-방식-파일시스템"><a href="#inode-방식-파일시스템" class="headerlink" title="inode 방식 파일시스템"></a>inode 방식 파일시스템</h1><ul><li>inode의 메타데이터에는 아래와 같은 정보들이 포함된다.</li></ul><ul><li>Mode: 파일종류/권한</li><li>Owner Info: 소유자,소울그룹</li><li>Size: 파일사이즈</li><li>Timestamps: 생성, 수정시간</li><li>Direct blocks (12개): 직접적으로 주소가리킴</li><li>Single inderect, Double inderect, Triple inderect: 간접적 주소가리킴</li></ul><blockquote><p>이러한 inode 메타데이터를 모두 가져오는 함수가 있다. <code>stat</code> 함수</p></blockquote><h2 id="stat-함수"><a href="#stat-함수" class="headerlink" title="stat 함수"></a>stat 함수</h2><blockquote><p><strong>사용 문법</strong><br>int stat(const char *path, struct stat *buf);<br>*buf : 구조체 변수</p></blockquote><ul><li>stat: 파일을 <code>filepath</code> 로 지정한다.</li><li>fstat: 파일을 <code>fd 넘버</code>로 지정한다.</li><li>lstat: 파일을 <code>filepath 로 지정</code>하되 지정된 파일이 <code>심볼릭 링크 파일</code>이면 링크파일 자체에 대한 정보를 얻는다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"> <span class="keyword">dev_t</span>     st_dev;  <span class="comment">// ID of device containing file</span></span><br><span class="line">                          <span class="comment">// :: 가상파일 시스템 file-system interface 를 사용하여 하단부에 있는 실제    디바이스의  종류는 달리할 수 있다. `추상화` `UNIX 모든것은 파일`</span></span><br><span class="line"> <span class="keyword">ino_t</span>     st_ino;  <span class="comment">// inode number</span></span><br><span class="line"> <span class="keyword">mode_t</span>    st_mode;  <span class="comment">// 파일 종류 및 접근권한</span></span><br><span class="line"> <span class="keyword">nlink_t</span>   st_nlink;  <span class="comment">// hardlink 의 횟수</span></span><br><span class="line"> <span class="keyword">uid_t</span>     st_uid;  <span class="comment">// 파일 owner</span></span><br><span class="line"> <span class="keyword">gid_t</span>     st_gid;  <span class="comment">// group ID of owner</span></span><br><span class="line"> <span class="keyword">off_t</span>     st_size;  <span class="comment">// 파일크기</span></span><br><span class="line"> <span class="keyword">blksize_t</span> st_blksize; <span class="comment">// blocksize for file system I/O</span></span><br><span class="line"> <span class="keyword">blkcnt_t</span>  st_blocks;  <span class="comment">// number of 512B blocks allocated</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_atime;  <span class="comment">// time if last access</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_mtime;  <span class="comment">// time if last modification</span></span><br><span class="line"> <span class="keyword">time_t</span>    st_ctime;  <span class="comment">// time if last status change</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stat-test-c-실습"><a href="#stat-test-c-실습" class="headerlink" title="stat-test.c 실습"></a>stat-test.c 실습</h3><ul><li>실제로 hello.txt 라는 파일의 메타데이터를 출력해보는 stat-test.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret= <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">  ret= <span class="built_in">stat</span>(<span class="string">&quot;hello.txt&quot;</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;deviceId:%ld, inode:%ld, hardLinkCount:%ld, filesize: %ld, blockSize:%ld, blockCount:%ld \n&quot;</span>, buf.st_dev, buf.st_ino, buf.st_nlink, buf.st_size, buf.st_blksize, buf.st_blocks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>출력 결과</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> ./stat-test</span></span><br><span class="line">deviceId:51713, inode:256331, hardLinkCount:1, filesize: 7, blockSize:4096, blockCount:8</span><br></pre></td></tr></table></figure><h1 id="Standard-Stream-표준-입출력-스트림"><a href="#Standard-Stream-표준-입출력-스트림" class="headerlink" title="Standard Stream 표준 입출력 스트림"></a>Standard Stream 표준 입출력 스트림</h1><ul><li>모든 스트림은 일반적인 plain text로 console에 출력된다.</li><li>표준 입력 스트림(Standard Input Stream): stdid</li><li>표준 입력 스트림(Standard Ouput Stream): stdout</li><li>표준 입력 스트림(Standard Error Stream): stderr</li></ul><h3 id="std-test-c-실습"><a href="#std-test-c-실습" class="headerlink" title="std-test.c 실습"></a>std-test.c 실습</h3><ul><li>아래 프로그램을 실행하면, 터미널에 입력할 때마다 stdin 에 들어가고, stdout 으로 출력되는 것을 확인할 수 있다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">  FILE* fp; <span class="comment">// 파일 디스크립터</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;  <span class="comment">// 인자가 들어오면,</span></span><br><span class="line">    fp= <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>); <span class="comment">// 읽기오픈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;file open error&quot;</span>, stderr);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fp= stdin; <span class="comment">// 터미널에 입력된 데이터가 표준입력(stdin)에 들어간다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="number">255</span>, fp) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stdout); <span class="comment">// 파일 표준출력(stdout)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>실행 결과</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> ./std-test</span></span><br><span class="line">hello // stdin</span><br><span class="line">hello // stdout</span><br><span class="line">입력  // stdin</span><br><span class="line">입력  // stdout</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;메모리와 관련된 mmap 함수의 사용법을 알아본다.&lt;br&gt;stat 함수 사용으로 inode 메타데이터를 출력해본다.&lt;br&gt;&lt;code&gt;#mmap&lt;/code&gt; &lt;code&gt;#stat&lt;/code&gt; &lt;code&gt;#inode&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>스레드 pthread 구현</title>
    <link href="http://yoursite.com/2021/05/27/%EC%8A%A4%EB%A0%88%EB%93%9C-pthread-%EA%B5%AC%ED%98%84/"/>
    <id>http://yoursite.com/2021/05/27/%EC%8A%A4%EB%A0%88%EB%93%9C-pthread-%EA%B5%AC%ED%98%84/</id>
    <published>2021-05-27T14:50:54.000Z</published>
    <updated>2021-06-03T09:31:07.432Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="스레드"><a href="#스레드" class="headerlink" title="스레드"></a>스레드</h1><h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><ul><li><code>POSIX 스레드</code> 또는 <code>Pthread</code> 라고 부른다.</li><li>저수준 API로 100 여개의 함수 제공</li><li>복잡하지만 유닉스 시스템 핵심 스레딩 라이브러리</li><li>다른 스레딩 솔루션도 결국 Pthread 를 기반으로 구현되어 있으므로 익혀둘 가치가 있다.</li><li>기본 라이브러리 <code>(glibc) 와 분리</code>된 <code>libpthread</code> 라이브러리에 pthread 구현되어 있으므로<br>컴파일시 명시적으로 <code>pthread 옵션</code>이 필요하다.</li><li>pthread API는 <code>Semaphore를 포함하지 않는다</code>.</li></ul><h2 id="Pthread-라이브러리"><a href="#Pthread-라이브러리" class="headerlink" title="Pthread 라이브러리"></a>Pthread 라이브러리</h2><ul><li>&lt;pthread.h&gt; 헤더 파일에서 정의한다.</li><li>모든함수는 <code>pthread_</code> 로 시작한다.</li></ul><h2 id="스레드-생성"><a href="#스레드-생성" class="headerlink" title="스레드 생성"></a>스레드 생성</h2><ul><li>스레드 생성<ul><li>thread_inst(): 9까지 출력</li><li>main 함수: thread_inst 스레드 생성후, 4까지 출력</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">include&lt;pthread.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include&lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void * thread_inst(void *arg)&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    tid = pthread_self();</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;10)&#123;</span><br><span class="line">        printf(&quot;[%lx] new thread: %d\n&quot;, tid, i);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, NULL, thread_inst, NULL);</span><br><span class="line">    pthread_t tid= pthread_self();</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;5)&#123;</span><br><span class="line">        printf(&quot;[%lx] main thread: %d\n&quot;, tid, i);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>스레드 실행결과<ul><li>아래처럼 9까지 출력되어야 할 new thread 는 main 함수가 끝나니 함께 끝나버렸다.</li><li>다음 예제의 pthread_join 추가가 필요하다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ gcc pthread.c -pthread -o pthread</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ./pthread</span><br><span class="line">[7f93eb31c740] main thread: 0</span><br><span class="line">[7f93eaaee700] new thread: 0</span><br><span class="line">[7f93eb31c740] main thread: 1</span><br><span class="line">[7f93eaaee700] new thread: 1</span><br><span class="line">[7f93eb31c740] main thread: 2</span><br><span class="line">[7f93eaaee700] new thread: 2</span><br><span class="line">[7f93eb31c740] main thread: 3</span><br><span class="line">[7f93eaaee700] new thread: 3</span><br><span class="line">[7f93eb31c740] main thread: 4</span><br><span class="line">[7f93eaaee700] new thread: 4</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="스레드-관리"><a href="#스레드-관리" class="headerlink" title="스레드 관리"></a>스레드 관리</h2><ul><li>리소스</li></ul><ol><li>pthread_join</li></ol><ul><li>메인 스레드에서 해당 스레드가 종료되면, 상태값을 보고 메인스레드에서 <code>추가처리</code>를 할 수 있다.</li></ul><ol start="2"><li>pthread_detach(thread1)</li></ol><ul><li>관련 리소스를 <code>즉시 해제</code>한다.</li></ul><ul><li>실행</li></ul><ol><li>pthread_join</li></ol><ul><li>스레드 1이 종료될때까지 다음코드를 수행하지 않고 <code>기다린다</code>.</li></ul><ol start="2"><li>pthread_detach</li></ol><ul><li>스레드 1이 종료될때까지 <code>기다리지 않는다</code>.</li></ul><h2 id="Pthread-뮤텍스-상호배제-기법"><a href="#Pthread-뮤텍스-상호배제-기법" class="headerlink" title="Pthread 뮤텍스 - 상호배제 기법"></a>Pthread 뮤텍스 - 상호배제 기법</h2><pre><code class="~~`"></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;POSIX thread와 그 사용법 익혀보기.&lt;br&gt;&lt;code&gt;#Pthread&lt;/code&gt; &lt;code&gt;#pthread_join&lt;/code&gt; &lt;code&gt;#pthread_detach&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>프로세스 IPC 기법</title>
    <link href="http://yoursite.com/2021/05/26/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-IPC-%EA%B8%B0%EB%B2%95/"/>
    <id>http://yoursite.com/2021/05/26/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-IPC-%EA%B8%B0%EB%B2%95/</id>
    <published>2021-05-26T14:13:08.000Z</published>
    <updated>2021-05-31T00:52:37.997Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="IPC-기법"><a href="#IPC-기법" class="headerlink" title="IPC 기법"></a>IPC 기법</h1><h2 id="파이프"><a href="#파이프" class="headerlink" title="파이프"></a>파이프</h2><ul><li>부모 프로세스와 자식 프로세스가 같은 <code>kernel 공간</code>을 공유한다. 즉, 같은 물리주소를 바라보고 있다.</li><li><code>단방향</code> 통신이다. 부모프로세스 -&gt; 자식프로세스</li></ul><h3 id="파이프-예제"><a href="#파이프-예제" class="headerlink" title="파이프 예제"></a>파이프 예제</h3><ul><li>부모프로세스가 <code>write</code> 한 msg를 <code>pipe</code>를 통해 자식프로세스가 <code>read</code> 한다.</li></ul><ul><li>pipe.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* msg=<span class="string">&quot;Hello Child Process&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>], pid, nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 파이프 생성: pipe(fd)= -1이면 pipe가 생성되지 않은것.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pipe</span>(fd)&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 종료</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 부모-자식 프로세스 생성</span></span><br><span class="line">        pid= fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after fork pid : %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123; <span class="comment">// 부모 프로세스</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[1] Parent: %d, Child: %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">                <span class="comment">// 부모 프로세스가 fd[1] 에 쓴다.</span></span><br><span class="line">                <span class="built_in">write</span>(fd[<span class="number">1</span>], msg, MSGSIZE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//자식 프로세스에는 pid값이 0</span></span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">&quot;[2] Parent: %d, Child: %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line"></span><br><span class="line">                 nbytes = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, MSGSIZE);</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">&quot;nbytes: %d , msg: %s\n&quot;</span>, nbytes, buf);</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="파이프-실행-결과"><a href="#파이프-실행-결과" class="headerlink" title="파이프 실행 결과"></a>파이프 실행 결과</h3><ul><li>pid=0 일 때 자식 프로세스이며, 아래와 같이 부모 프로세스가 저장한 <code>msg</code> 를 읽어오는 것을 확인할 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./_ipc</span></span><br><span class="line">[1] Parent: 21768, Child: 21769</span><br><span class="line"><span class="meta">$</span><span class="bash"> [2] Parent: 21769, Child: 0</span></span><br><span class="line">nbytes: 255 , msg: Hello Child Process</span><br></pre></td></tr></table></figure><hr><h2 id="메시지-큐"><a href="#메시지-큐" class="headerlink" title="메시지 큐"></a>메시지 큐</h2><ul><li><code>kernel 공간</code>의 메모리를 사용한다.</li><li><code>양방향</code> 통신이 가능하다.</li><li>먼저 들어간 메시지부터 읽는다.</li></ul><h3 id="메시지-큐-예시"><a href="#메시지-큐-예시" class="headerlink" title="메시지 큐 예시"></a>메시지 큐 예시</h3><ul><li><p> <code>msgrcv</code>(int msgid, void *msgp, size_t msgsz, long msgtype, int msgflag)</p></li><li><p>msgtype: 0일때 첫번째 데이터부터 읽고 그 이상이라면 그 type에 일치하는 데이터부터 읽는다.</p></li><li><p>msgflag: 0: 블록모드, IPC_NOWAIT: 비블록모드</p></li><li><p>보내는 프로세스 msgSnd.c, 받는 프로세스 msgRcv.c 를 따로 만들어 수행한다.</p></li></ul><ul><li>msgSnd.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> type;</span><br><span class="line">        <span class="keyword">char</span> text[<span class="number">50</span>];</span><br><span class="line">&#125; MsgBuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> msgid, len;</span><br><span class="line">        MsgBuf msg;</span><br><span class="line">        <span class="keyword">key_t</span> key = <span class="number">1234</span>;</span><br><span class="line">        <span class="comment">// IPC_CREAT: 새로운 키는 식별자 생성(접근권한)</span></span><br><span class="line">        msgid= <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0644</span>); <span class="comment">// =&gt; rw‑r‑‑r‑‑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.type = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 아래 메시지 전송</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg.text, <span class="string">&quot;Message Queue is Executed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">msgsnd</span>(msgid, (<span class="keyword">void</span> *)&amp;msg, <span class="number">50</span>, IPC_NOWAIT) == <span class="number">-1</span>)&#123; </span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>msgRcv.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> type;</span><br><span class="line">        <span class="keyword">char</span> text[<span class="number">50</span>];</span><br><span class="line">&#125; MsgBuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> msgid, len;</span><br><span class="line">        MsgBuf msg;</span><br><span class="line">        <span class="keyword">key_t</span> key = <span class="number">1234</span>;</span><br><span class="line">        <span class="comment">// IPC_CREAT: 새로운 키는 식별자 생성(접근권한)</span></span><br><span class="line">        msgid= <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0644</span>); <span class="comment">// =&gt; rw‑r‑‑r‑‑</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        len= <span class="built_in">msgrcv</span>(msgid, &amp;msg, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got a Message ! =&gt; %s [%d] \n&quot;</span>, msg.text, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="메시지큐-실행-결과"><a href="#메시지큐-실행-결과" class="headerlink" title="메시지큐 실행 결과"></a>메시지큐 실행 결과</h3><ul><li>msgSnd - 보내고 , msgRcv - 받는다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ gcc msgRcv.c -o msgRcv</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ gcc msgSnd.c -o msgSnd</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./msgSnd</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./msgRcv</span><br><span class="line">Got a Message ! =&gt; Message Queue is Executed</span><br><span class="line"> [50]</span><br></pre></td></tr></table></figure><br><blockquote><p><strong>ftok() - 키 생성을 위한 함수</strong></p><ul><li>path 경로명의 inode 값과 숫자값(id)을 기반으로 생성된다.</li><li>경로 삭제 후 재생성시 inode값이 달라지므로 기존과 다른 값을 리턴한다.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 예시</span></span><br><span class="line">key = <span class="built_in">ftok</span>(<span class="string">&quot;keyfile&quot;</span>, <span class="number">1</span>); <span class="comment">// 메시지큐를 통해서 부모-자식 프로세스 간 공유</span></span><br><span class="line">id = <span class="built_in">msgget</span>(key, IPC_CREAT|<span class="number">0640</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;IPC 기법을 직접 실습해본다.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="ipc" scheme="http://yoursite.com/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>시스템콜을 이용한 프로세스 관리</title>
    <link href="http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/"/>
    <id>http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/</id>
    <published>2021-05-24T13:24:11.000Z</published>
    <updated>2021-05-31T07:43:32.170Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h1><ul><li>생성과정<br>(1) TEXT, DATA, BSS, HEAP, STACK 의 공간을 생성한다.<br>(2) 프로세스 이미지를 해당 공간에 업로드하고 실행한다.</li></ul><h2 id="프로세스-소유자-관리"><a href="#프로세스-소유자-관리" class="headerlink" title="프로세스 소유자 관리"></a>프로세스 소유자 관리</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/shadow</span></span><br></pre></td></tr></table></figure><h1 id="시스템콜-함수사용"><a href="#시스템콜-함수사용" class="headerlink" title="시스템콜 함수사용"></a>시스템콜 함수사용</h1><h2 id="getpid-getppid-시스템콜"><a href="#getpid-getppid-시스템콜" class="headerlink" title="getpid() getppid() 시스템콜"></a>getpid() getppid() 시스템콜</h2><ul><li>getpid(), getppid() 함수를 사용하여 test_ps.c 프로그램 예시.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ppid=%d\n&quot;</span>, getppid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아래와 같이 <code>pid</code>, <code>ppid</code> 가 정상적으로 출력되는것을 확인할 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~/test$ gcc test_ps.c -o test_ps</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ls</span><br><span class="line">dir  loop.c  soft  soft_link  softlink  test_ps  test_ps.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ./test_ps</span><br><span class="line">pid=14611</span><br><span class="line">ppid=14529</span><br></pre></td></tr></table></figure><h2 id="fork-exec-프로세스-생성"><a href="#fork-exec-프로세스-생성" class="headerlink" title="fork() exec() - 프로세스 생성"></a>fork() exec() - 프로세스 생성</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><blockquote><p>새로운 프로세스 공간을 별도로 만들고, fork() 를 호출한 프로세스(부모) 공간을 모두 <code>복사</code>한다.</p></blockquote><ul><li><p>함수 사용</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;unistd.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>자식프로세스는 <code>pid=0</code>, 부모프로세스는 <code>실제 pid</code></p></li><li><p>pid= fork() 실행되면 부모 프로세스와 동일한 자식 프로세스를 <code>별도 메모리공간</code>에 생성한다.</p></li><li><p>두 프로세스의 변수, PC(Program Counter)값은 동일하다.</p></li></ul><ul><li>_fork.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before fork() call\n&quot;</span>);</span><br><span class="line"> <span class="comment">// -- 여기까지 프로세스는 1개</span></span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child Process&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><blockquote><p>호출한 현재 프로세스 공간의 <code>TEXT, DATA, BSS</code> 영역을 새로운 프로세스의 이미지로 <code>덮어씌운다</code>. 별도의 공간을 만들지 않는다.</p></blockquote><ul><li>헤더</li><li>함수 6가지</li><li>execlp : path 명 포함. </li></ul><ul><li>_execl.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;execute ls\n&quot;</span>);</span><br><span class="line">  execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// argv[0]=ls, argv[1]=-l</span></span><br><span class="line">  <span class="comment">// -- 기존의 &#x27;ls al&#x27; 의 기능이 덮어씌워진다.</span></span><br><span class="line">  perror(execl is failed\n);</span><br><span class="line">  <span class="comment">// - 에러코드 출력</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="wait-기다림"><a href="#wait-기다림" class="headerlink" title="wait() - 기다림"></a>wait() - 기다림</h2><blockquote><ul><li>fork() 함수 호출시 자식 프로세스가 종료할 때까지 <code>부모 프로세스가 기다린다.</code></li><li>wait() 자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 먼저 죽는 경우를 막기 위해 사용한다. (고아 프로세스: 자식 프로세스가 메모리를 계속 사용하고 있을 수 있다.)</li><li>자식 프로세스의 일이 끝나면 부모 프로세스에 <code>SIGCHLD</code> 시그널을 보낸다. </li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/28856435/119525382-6a99dd00-bdb9-11eb-9517-fd7ebb48d420.jpg" alt="KakaoTalk_20210526_002054322"></p><br><h3 id="wait-시스템콜-사용"><a href="#wait-시스템콜-사용" class="headerlink" title="wait() 시스템콜 사용"></a>wait() 시스템콜 사용</h3><ul><li>리턴값은 종료된 <code>자식 프로세스의 pid</code> 이다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span> <span class="params">(<span class="keyword">int</span> *status)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 사용: status 를 통해 자식 프로세스 정보 확인</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WIFEXITED</span><span class="params">(status)</span></span>; <span class="comment">// 0 이 아닐때 정상종료</span></span><br></pre></td></tr></table></figure><ul><li>test_wait.c 실습</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="keyword">int</span> child_pid;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  pid= fork();</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span>(pid)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;fork is failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    csae <span class="number">0</span>: <span class="comment">// pid : 자식</span></span><br><span class="line">      <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;execl is failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// pid : 부모</span></span><br><span class="line">      <span class="comment">// 부모프로세스는 자식 프로세스가 끝나길 기다림</span></span><br><span class="line">      <span class="comment">// status에 자식프로세스의 상태를 담아줌</span></span><br><span class="line">      child_pid= <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Parent PID(%d), Child PID (%d)\n&quot;</span>, <span class="built_in">getpid</span>(), child_pid)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0 이 아니면 정상종료.</span></span><br><span class="line">      ret = <span class="built_in">WIFEXITED</span>(status);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 정상종료</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is normally terminated\n&quot;</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 비정상 종료</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is abnormally terminated\n&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fork-execl-wait-사용한-프로그램-만들기"><a href="#fork-execl-wait-사용한-프로그램-만들기" class="headerlink" title="fork(), execl(), wait() 사용한 프로그램 만들기"></a>fork(), execl(), wait() 사용한 프로그램 만들기</h2><ul><li>execl() 만 사용하면, 부모 프로세스가 사라진다.</li><li>이를 유지위해 fork() 로 새로운 공간 복사 후, execl() 사용.</li></ul><ul><li>fork_execl_wait.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">        <span class="keyword">int</span> proc_status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DaveShell ver 1.0\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// memset(void *ptr, int value, size_t num);</span></span><br><span class="line">            <span class="comment">// ptr: 채우고자하는 메모리 시작포인터</span></span><br><span class="line">            <span class="comment">// value: 메모리에서 채우고자하는값. 1byte마다 0x00(64)로 초기화</span></span><br><span class="line">            <span class="comment">// sizeof: 배열의 전체 바이트 크기</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, MAXLINE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// buf 출력해보기</span></span><br><span class="line">            <span class="comment">// for(int i=0; i&lt;(sizeof(buf)/sizeof(char)); i++)&#123;</span></span><br><span class="line">            <span class="comment">//     printf(&quot;%c\n&quot;, buf[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// char *fgets (char *string, int n, FILE *stream)</span></span><br><span class="line">            <span class="comment">// -- 파일에서 최대 MAXLINE-1 만큼 읽어서  buf 에 담음</span></span><br><span class="line">            <span class="built_in">fgets</span>(buf, MAXLINE<span class="number">-1</span>, stdin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf, <span class="string">&quot;exit\n&quot;</span>, <span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="comment">// strncmp(buf와 &#x27;exit\n&#x27; 의 문자열이 size5만큼) 같은지 문자열 비교</span></span><br><span class="line">              <span class="comment">// exit 를 입력후 enter치면 while문 종료</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 새로운 공간을 만들고 부모프로세스로부터 복사</span></span><br><span class="line">            pid= fork();</span><br><span class="line">            <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123; <span class="comment">// 자식 프로세스</span></span><br><span class="line">                <span class="comment">// 실행한 사용자의 PATH 환경변수</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">execl</span>(buf, buf, <span class="literal">NULL</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;command execution is failed\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 자식 프로세스 waiting</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fork_execl_wait 결과<ul><li><code>/bin/ls</code> 를 입력하면 해당 명령 수행.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ ./fork_exec_wait</span><br><span class="line">DaveShell ver <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">/bin/ls</span><br><span class="line">a.txt  a_link.txt  b.txt  b_link.txt  fork_exec_wait  fork_exec_wait.c</span><br></pre></td></tr></table></figure><h3 id="copy-on-write-COW-프로세스-생성"><a href="#copy-on-write-COW-프로세스-생성" class="headerlink" title="copy-on-write(COW) - 프로세스 생성"></a>copy-on-write(COW) - 프로세스 생성</h3><blockquote><p>copy-on-write<br><code>수정 (쓰기;write)</code> 가 일어날 때 복사한다.</p></blockquote><ul><li>자식 프로세스 생성시, 부모 프로세스 자원(페이지)을 우선 사용한다.</li><li>커널 공간을 공유한다.</li><li><code>READ</code> 요청<br>자식 프로세스 생성시, 부모 프로세스에서 사용하고 있는 물리주소를 그대로 사용(포인터랑 비슷하다고 생각하면 된다.)</li><li><code>WRITE</code> 요청<br>(1) write 요청<br>(2) Physical Memory : 부모 프로세스로의 물리 메모리 복사<br>(3) PCB : 자식 프로세스의 Page Pointer 변경</li></ul><h2 id="exit-프로세스-종료"><a href="#exit-프로세스-종료" class="headerlink" title="exit() - 프로세스 종료"></a>exit() - 프로세스 종료</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line"><span class="comment">// EXIT_SUCCESS 는 0, exit(EXIT_SUCCESS); // EXIT_SUCCESS 는 0</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><ul><li>main 함수의 return 0; 과 exit(0)l 의 차이</li><li><code>exit() </code> : 즉시 프로세스를 종료한다. exit()함수 다음에 있는 코드는 실행하지 않는다.</li><li><code>return 0</code> : 단순히 함수를 종료한다. 단, <code>main() 함수</code> 에서는 C 언어 실행파일에 포함된 <code>_start()</code> 함수를 호출한 뒤, 결과적으로는 exit() 함수가 호출된다.</li></ul><h3 id="exit-주요동작"><a href="#exit-주요동작" class="headerlink" title="exit() 주요동작"></a>exit() 주요동작</h3><ul><li>atexit()에 등록된 함수 실행</li><li>열려 있는 모든 입출력 스트림버퍼 삭제 (stdin, stdout, stdrerr 데이터)</li><li>프로세스가 오픈한 파일을 모두 닫는다.</li><li>tmpfile() 함수를 통해 생성된 임시파일 삭제</li><li><code>FILE *tmpfile(void)</code></li></ul><h3 id="atexit-함수-예제"><a href="#atexit-함수-예제" class="headerlink" title="atexit() 함수 예제"></a>atexit() 함수 예제</h3><ul><li>atexit()에 등록된 함수 실행 순서를 확인하는 예제이다.</li></ul><ul><li>test_exit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodbye</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">atexit</span>(hello);</span><br><span class="line">    <span class="keyword">if</span> (ret!=<span class="number">0</span>) <span class="built_in">perror</span>(<span class="string">&quot;Error in atexit\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">atexit</span>(goodbye);</span><br><span class="line">    <span class="keyword">if</span> (ret!=<span class="number">0</span>) <span class="built_in">perror</span>(<span class="string">&quot;Error in atexit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">goodbye</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;see you!\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아래와 같은 실행 결과를 보면, 아래서부터 반대로 수행한다. goodbye() 함수 수행 후 hello()함수가 수행되었다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> see you!</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hello</span></span><br></pre></td></tr></table></figure><h2 id="우선순위-기반-스케줄러"><a href="#우선순위-기반-스케줄러" class="headerlink" title="우선순위 기반 스케줄러"></a>우선순위 기반 스케줄러</h2><ul><li>Priority-Based 스케줄러 (우선순위 스케줄링)<ul><li>동적/정적</li></ul></li><li>프로세스 중 <code>root</code> 가 소유한 프로세스만 우선순위를 높일 수 있다. 그 외의 프로세스는 낮출 수만 있다.<ul><li>즉, 일반유저는 nice 값을 증가만 가능하며 root는 nice값을 감소시켜서 우선순위를 높일 수 있다.</li></ul></li><li>스케줄링 방식에 따라 <code>효과가 없을 수도</code> 있다.</li></ul><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h3><ul><li>기본값은 보통 <code>0</code>으로 시작한다.</li><li><code>-20 ~ 19</code> 까지 순위값을 조정할 수 있다.</li><li>값이 <code>작을수록</code> 우선순위가 높다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span> <span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>nice -n 10 bash</code> bash 프로세스 기존값에서 10을 증가 시킨다.</li><li>새로운 프로세스가 추가된다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R  1000   394 27607  0  80   0 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  80   0 -  5814 wait   pts/0    00:00:00 bash</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ nice -n 10 bash</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   461 27607  0  90  10 -  5752 wait   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000   470   461  0  90  10 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  80   0 -  5814 wait   pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure><h3 id="renice"><a href="#renice" class="headerlink" title="renice"></a>renice</h3><ul><li>nice 와 달리 기존의 PID 로 우선순위를 조정한다.</li><li><code>renice 15 27607</code> PID 27607의 우선순위를 10-&gt;15로 조정</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ renice 15 27607</span><br><span class="line">27607 (process ID) old priority 0, new priority 15</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   461 27607  0  90  10 -  5752 wait   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000   492   461  0  90  10 -  7336 -      pts/0    00:00:00 ps</span><br><span class="line">0 S  1000 27607 27606  0  95  15 -  5814 wait   pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure><h3 id="getpriority-setpriority"><a href="#getpriority-setpriority" class="headerlink" title="getpriority/setpriority"></a>getpriority/setpriority</h3><ul><li>스케줄링 조작 시스템콜을 기본 제공한다. (POSIX 기반)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p><code>which</code> 옵션</p><ul><li>프로세스(PRIO_PROCESS)</li><li>프로세스 그룹(PRIO_PGRP)</li><li>사용자(PRIO_USER)</li></ul><ul><li>root 소유로 우선순위변경 실행</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> which = PRIO_PROCESS;</span><br><span class="line"><span class="keyword">id_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">pid = <span class="built_in">getpid</span>();</span><br><span class="line">ret = <span class="built_in">getpriority</span>(which, pid); <span class="comment">// 프로세스 우선순위를 가져온다.</span></span><br><span class="line">ret = <span class="built_in">setpriority</span>(which, pid, <span class="number">5</span>); <span class="comment">//프로세스의 우선순위를 5로 설정</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜 함수를 직접 사용하면서 프로세스의 생성과 종료, 우선순위 관리까지 경험해본다.&lt;br&gt;&lt;code&gt;#fork&lt;/code&gt; &lt;code&gt;#exec&lt;/code&gt; &lt;code&gt;#wait&lt;/code&gt; &lt;code&gt;#COW&lt;/code&gt; &lt;code&gt;#exit&lt;/code&gt; &lt;code&gt;#nice&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="system_call" scheme="http://yoursite.com/tags/system-call/"/>
    
  </entry>
  
  <entry>
    <title>AWS-Docker,Jira 설치</title>
    <link href="http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/"/>
    <id>http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/</id>
    <published>2021-05-22T11:46:29.000Z</published>
    <updated>2021-05-25T00:54:42.539Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="AWS-인스턴스에서-Docker-설치"><a href="#AWS-인스턴스에서-Docker-설치" class="headerlink" title="AWS 인스턴스에서 Docker 설치"></a>AWS 인스턴스에서 Docker 설치</h1><ul><li>jira container 는 메모리를 많이 차지하기 때문에 AWS 인스턴스는 최소 <code>t2.larg</code> 로 선택해야 한다.<blockquote><p>$ sudo yum install docker-io</p></blockquote></li></ul><!-- [rectangle setX: 10 y: 10 width: 20 height: 20]; --><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -i suyeon.pem ec2-user@15.164.50.108</span></span><br><span class="line">The authenticity of host &#x27;15.164.50.108 (15.164.50.108)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:KwsFct4EwSLlShPOuWPC0yr0ewcI4lGT352J9tLKKwQ.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;15.164.50.108&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line"></span><br><span class="line">       __|  __|_  )</span><br><span class="line">       _|  (     /   Amazon Linux 2 AMI</span><br><span class="line">      ___|\___|___|</span><br><span class="line"></span><br><span class="line">https://aws.amazon.com/amazon-linux-2/</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ ^C</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker</span><br><span class="line">-bash: docker: command not found</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo yum install docker-io</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-ps-a-리스트-확인"><a href="#docker-ps-a-리스트-확인" class="headerlink" title="docker ps -a 리스트 확인"></a>docker ps -a 리스트 확인</h2><ul><li>Is the docker daemon running? : 도커를 실행해준다.</li><li><code>sudo systemctl start docker</code></li><li>dial unix /var/run/docker.sock: connect: permission denied : 권한 부여</li><li><code>sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo systemctl start docker</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/d</span><br><span class="line">dbus/               dhclient-eth0.pid   dmeventd-server     docker.pid</span><br><span class="line">dhclient6-eth0.pid  dmeventd-client     docker/             docker.sock</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</span><br></pre></td></tr></table></figure><ul><li>잘 실행된다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><hr><h1 id="Jira-협업툴-설치"><a href="#Jira-협업툴-설치" class="headerlink" title="Jira 협업툴 설치"></a>Jira 협업툴 설치</h1><ol><li>기존 지라 도커 컨테이너 삭제</li><li>지라 도커 컨테이너 설치<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull cptactionhank/atlassian-jira-software:latest</span></span><br></pre></td></tr></table></figure></li><li>지라 도커 컨테이너 생성</li></ol><ul><li>``<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker create --restart=no --name <span class="string">&quot;jira-container&quot;</span>\</span></span><br><span class="line"><span class="bash"> --publish <span class="string">&quot;8080:8080&quot;</span>\</span></span><br><span class="line"><span class="bash"> --volume <span class="string">&quot;hostpath:/var/atlassian/jira&quot;</span>\</span></span><br><span class="line"><span class="bash"> --env <span class="string">&quot;CATALINA_OPTS= -Xms1024m -Xmx1024m -Datlassian.plugins.enable.wait=300&quot;</span>\</span></span><br><span class="line"><span class="bash"> cptactionhank/atlassian-jira-software:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 0c8922efd3800885da4b46af5bc17e6804fc91b102e186dec61efa41e39f117d</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>지라 도커 컨테이너 실행<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS 에서 Jira와 Docker를 설치해보자.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ AWS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-AWS/"/>
    
    
  </entry>
  
  <entry>
    <title>📲 시스템콜과 API</title>
    <link href="http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/"/>
    <id>http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/</id>
    <published>2021-05-20T14:59:59.000Z</published>
    <updated>2021-05-25T00:54:42.546Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="시스템콜"><a href="#시스템콜" class="headerlink" title="시스템콜"></a>시스템콜</h1><ul><li>주요 시스템콜 명령어</li></ul><table><thead><tr><th>%eax</th><th>Kernel Function(System call)</th><th>%ebx</th><th>%ecx</th><th>%edx</th></tr></thead><tbody><tr><td>1</td><td>sys_exit(exit)</td><td>int</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork(fork)</td><td>struct pt_regs</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read(read)</td><td>unsigned int</td><td>char *</td><td>size_t</td></tr><tr><td>4</td><td>sys_write(write)</td><td>unsigned int</td><td>const char *</td><td>size_t</td></tr><tr><td>5</td><td>sys_open(open)</td><td>const char *</td><td>int</td><td>int</td></tr><tr><td>6</td><td>sys_close(clsoe)</td><td>unsigned int</td><td>-</td><td>-</td></tr></tbody></table><h2 id="시스템콜은-어떻게-구현"><a href="#시스템콜은-어떻게-구현" class="headerlink" title="시스템콜은 어떻게 구현?"></a>시스템콜은 어떻게 구현?</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0x04</span> <span class="comment">// 시스템콜 번호</span></span><br><span class="line">mov ebx, <span class="number">0x03</span> <span class="comment">// 인자값</span></span><br><span class="line">mov ecx, $buf</span><br><span class="line">mov edx, <span class="number">14</span>   <span class="comment">// 문자열 사이즈</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>      <span class="comment">// 소프트웨어 인터럽트 명령</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>레지스터</th><th>의미</th></tr></thead><tbody><tr><td>eax</td><td>산술 및 논리연산을 수행할 때 사용되며 함수의 반환값이 저장된다.</td></tr><tr><td>ebx</td><td>메모리 주소를 저장하기 위한 용도로 사용된다. 인자를 넣어준다.</td></tr><tr><td>ecx</td><td>반복 명령어 사용시 반복 카운터로 사용되는 레지스터이다.</td></tr><tr><td>edx</td><td>eax와 같이 쓰이며 부호 확장 명령등에 쓰이고 큰수의 곱셈, 나눗셈 등의 연산이 이루어질 때 사용된다.</td></tr><tr><td>int 0x80</td><td>소프트웨어 인터럽트 명령이다.</td></tr></tbody></table><hr><h1 id="C-컴파일러"><a href="#C-컴파일러" class="headerlink" title="C 컴파일러"></a>C 컴파일러</h1><ul><li>유닉스 C 컴파일러 <code>c</code></li><li>리눅스 C 컴파일러 -GNU cc- gcc</li><li>우분투 리눅스에 gcc설치</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">gcc --version</span><br><span class="line">gcc -o test.c test</span><br></pre></td></tr></table></figure><h2 id="컴파일-과정-전처리-컴파일-어셈블리-링크"><a href="#컴파일-과정-전처리-컴파일-어셈블리-링크" class="headerlink" title="컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)"></a>컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)</h2><blockquote><p>위 코드에서 <code>gcc -o test.c test</code> 를 수행할 때 발생하는 컴파일 과정이다.</p></blockquote><table><thead><tr><th>컴파일 과정</th><th>서술</th></tr></thead><tbody><tr><td>(1) 전처리기</td><td><code>cpp</code> 라는 전처리기를 사용한다.</td></tr><tr><td></td><td>전처리기가 #include 구문을 만나면 해당 <code>헤더 파일</code>을 찾아 그 내용을 순차적으로 삽입한다.</td></tr><tr><td></td><td>#define, #ifdef 같은 <code>매크로</code> 구문을 치환하고 처리한다.</td></tr><tr><td>(2) C컴파일러</td><td><code>ccl</code> 에 의해 <code>전단부</code>에서 소스코드를 어휘, 구문, 의미를 분석하고 중간코드를 생성한다.</td></tr><tr><td></td><td><code>중단부</code>에서 최적화를 거치고 <code>후단부</code>에서 <code>어셈블리 코드</code>를 생성한다.</td></tr><tr><td>(3) 어셈블러</td><td><code>as</code> 라는 어셈블러를 사용해 어셈블리 코드를 0과1의 기계어로 변환한다.</td></tr><tr><td></td><td>최종적으로 ELF 바이너리 포맷 구조를 갖는 <code>목적코드를 생성</code>한다.</td></tr><tr><td>(4) 링커</td><td><code>ld</code>라는 링커를 사용한다.</td></tr><tr><td></td><td>오브젝트 파일들과 프로그램에서 사용된 표준 C 라이브러리와 사용자 라이브러리를 링크한다.</td></tr><tr><td></td><td>이 과정을 통해 <code>실행파일</code>이 만들어진다.</td></tr></tbody></table><hr><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul><li>응용 프로그램과 분리된 <code>하위 호환 인터페이스</code></li><li>eg. 시스템콜 래퍼, 입출력 라이브러리 등</li><li>fork() 와 같은 시스템콜 함수 사용을 위해 사용자가 사용할 수 있는 함수들의 모음을 말한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process_fork()&#123;</span><br><span class="line">    fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="ABI-Application-Binary-Interface"><a href="#ABI-Application-Binary-Interface" class="headerlink" title="ABI (Application Binary Interface)"></a>ABI (Application Binary Interface)</h1><ul><li>응용 프로그램 바이너리 인터페이스</li><li>함수 실행방식, 레지스터 활용, 시스템콜 실행, 라이브러리 링크 방식 등</li><li>ABI가 호환되면 재컴파일 없이 동작한다. (ABI 표준)</li><li>리눅스에서 만든 프로그램을 리눅스에서 실행하지 못하는이유? ABI가 완벽하게 달라서이다.</li><li>컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공</li></ul><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><ul><li>유닉스 시스템 프로그래밍 인터페이스 표준</li><li>리차드 스톨만이 POSIX를 표준안 이름으로 제안</li><li>IEEE 에서 표준화 시도</li></ul><h2 id="C-언어-표준"><a href="#C-언어-표준" class="headerlink" title="C 언어 표준"></a>C 언어 표준</h2><ul><li>다양한 C 언어 변종이 존재한다.</li><li>ANSI 에서 <code>ANSI C</code> 표준을 정립했다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜의 수행과정, 컴파일 과정에 대해서도 알아본다.&lt;br&gt;API ? ABI ?&lt;br&gt;&lt;code&gt;#API&lt;/code&gt; &lt;code&gt;#ABI&lt;/code&gt; &lt;code&gt;#IDT&lt;/code&gt; &lt;code&gt;#system_call&lt;/code&gt; &lt;code&gt;#gcc&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="abi" scheme="http://yoursite.com/tags/abi/"/>
    
    <category term="system_call" scheme="http://yoursite.com/tags/system-call/"/>
    
    <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>🗯 리눅스 리다이렉션/파이프, 프로세스 관련 명령어</title>
    <link href="http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/"/>
    <id>http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/</id>
    <published>2021-05-19T12:34:46.000Z</published>
    <updated>2021-05-25T00:54:42.542Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="표준-입출력-Standard-Stream"><a href="#표준-입출력-Standard-Stream" class="headerlink" title="표준 입출력 (Standard Stream )"></a>표준 입출력 (Standard Stream )</h1><ul><li>command로 실행되는 프로세스는 세가지 스트림을 가지고 있다.</li><li>표준 입력 스트림 : stdin</li><li>표준 출력 스트림 : stdout</li><li>오류 출력 스트림 : stderr</li></ul><h1 id="리다이렉션-redirection"><a href="#리다이렉션-redirection" class="headerlink" title="리다이렉션 (redirection)"></a>리다이렉션 (redirection)</h1><ul><li>표준 스트림 흐름을 바꿔줄 수 있다.</li><li>‘&gt;’ , ‘&lt;’ 를 사용한다.</li><li>주로 명령어 표준 출력을 화면이 아닌 <code>파일</code>에 쓸때</li></ul><ul><li><p>아래와 같이 <code>ll</code>로 출력되는 메시지들이 file.txt 로 만들어진다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ll &gt; file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ vi file.txt</span><br></pre></td></tr></table></figure></li><li><p>혹은  <code>head</code> 명령어를 사용해, 방금 생성된 file.txt 의 앞에서부터 10줄만 file2.txt 로 새로 만들수 있다.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ head &lt; file.txt &gt; file2.txt</span><br></pre></td></tr></table></figure><h1 id="파이프-pipe"><a href="#파이프-pipe" class="headerlink" title="파이프 (pipe)"></a>파이프 (pipe)</h1><ul><li>두 프로세스 사이에서 한 프로세스의 출력 스트림을 또 다른 프로세스의 입력 스트림으로 사용할 때 사용함.</li></ul><ul><li><code>grep</code> 명령어로 가장 많이 사용된다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ls | grep file</span><br><span class="line">file.txt</span><br><span class="line">file2.txt</span><br></pre></td></tr></table></figure><h2 id="grep-명령어-옵션"><a href="#grep-명령어-옵션" class="headerlink" title="grep 명령어 옵션"></a>grep 명령어 옵션</h2></li></ul><ul><li><code>grep java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 모두 출력</li><li><code>grep -n java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>라인까지</code> 출력</li><li><code>grep -r java directory</code> : directory 내의 모든 파일 중 <code>java</code> 라는 문구가 포함된 행 출력</li><li><code>grep -i java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>대소문자 구분없이</code> 출력</li><li><code>grep -E python|java|ruby file.txt</code> : file.txt 내에서 <code>java</code>,<code>python</code>,<code>ruby</code> 라는 문구가 포함된 행을 출력</li></ul><h1 id="프로세스-vs-바이너리"><a href="#프로세스-vs-바이너리" class="headerlink" title="프로세스 vs 바이너리"></a>프로세스 vs 바이너리</h1><ul><li>코드 이미지 또는 바이너리: 실행파일</li><li>싫행중인 프로그램: 프로세스</li><li>가상 메모리 및 물리 메모리 정보</li><li>시스템 리소스 관련 정보</li><li>스케줄링 단위</li></ul><h1 id="다양한-프로세스-실행환경"><a href="#다양한-프로세스-실행환경" class="headerlink" title="다양한 프로세스 실행환경"></a>다양한 프로세스 실행환경</h1><ul><li>리눅스는 다양한 프로세스가 실행된다.<blockquote><p>유닉스 철학 : 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체 시스템이 동작하도록 하는 모델</p></blockquote></li></ul><h2 id="Foreground-Background-process"><a href="#Foreground-Background-process" class="headerlink" title="Foreground/Background process"></a>Foreground/Background process</h2><ul><li>foreground process: 쉘에서 해당 프로세스를 실행한 후, 해당 프로세스 수행 종료까지 다른 입력을 하지 못하는 프로세스</li><li>background process: 사용자 입력과 상관없이 실행되는 프로세스.</li><li>해당 프로세스 실행시, 맨 뒤에 <code>&amp;</code> 를 붙여주면 된다.</li></ul><ul><li>loop.c 라는 무한루프를 도는 프로그램을 간단히 만들어 테스트 해본다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="forground-process"><a href="#forground-process" class="headerlink" title="forground process"></a>forground process</h3><ul><li>sudo apt-get gcc: <code>gcc</code>는 C 프로그램을 컴파일해준다.</li><li><code>ctrl+C</code> 로 수행을 강제종료 할 때까지 명령어를 사용할 수 없다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ sudo apt-get gcc</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ gcc loop.c -o loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">`loop`  loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">dkfkslfjdldienfkajsdlkfjksjdlkfjaksldfjklsjgheihfodkjfklak</span><br><span class="line">dfasdfasd</span><br><span class="line">dsaf</span><br></pre></td></tr></table></figure></li></ul><h3 id="background-process"><a href="#background-process" class="headerlink" title="background process"></a>background process</h3><ul><li><code>&amp;</code> 를 붙여주면 된다.</li><li><code>[1] 32748</code> : <code>[1]</code>은 작업번호, <code>32748</code> 은 프로세스ID 를 나타낸다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop &amp;</span><br><span class="line">[1] 32748</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop</span><br><span class="line">loop    loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">        int i=1;</span><br><span class="line">        while(i==1)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$</span><br></pre></td></tr></table></figure><h3 id="jobs-명령어"><a href="#jobs-명령어" class="headerlink" title="jobs 명령어"></a>jobs 명령어</h3></li><li>백그라운드로 <code>진행</code> 또는 <code>중지</code>된 프로세스를 보여준다.</li><li>[CTRL]+Z : 프로세스를 중지상태로 변경</li><li><code>bg</code> : 맨 마지막 [CTRL]+Z 로 중지된 프로세스는 <code>bg</code> 명령으로 <code>background</code> 프로세스로 실행될 수 있다.</li><li>[CTRL]+C : 프로세스 작업취소(완전히 종료)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]+  Running                 ./loop &amp;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">^Z</span><br><span class="line">[2]+  Stopped                 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]-  Running                 ./loop &amp;</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure><h3 id="프로세스-상태-확인-ps-명령어"><a href="#프로세스-상태-확인-ps-명령어" class="headerlink" title="프로세스 상태 확인 ps 명령어"></a>프로세스 상태 확인 ps 명령어</h3><ul><li><p><code>ps [option]</code></p></li><li><p><code>-a</code>: 모든 사용자의 프로세스 출력.</p></li><li><p><code>-u</code>: 프로세스 소유자에대한 정보.</p></li><li><p><code>-l</code>: 프로세스 관련 상세정보.</p></li><li><p><code>-x</code>: 프로세스가 아닌 프로세스들도 출력한다. 주로 데몬 프로세스(사용자 모르게 시스템 관리를 위해 실행되는 프로세스)까지 확인하기 위해 사용한다.</p></li><li><p><code>-e</code>: 해당 프로세스와 관련된 환경변수 정보도 함께 출력.</p></li><li><p><code>-f</code>:</p></li><li><p><code>ps -aux</code> 명령 일부</p></li><li><p>USER: 프로세스를 실행시킨 사용자ID</p></li><li><p>%CPU: 마지막 1분동안 프로세스가 사용한 CPU시간의 백분율</p></li><li><p>%MEM: 마지막 1분동안 프로세스가 사용한 메모리 백분율</p></li><li><p>VSZ: 프로세스가 사용하는 가상 메모리크기</p></li><li><p>RSS: 프로세스에서 사용하는 실제 물리메모리</p></li><li><p>TTY : 하드웨어 리소스</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.8 159744  8672 ?        Ss   May17   0:04 /sbin/init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    May17   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_gp]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_par_gp]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [kworker/0:0H-kb]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [mm_percpu_wq]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S    May17   0:00 [ksoftirqd/0]</span><br><span class="line">root        11  0.0  0.0      0     0 ?        I    May17   0:00 [rcu_sched]</span><br><span class="line">root        12  0.0  0.0      0     0 ?        S    May17   0:01 [migration/0]</span><br><span class="line">root        13  0.0  0.0      0     0 ?        S    May17   0:00 [cpuhp/0]</span><br><span class="line">root        14  0.0  0.0      0     0 ?        S    May17   0:00 [kdevtmpfs]</span><br><span class="line">root        15  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [netns]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    May17   0:00 [rcu_tasks_kthre]</span><br><span class="line">root        17  0.0  0.0      0     0 ?        S    May17   0:00 [kauditd]</span><br><span class="line">root        18  0.0  0.0      0     0 ?        S    May17   0:00 [khungtaskd]</span><br></pre></td></tr></table></figure><h3 id="kill-명령"><a href="#kill-명령" class="headerlink" title="kill 명령"></a>kill 명령</h3><ul><li>아까 백그라운드에서 무한 루프를 돌리던 프로세스를 죽이기 위해서 사용한다.</li><li>kill 프로세스 ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu   32748 28829 99 14:11 pts/0    00:18:16 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ kill -9 32748</span><br><span class="line">[1]-  Killed                  ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;리눅스에서 리다이렉션과 파이프를 명령어와 함께 사용해본다.&lt;br&gt;background 와 foreground 프로세스에 대한 이해.&lt;br&gt;&lt;code&gt;#redirection&lt;/code&gt; &lt;code&gt;#pipe&lt;/code&gt; &lt;code&gt;#grep&lt;/code&gt; &lt;code&gt;#linux_process&lt;/code&gt; &lt;code&gt;#ps&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="pipe" scheme="http://yoursite.com/tags/pipe/"/>
    
    <category term="redirection" scheme="http://yoursite.com/tags/redirection/"/>
    
  </entry>
  
</feed>
