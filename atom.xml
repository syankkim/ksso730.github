<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>동글씨</title>
  
  <subtitle>동글씨의 LOG</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-25T00:54:42.549Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Suyan Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>프로세스ID</title>
    <link href="http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/"/>
    <id>http://yoursite.com/2021/05/24/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4ID/</id>
    <published>2021-05-24T13:24:11.000Z</published>
    <updated>2021-05-25T00:54:42.549Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h1><ul><li>생성과정<br>(1) TEXT, DATA, BSS, HEAP, STACK 의 공간을 생성한다.<br>(2) 프로세스 이미지를 해당 공간에 업로드하고 실행한다.</li></ul><h2 id="프로세스-소유자-관리"><a href="#프로세스-소유자-관리" class="headerlink" title="프로세스 소유자 관리"></a>프로세스 소유자 관리</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/shadow</span></span><br></pre></td></tr></table></figure><h2 id="시스템콜-함수-사용해보기"><a href="#시스템콜-함수-사용해보기" class="headerlink" title="시스템콜 함수 사용해보기"></a>시스템콜 함수 사용해보기</h2><h3 id="getpid-getppid-시스템콜"><a href="#getpid-getppid-시스템콜" class="headerlink" title="getpid() getppid() 시스템콜"></a>getpid() getppid() 시스템콜</h3><ul><li>getpid(), getppid() 함수를 사용하여 test_ps.c 프로그램 예시.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ppid=%d\n&quot;</span>, getppid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아래와 같이 <code>pid</code>, <code>ppid</code> 가 정상적으로 출력되는것을 확인할 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~/test$ gcc test_ps.c -o test_ps</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ls</span><br><span class="line">dir  loop.c  soft  soft_link  softlink  test_ps  test_ps.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~/test$ ./test_ps</span><br><span class="line">pid=14611</span><br><span class="line">ppid=14529</span><br></pre></td></tr></table></figure><h3 id="fork-exec-시스템콜"><a href="#fork-exec-시스템콜" class="headerlink" title="fork() exec() 시스템콜"></a>fork() exec() 시스템콜</h3><ul><li>fork() : 새로운 프로세스 공간을 별도로 만들고, fork() 를 호출한 프로세스(부모) 공간을 모두 <code>복사</code>한다.</li><li>헤더: <code>&lt;unistd.h&gt;</code></li><li>함수: <code>pid_t fork(void);</code></li><li>자식프로세스는 <code>pid=0</code>, 부모프로세스는 <code>실제 pid</code></li><li>pid= fork() 실행되면 부모 프로세스와 동일한 자식 프로세스를 <code>별도 메모리공간</code>에 생성한다.</li><li>두 프로세스의 변수, PC(Program Counter)값은 동일하다.</li></ul><ul><li>_fork.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before fork() call\n&quot;</span>);</span><br><span class="line"> <span class="comment">// -- 여기까지 프로세스는 1개</span></span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child Process&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>exec() : 호출한 현재 프로세스 공간의 <code>TEXT, DATA, BSS</code> 영역을 새로운 프로세스의 이미지로 <code>덮어씌운다</code>. 별도의 공간을 만들지 않는다.</p></li><li><p>헤더</p></li><li><p>함수 6가지</p></li><li><p>execlp : path 명 포함. </p></li></ul><ul><li>_execl.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;execute ls\n&quot;</span>);</span><br><span class="line">  execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// argv[0]=ls, argv[1]=-l</span></span><br><span class="line">  <span class="comment">// -- 기존의 &#x27;ls al&#x27; 의 기능이 덮어씌워진다.</span></span><br><span class="line">  perror(execl is failed\n);</span><br><span class="line">  <span class="comment">// - 에러코드 출력</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="wait-시스템콜"><a href="#wait-시스템콜" class="headerlink" title="wait() 시스템콜"></a>wait() 시스템콜</h3><ul><li>fork() 함수 호출시 자식 프로세스가 종료할 때까지 <code>부모 프로세스가 기다린다.</code></li><li>wait() 자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 먼저 죽는 경우를 막기 위해 사용한다. (고아 프로세스: 자식 프로세스가 메모리를 계속 사용하고 있을 수 있다.)</li><li>자식 프로세스의 일이 끝나면 부모 프로세스에 시그널을 보낸다. SIGCHL</li></ul><h3 id="fork-execl-wait-사용한-프로그램-만들기"><a href="#fork-execl-wait-사용한-프로그램-만들기" class="headerlink" title="fork(), execl(), wait() 사용한 프로그램 만들기"></a>fork(), execl(), wait() 사용한 프로그램 만들기</h3><ul><li>execl() 만 사용하면, 부모 프로세스가 사라진다.</li><li>이를 유지위해 fork() 로 새로운 공간 복사 후, execl() 사용.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜 함수로 직접 시스템 프로그래밍 해보기.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS-Docker,Jira 설치</title>
    <link href="http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/"/>
    <id>http://yoursite.com/2021/05/22/Docker-Jira-AWS-%EC%84%A4%EC%B9%98/</id>
    <published>2021-05-22T11:46:29.000Z</published>
    <updated>2021-05-25T00:54:42.539Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h1 id="AWS-인스턴스에서-Docker-설치"><a href="#AWS-인스턴스에서-Docker-설치" class="headerlink" title="AWS 인스턴스에서 Docker 설치"></a>AWS 인스턴스에서 Docker 설치</h1><ul><li>jira container 는 메모리를 많이 차지하기 때문에 AWS 인스턴스는 최소 <code>t2.larg</code> 로 선택해야 한다.<blockquote><p>$ sudo yum install docker-io</p></blockquote></li></ul><!-- [rectangle setX: 10 y: 10 width: 20 height: 20]; --><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -i suyeon.pem ec2-user@15.164.50.108</span></span><br><span class="line">The authenticity of host &#x27;15.164.50.108 (15.164.50.108)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:KwsFct4EwSLlShPOuWPC0yr0ewcI4lGT352J9tLKKwQ.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;15.164.50.108&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line"></span><br><span class="line">       __|  __|_  )</span><br><span class="line">       _|  (     /   Amazon Linux 2 AMI</span><br><span class="line">      ___|\___|___|</span><br><span class="line"></span><br><span class="line">https://aws.amazon.com/amazon-linux-2/</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ ^C</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker</span><br><span class="line">-bash: docker: command not found</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo yum install docker-io</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-ps-a-리스트-확인"><a href="#docker-ps-a-리스트-확인" class="headerlink" title="docker ps -a 리스트 확인"></a>docker ps -a 리스트 확인</h2><ul><li>Is the docker daemon running? : 도커를 실행해준다.</li><li><code>sudo systemctl start docker</code></li><li>dial unix /var/run/docker.sock: connect: permission denied : 권한 부여</li><li><code>sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo systemctl start docker</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/d</span><br><span class="line">dbus/               dhclient-eth0.pid   dmeventd-server     docker.pid</span><br><span class="line">dhclient6-eth0.pid  dmeventd-client     docker/             docker.sock</span><br><span class="line">[ec2-user@ip-172-31-36-132 ~]$ sudo setfacl -m user:ec2-user:rw /var/run/docker.sock</span><br></pre></td></tr></table></figure><ul><li>잘 실행된다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-36-132 ~]$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><hr><h1 id="Jira-협업툴-설치"><a href="#Jira-협업툴-설치" class="headerlink" title="Jira 협업툴 설치"></a>Jira 협업툴 설치</h1><ol><li>기존 지라 도커 컨테이너 삭제</li><li>지라 도커 컨테이너 설치<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull cptactionhank/atlassian-jira-software:latest</span></span><br></pre></td></tr></table></figure></li><li>지라 도커 컨테이너 생성</li></ol><ul><li>``<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker create --restart=no --name <span class="string">&quot;jira-container&quot;</span>\</span></span><br><span class="line"><span class="bash"> --publish <span class="string">&quot;8080:8080&quot;</span>\</span></span><br><span class="line"><span class="bash"> --volume <span class="string">&quot;hostpath:/var/atlassian/jira&quot;</span>\</span></span><br><span class="line"><span class="bash"> --env <span class="string">&quot;CATALINA_OPTS= -Xms1024m -Xmx1024m -Datlassian.plugins.enable.wait=300&quot;</span>\</span></span><br><span class="line"><span class="bash"> cptactionhank/atlassian-jira-software:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 0c8922efd3800885da4b46af5bc17e6804fc91b102e186dec61efa41e39f117d</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>지라 도커 컨테이너 실행<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS 에서 Jira와 Docker를 설치해보자.&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ AWS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-AWS/"/>
    
    
  </entry>
  
  <entry>
    <title>📲 시스템콜과 API</title>
    <link href="http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/"/>
    <id>http://yoursite.com/2021/05/20/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EA%B3%BC-API/</id>
    <published>2021-05-20T14:59:59.000Z</published>
    <updated>2021-05-25T00:54:42.546Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="시스템콜"><a href="#시스템콜" class="headerlink" title="시스템콜"></a>시스템콜</h1><ul><li>주요 시스템콜 명령어</li></ul><table><thead><tr><th>%eax</th><th>Kernel Function(System call)</th><th>%ebx</th><th>%ecx</th><th>%edx</th></tr></thead><tbody><tr><td>1</td><td>sys_exit(exit)</td><td>int</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork(fork)</td><td>struct pt_regs</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read(read)</td><td>unsigned int</td><td>char *</td><td>size_t</td></tr><tr><td>4</td><td>sys_write(write)</td><td>unsigned int</td><td>const char *</td><td>size_t</td></tr><tr><td>5</td><td>sys_open(open)</td><td>const char *</td><td>int</td><td>int</td></tr><tr><td>6</td><td>sys_close(clsoe)</td><td>unsigned int</td><td>-</td><td>-</td></tr></tbody></table><h2 id="시스템콜은-어떻게-구현"><a href="#시스템콜은-어떻게-구현" class="headerlink" title="시스템콜은 어떻게 구현?"></a>시스템콜은 어떻게 구현?</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0x04</span> <span class="comment">// 시스템콜 번호</span></span><br><span class="line">mov ebx, <span class="number">0x03</span> <span class="comment">// 인자값</span></span><br><span class="line">mov ecx, $buf</span><br><span class="line">mov edx, <span class="number">14</span>   <span class="comment">// 문자열 사이즈</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>      <span class="comment">// 소프트웨어 인터럽트 명령</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>레지스터</th><th>의미</th></tr></thead><tbody><tr><td>eax</td><td>산술 및 논리연산을 수행할 때 사용되며 함수의 반환값이 저장된다.</td></tr><tr><td>ebx</td><td>메모리 주소를 저장하기 위한 용도로 사용된다. 인자를 넣어준다.</td></tr><tr><td>ecx</td><td>반복 명령어 사용시 반복 카운터로 사용되는 레지스터이다.</td></tr><tr><td>edx</td><td>eax와 같이 쓰이며 부호 확장 명령등에 쓰이고 큰수의 곱셈, 나눗셈 등의 연산이 이루어질 때 사용된다.</td></tr><tr><td>int 0x80</td><td>소프트웨어 인터럽트 명령이다.</td></tr></tbody></table><hr><h1 id="C-컴파일러"><a href="#C-컴파일러" class="headerlink" title="C 컴파일러"></a>C 컴파일러</h1><ul><li>유닉스 C 컴파일러 <code>c</code></li><li>리눅스 C 컴파일러 -GNU cc- gcc</li><li>우분투 리눅스에 gcc설치</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">gcc --version</span><br><span class="line">gcc -o test.c test</span><br></pre></td></tr></table></figure><h2 id="컴파일-과정-전처리-컴파일-어셈블리-링크"><a href="#컴파일-과정-전처리-컴파일-어셈블리-링크" class="headerlink" title="컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)"></a>컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)</h2><blockquote><p>위 코드에서 <code>gcc -o test.c test</code> 를 수행할 때 발생하는 컴파일 과정이다.</p></blockquote><table><thead><tr><th>컴파일 과정</th><th>서술</th></tr></thead><tbody><tr><td>(1) 전처리기</td><td><code>cpp</code> 라는 전처리기를 사용한다.</td></tr><tr><td></td><td>전처리기가 #include 구문을 만나면 해당 <code>헤더 파일</code>을 찾아 그 내용을 순차적으로 삽입한다.</td></tr><tr><td></td><td>#define, #ifdef 같은 <code>매크로</code> 구문을 치환하고 처리한다.</td></tr><tr><td>(2) C컴파일러</td><td><code>ccl</code> 에 의해 <code>전단부</code>에서 소스코드를 어휘, 구문, 의미를 분석하고 중간코드를 생성한다.</td></tr><tr><td></td><td><code>중단부</code>에서 최적화를 거치고 <code>후단부</code>에서 <code>어셈블리 코드</code>를 생성한다.</td></tr><tr><td>(3) 어셈블러</td><td><code>as</code> 라는 어셈블러를 사용해 어셈블리 코드를 0과1의 기계어로 변환한다.</td></tr><tr><td></td><td>최종적으로 ELF 바이너리 포맷 구조를 갖는 <code>목적코드를 생성</code>한다.</td></tr><tr><td>(4) 링커</td><td><code>ld</code>라는 링커를 사용한다.</td></tr><tr><td></td><td>오브젝트 파일들과 프로그램에서 사용된 표준 C 라이브러리와 사용자 라이브러리를 링크한다.</td></tr><tr><td></td><td>이 과정을 통해 <code>실행파일</code>이 만들어진다.</td></tr></tbody></table><hr><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul><li>응용 프로그램과 분리된 <code>하위 호환 인터페이스</code></li><li>eg. 시스템콜 래퍼, 입출력 라이브러리 등</li><li>fork() 와 같은 시스템콜 함수 사용을 위해 사용자가 사용할 수 있는 함수들의 모음을 말한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process_fork()&#123;</span><br><span class="line">    fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="ABI-Application-Binary-Interface"><a href="#ABI-Application-Binary-Interface" class="headerlink" title="ABI (Application Binary Interface)"></a>ABI (Application Binary Interface)</h1><ul><li>응용 프로그램 바이너리 인터페이스</li><li>함수 실행방식, 레지스터 활용, 시스템콜 실행, 라이브러리 링크 방식 등</li><li>ABI가 호환되면 재컴파일 없이 동작한다. (ABI 표준)</li><li>리눅스에서 만든 프로그램을 리눅스에서 실행하지 못하는이유? ABI가 완벽하게 달라서이다.</li><li>컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공</li></ul><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><ul><li>유닉스 시스템 프로그래밍 인터페이스 표준</li><li>리차드 스톨만이 POSIX를 표준안 이름으로 제안</li><li>IEEE 에서 표준화 시도</li></ul><h2 id="C-언어-표준"><a href="#C-언어-표준" class="headerlink" title="C 언어 표준"></a>C 언어 표준</h2><ul><li>다양한 C 언어 변종이 존재한다.</li><li>ANSI 에서 <code>ANSI C</code> 표준을 정립했다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;시스템콜의 수행과정, 컴파일 과정에 대해서도 알아본다.&lt;br&gt;API ? ABI ?&lt;br&gt;&lt;code&gt;#API&lt;/code&gt; &lt;code&gt;#ABI&lt;/code&gt; &lt;code&gt;#IDT&lt;/code&gt; &lt;code&gt;#system_call&lt;/code&gt; &lt;code&gt;#gcc&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="abi" scheme="http://yoursite.com/tags/abi/"/>
    
    <category term="system_call" scheme="http://yoursite.com/tags/system-call/"/>
    
    <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>🗯 리눅스 리다이렉션/파이프, 프로세스 관련 명령어</title>
    <link href="http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/"/>
    <id>http://yoursite.com/2021/05/19/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A6%AC%EB%8B%A4%EB%A0%89%EC%85%98-%ED%8C%8C%EC%9D%B4%ED%94%84/</id>
    <published>2021-05-19T12:34:46.000Z</published>
    <updated>2021-05-25T00:54:42.542Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="표준-입출력-Standard-Stream"><a href="#표준-입출력-Standard-Stream" class="headerlink" title="표준 입출력 (Standard Stream )"></a>표준 입출력 (Standard Stream )</h1><ul><li>command로 실행되는 프로세스는 세가지 스트림을 가지고 있다.</li><li>표준 입력 스트림 : stdin</li><li>표준 출력 스트림 : stdout</li><li>오류 출력 스트림 : stderr</li></ul><h1 id="리다이렉션-redirection"><a href="#리다이렉션-redirection" class="headerlink" title="리다이렉션 (redirection)"></a>리다이렉션 (redirection)</h1><ul><li>표준 스트림 흐름을 바꿔줄 수 있다.</li><li>‘&gt;’ , ‘&lt;’ 를 사용한다.</li><li>주로 명령어 표준 출력을 화면이 아닌 <code>파일</code>에 쓸때</li></ul><ul><li><p>아래와 같이 <code>ll</code>로 출력되는 메시지들이 file.txt 로 만들어진다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ll &gt; file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">file.txt</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ vi file.txt</span><br></pre></td></tr></table></figure></li><li><p>혹은  <code>head</code> 명령어를 사용해, 방금 생성된 file.txt 의 앞에서부터 10줄만 file2.txt 로 새로 만들수 있다.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ head &lt; file.txt &gt; file2.txt</span><br></pre></td></tr></table></figure><h1 id="파이프-pipe"><a href="#파이프-pipe" class="headerlink" title="파이프 (pipe)"></a>파이프 (pipe)</h1><ul><li>두 프로세스 사이에서 한 프로세스의 출력 스트림을 또 다른 프로세스의 입력 스트림으로 사용할 때 사용함.</li></ul><ul><li><code>grep</code> 명령어로 가장 많이 사용된다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ls | grep file</span><br><span class="line">file.txt</span><br><span class="line">file2.txt</span><br></pre></td></tr></table></figure><h2 id="grep-명령어-옵션"><a href="#grep-명령어-옵션" class="headerlink" title="grep 명령어 옵션"></a>grep 명령어 옵션</h2></li></ul><ul><li><code>grep java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 모두 출력</li><li><code>grep -n java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>라인까지</code> 출력</li><li><code>grep -r java directory</code> : directory 내의 모든 파일 중 <code>java</code> 라는 문구가 포함된 행 출력</li><li><code>grep -i java file.txt</code> : file.txt 내에서 <code>java</code> 라는 문구가 포함된 행을 <code>대소문자 구분없이</code> 출력</li><li><code>grep -E python|java|ruby file.txt</code> : file.txt 내에서 <code>java</code>,<code>python</code>,<code>ruby</code> 라는 문구가 포함된 행을 출력</li></ul><h1 id="프로세스-vs-바이너리"><a href="#프로세스-vs-바이너리" class="headerlink" title="프로세스 vs 바이너리"></a>프로세스 vs 바이너리</h1><ul><li>코드 이미지 또는 바이너리: 실행파일</li><li>싫행중인 프로그램: 프로세스</li><li>가상 메모리 및 물리 메모리 정보</li><li>시스템 리소스 관련 정보</li><li>스케줄링 단위</li></ul><h1 id="다양한-프로세스-실행환경"><a href="#다양한-프로세스-실행환경" class="headerlink" title="다양한 프로세스 실행환경"></a>다양한 프로세스 실행환경</h1><ul><li>리눅스는 다양한 프로세스가 실행된다.<blockquote><p>유닉스 철학 : 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체 시스템이 동작하도록 하는 모델</p></blockquote></li></ul><h2 id="Foreground-Background-process"><a href="#Foreground-Background-process" class="headerlink" title="Foreground/Background process"></a>Foreground/Background process</h2><ul><li>foreground process: 쉘에서 해당 프로세스를 실행한 후, 해당 프로세스 수행 종료까지 다른 입력을 하지 못하는 프로세스</li><li>background process: 사용자 입력과 상관없이 실행되는 프로세스.</li><li>해당 프로세스 실행시, 맨 뒤에 <code>&amp;</code> 를 붙여주면 된다.</li></ul><ul><li>loop.c 라는 무한루프를 도는 프로그램을 간단히 만들어 테스트 해본다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="forground-process"><a href="#forground-process" class="headerlink" title="forground process"></a>forground process</h3><ul><li>sudo apt-get gcc: <code>gcc</code>는 C 프로그램을 컴파일해준다.</li><li><code>ctrl+C</code> 로 수행을 강제종료 할 때까지 명령어를 사용할 수 없다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ sudo apt-get gcc</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ gcc loop.c -o loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ls</span><br><span class="line">`loop`  loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">dkfkslfjdldienfkajsdlkfjksjdlkfjaksldfjklsjgheihfodkjfklak</span><br><span class="line">dfasdfasd</span><br><span class="line">dsaf</span><br></pre></td></tr></table></figure></li></ul><h3 id="background-process"><a href="#background-process" class="headerlink" title="background process"></a>background process</h3><ul><li><code>&amp;</code> 를 붙여주면 된다.</li><li><code>[1] 32748</code> : <code>[1]</code>은 작업번호, <code>32748</code> 은 프로세스ID 를 나타낸다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop &amp;</span><br><span class="line">[1] 32748</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop</span><br><span class="line">loop    loop.c</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ cat loop.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">        int i=1;</span><br><span class="line">        while(i==1)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$</span><br></pre></td></tr></table></figure><h3 id="jobs-명령어"><a href="#jobs-명령어" class="headerlink" title="jobs 명령어"></a>jobs 명령어</h3></li><li>백그라운드로 <code>진행</code> 또는 <code>중지</code>된 프로세스를 보여준다.</li><li>[CTRL]+Z : 프로세스를 중지상태로 변경</li><li><code>bg</code> : 맨 마지막 [CTRL]+Z 로 중지된 프로세스는 <code>bg</code> 명령으로 <code>background</code> 프로세스로 실행될 수 있다.</li><li>[CTRL]+C : 프로세스 작업취소(완전히 종료)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]+  Running                 ./loop &amp;</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ ./loop</span><br><span class="line">^Z</span><br><span class="line">[2]+  Stopped                 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[1]-  Running                 ./loop &amp;</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure><h3 id="프로세스-상태-확인-ps-명령어"><a href="#프로세스-상태-확인-ps-명령어" class="headerlink" title="프로세스 상태 확인 ps 명령어"></a>프로세스 상태 확인 ps 명령어</h3><ul><li><p><code>ps [option]</code></p></li><li><p><code>-a</code>: 모든 사용자의 프로세스 출력.</p></li><li><p><code>-u</code>: 프로세스 소유자에대한 정보.</p></li><li><p><code>-l</code>: 프로세스 관련 상세정보.</p></li><li><p><code>-x</code>: 프로세스가 아닌 프로세스들도 출력한다. 주로 데몬 프로세스(사용자 모르게 시스템 관리를 위해 실행되는 프로세스)까지 확인하기 위해 사용한다.</p></li><li><p><code>-e</code>: 해당 프로세스와 관련된 환경변수 정보도 함께 출력.</p></li><li><p><code>-f</code>:</p></li><li><p><code>ps -aux</code> 명령 일부</p></li><li><p>USER: 프로세스를 실행시킨 사용자ID</p></li><li><p>%CPU: 마지막 1분동안 프로세스가 사용한 CPU시간의 백분율</p></li><li><p>%MEM: 마지막 1분동안 프로세스가 사용한 메모리 백분율</p></li><li><p>VSZ: 프로세스가 사용하는 가상 메모리크기</p></li><li><p>RSS: 프로세스에서 사용하는 실제 물리메모리</p></li><li><p>TTY : 하드웨어 리소스</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.8 159744  8672 ?        Ss   May17   0:04 /sbin/init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    May17   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_gp]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [rcu_par_gp]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [kworker/0:0H-kb]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [mm_percpu_wq]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S    May17   0:00 [ksoftirqd/0]</span><br><span class="line">root        11  0.0  0.0      0     0 ?        I    May17   0:00 [rcu_sched]</span><br><span class="line">root        12  0.0  0.0      0     0 ?        S    May17   0:01 [migration/0]</span><br><span class="line">root        13  0.0  0.0      0     0 ?        S    May17   0:00 [cpuhp/0]</span><br><span class="line">root        14  0.0  0.0      0     0 ?        S    May17   0:00 [kdevtmpfs]</span><br><span class="line">root        15  0.0  0.0      0     0 ?        I&lt;   May17   0:00 [netns]</span><br><span class="line">root        16  0.0  0.0      0     0 ?        S    May17   0:00 [rcu_tasks_kthre]</span><br><span class="line">root        17  0.0  0.0      0     0 ?        S    May17   0:00 [kauditd]</span><br><span class="line">root        18  0.0  0.0      0     0 ?        S    May17   0:00 [khungtaskd]</span><br></pre></td></tr></table></figure><h3 id="kill-명령"><a href="#kill-명령" class="headerlink" title="kill 명령"></a>kill 명령</h3><ul><li>아까 백그라운드에서 무한 루프를 돌리던 프로세스를 죽이기 위해서 사용한다.</li><li>kill 프로세스 ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu   32748 28829 99 14:11 pts/0    00:18:16 ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ kill -9 32748</span><br><span class="line">[1]-  Killed                  ./loop</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ jobs</span><br><span class="line">[2]+  Stopped                 ./loop</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;리눅스에서 리다이렉션과 파이프를 명령어와 함께 사용해본다.&lt;br&gt;background 와 foreground 프로세스에 대한 이해.&lt;br&gt;&lt;code&gt;#redirection&lt;/code&gt; &lt;code&gt;#pipe&lt;/code&gt; &lt;code&gt;#grep&lt;/code&gt; &lt;code&gt;#linux_process&lt;/code&gt; &lt;code&gt;#ps&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="pipe" scheme="http://yoursite.com/tags/pipe/"/>
    
    <category term="redirection" scheme="http://yoursite.com/tags/redirection/"/>
    
  </entry>
  
  <entry>
    <title>🗯 리눅스서버EC2, 리눅스 기본</title>
    <link href="http://yoursite.com/2021/05/18/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%84%9C%EB%B2%84EC2/"/>
    <id>http://yoursite.com/2021/05/18/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%84%9C%EB%B2%84EC2/</id>
    <published>2021-05-17T15:01:58.000Z</published>
    <updated>2021-05-25T00:54:42.544Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="리눅스-배포판-패키지"><a href="#리눅스-배포판-패키지" class="headerlink" title="리눅스 배포판(패키지)"></a>리눅스 배포판(패키지)</h1><ul><li>리눅스 커널 및 다양한 소프트웨어 패키지를 묶어서 배포하는것</li><li>리눅스 배포판(패키지)</li></ul><h2 id="리눅스-배포판-비교-GNU-Ubuntuk-CentOS-RedHat"><a href="#리눅스-배포판-비교-GNU-Ubuntuk-CentOS-RedHat" class="headerlink" title="리눅스 배포판 비교 (GNU, Ubuntuk, CentOS, RedHat)"></a>리눅스 배포판 비교 (GNU, Ubuntuk, CentOS, RedHat)</h2><table><thead><tr><th>종류</th><th>설명</th></tr></thead><tbody><tr><td>Debian GNU</td><td>데비안은 <code>무료 오픈소스 소프트웨어</code>로만 구성된 운영체제이다. 패키지 업데이트나 의존성 및 보안관련 업데이트를 자동으로 수행하여 <code>관리가 편리</code>하다. 안정성과 보안에 중점을 두어 다른 리눅스 배포판들의 기반으로 사용되고 있다. 다만 <code>설정이 어려워</code> 초보자에게는 권장되지 않는다.</td></tr><tr><td>Ubuntu</td><td>데비안에 기초한 운영체제로서 <code>유니티라는 독자적인 데스크톱 환경</code>을 제공한다. 업데이트 주기는 일년에 총 두번으로 짧다. 처음 접하는 사람들도 <code>쉽게 설치</code>가 가능하다. 개인용 데스크톱에서 많이 사용하지만, 현재는 모바일, 웹서버, 클라우드, 가상서버 등 다양한 형태로 지원하고 있다.</td></tr><tr><td>CentOS</td><td>유료버전인 <code>RHEL의 복제판</code>으로 레드햇에서 상표권을 배제하고 배포된 리눅스이다. 모든 패키지나 기능이 RHEL과 같고 <code>무료</code>로 사용할 수 있다.  하지만 RHEL처럼 사후 기술지원이나 서비스를 받을 수는 없다.</td></tr><tr><td>RedHat</td><td><code>쉬운 설치</code>와 <code>독자적인 패키지 관리</code>가 가능하기 때문에 현업에서 가장 널리 사용되는 운영체제이다.  GUI와 RPM,YUM 같은 패키지 관리 도구를  제공하여 <code>초보자들도 쉽게 설치</code>할 수 있다. 현재는 레드햇 엔터프라이즈 리눅스(RHEL) 만 의미하며, 유료 배포판으로 업데이트를 지원하고 있다.</td></tr></tbody></table><h1 id="클라우드-컴퓨팅-설정-방법-with-AWS"><a href="#클라우드-컴퓨팅-설정-방법-with-AWS" class="headerlink" title="클라우드 컴퓨팅 설정 방법 with AWS"></a>클라우드 컴퓨팅 설정 방법 with AWS</h1><ul><li>AWS 계정이 없다면, 만들어야 한다.</li></ul><h2 id="EC2-또는-인스턴스-서버-생성"><a href="#EC2-또는-인스턴스-서버-생성" class="headerlink" title="EC2 또는 인스턴스(서버) 생성"></a>EC2 또는 인스턴스(서버) 생성</h2><ul><li>인스턴스 서버를 생성하면 마지막에 <code>키페어</code> (.pem) 를 생성할 수 있다. 잘 저장해둔다.</li></ul><img width="1242" alt="aws_01" src="https://user-images.githubusercontent.com/28856435/118682817-bdb0e480-b83b-11eb-9915-0dc33531741b.PNG"><br><h2 id="Elastic-IP-탄력적-IP-생성"><a href="#Elastic-IP-탄력적-IP-생성" class="headerlink" title="Elastic IP(탄력적 IP)생성"></a>Elastic IP(탄력적 IP)생성</h2><ul><li>고정IP/동적IP</li><li>탄력적 IP 를 생성하고, 인스턴스와 연결까지 해주어야 성공.</li></ul> <img width="836" alt="aws_02" src="https://user-images.githubusercontent.com/28856435/118682878-cdc8c400-b83b-11eb-8339-8d4e4d683dba.PNG"><br><h2 id="자기-PC-클라이언트-에서-EC2-서버-접속"><a href="#자기-PC-클라이언트-에서-EC2-서버-접속" class="headerlink" title="자기 PC(클라이언트) 에서 EC2(서버) 접속"></a>자기 PC(클라이언트) 에서 EC2(서버) 접속</h2><ul><li>인스턴스를 생성할 때 다운 받은 <code>.pem</code> 파일을 시작하기 원하는 위치에 둔다.</li><li><code>.pem</code> 이 있는 위치에서 <code>ssh -i &#123;.pem 파일&#125; &#123;ubuntu@고정IP&#125;</code> 수행.</li><li>eg. <code>ssh -i suyeon.pem  ubuntu@3.34.112.149</code></li><li>권한문제는 <code>chmod 400 suyeon.pem</code></li></ul><ul><li>아래와 같이 <code>ubuntu@ip-172-31-42-223:~$</code> 서버 AWS 서버접속이 되는것을 볼 수 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 400 suyeon.pem</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">total 4</span><br><span class="line">-r--r--r-- 1 SUYEON 197609 1700  5월 18 00:23 suyeon.pem</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="bash">$ ssh -i suyeon.pem  ubuntu@3.34.112.149</span></span><br><span class="line">The authenticity of host &#x27;3.34.112.149 (3.34.112.149)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:u5P/Pib6W0sp1nNLTvMtbweg4qAibDzeqtC6T5EVWWg.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;3.34.112.149&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1045-aws x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Mon May 17 15:29:10 UTC 2021</span><br><span class="line"></span><br><span class="line">  System load:  0.0               Processes:           94</span><br><span class="line">  Usage of /:   3.9% of 29.02GB   Users logged in:     0</span><br><span class="line">  Memory usage: 19%               IP address for eth0: 172.31.42.223</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line">0 packages can be updated.</span><br><span class="line">0 of these updates are security updates.</span><br><span class="line"></span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br><span class="line"></span><br><span class="line">ubuntu@ip-172-31-42-223:~$</span><br></pre></td></tr></table></figure><hr><h1 id="리눅스-기본-구성"><a href="#리눅스-기본-구성" class="headerlink" title="리눅스 기본 구성"></a>리눅스 기본 구성</h1><h2 id="리눅스-파일"><a href="#리눅스-파일" class="headerlink" title="리눅스 파일"></a>리눅스 파일</h2><ul><li>모든것은 파일이라는 철학을 따른다.</li><li>모든 인터렉션은 read / write</li><li>마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다.</li><li>파일 네임스페이스</li><li>전역 네임스페이스를 사용한다.<ul><li>eg. /tomcat/ows/driver.txt</li></ul></li></ul><h2 id="리눅스-프로세스"><a href="#리눅스-프로세스" class="headerlink" title="리눅스 프로세스"></a>리눅스 프로세스</h2><ul><li>리눅스 실행 파일 포멧 - <code>ELF</code> (Executable and Linkable Format)<ul><li>콜스택, 코드 (텍스트), 데이터 및 BSS 섹션 등</li></ul></li><li>다양한 시스템 리소스와 관련되어 있다. (시스템콜 기반.)<ul><li>타이머, 시그널, 파일, 네트워크, 디바이스, IPC 기법</li></ul></li><li><code>가상 메모리</code>를 지원한다.</li><li>각 프로세스는 <code>pid</code>(프로세스 ID) 고유값으로 구분되어 있다.</li><li><code>init 프로세스</code>(첫번째 프로세스) 를 기반으로 <code>fork()</code> 시스템콜을 사용해서 신규 프로세스가 생성되는 방식이다.</li></ul><h2 id="리눅스-권한"><a href="#리눅스-권한" class="headerlink" title="리눅스 권한"></a>리눅스 권한</h2><ul><li>운영체제는 사용자/리소스 권한을 관리한다.</li><li>리눅스는 사용자/그룹으로 권한을 관리한다.</li><li>root 는 슈퍼관리자이다.</li><li>파일마다 소유자, 소유자  그룹, 모든 사용자에 대해 읽기/쓰기/실행 권한을 관리한다. (rwx)</li><li>접근 권한 정보는 inode 의 자료구조에 저장된다.<br><a href="#ls-%EB%AA%85%EB%A0%B9%EC%96%B4">리눅스 권한 예시👆</a></li></ul><h2 id="리눅스-파일-종류"><a href="#리눅스-파일-종류" class="headerlink" title="리눅스 파일 종류"></a>리눅스 파일 종류</h2><ol><li>디렉토리<ul><li>하나의 파일로, 상위 디렉토리 파일에 등록되어 있다.</li></ul></li><li>일반파일<ul><li>스트림 파일</li></ul></li><li>특수 파일<ul><li>장치파일 (Device file)</li><li>블록 장치(특수)파일, 캐릭터 장치(특수)파일</li><li>파이프</li><li>소켓</li></ul></li></ol><blockquote><p><strong>블록 장치 파일</strong><br>보통 파일 read/write 요청이 있으면 커널에 전달되어 파일스트림 드라이버에 의해 처리된다. 반면에 장치파일은 요청이 그 장치의 드라이버에 의해서 처리되며, 하드디스크, CD/DVD 등의 저장 장치 파일들이다. <code>블록단위</code>로 입출력을 수행한다.<br><strong>캐릭터 장치 파일</strong><br>터미널, 프린터, 키보드 등의 문자 기반 장치 파일을 의미한다. I/O 버퍼를 사용하지 않으며 <code>바이트 단위</code>의 입출력만 수행한다.<br><strong>파이프 파일</strong><br>특정 프로그램의 출력을 중간 파일을 거치지 않고 다른 파일의 입력으로 보내는 파일을 의미한다. <code>FIFO</code> 방식으로 처리된다.<br><strong>소켓 파일</strong><br>네트워크의 입출력을 담당하는 API(Application Program Interface) 로, 물리적인 두 호스트 컴퓨터 간의 데이터를 송수신 할 때 사용하는 논리적인 소프트웨어 장치파일이다.</p></blockquote><hr><h1 id="쉘-shell-이란"><a href="#쉘-shell-이란" class="headerlink" title="쉘(shell) 이란?"></a>쉘(shell) 이란?</h1><ul><li>사용자와 운영체제간 인터페이스이다.</li><li>사용자의 명령을 해석해서 커널에 명령을 요청한다.</li><li>관련된 시스템콜을 사용해서 프로그램이 작성되어 있다.</li></ul><h2 id="쉘의-종류"><a href="#쉘의-종류" class="headerlink" title="쉘의 종류"></a>쉘의 종류</h2><ul><li>Bourne-Again Shell (bash): GNU 프로젝트의 일환으로 개발되었다.</li></ul><h2 id="다중-사용자를-지원하는-시스템"><a href="#다중-사용자를-지원하는-시스템" class="headerlink" title="다중 사용자를 지원하는 시스템"></a>다중 사용자를 지원하는 시스템</h2><ul><li>다중 사용자 관련 명령어는 어떤것이 있을까?</li></ul><h3 id="sudo-명령어"><a href="#sudo-명령어" class="headerlink" title="sudo 명령어"></a>sudo 명령어</h3><ul><li>/etc/sudors 설정 파일에서 설정을 변경할 수 있다.</li></ul><ul><li>아래와 같이 내가 만드려는 사용자를 <code>root</code> 아래에 추가해준다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">suyn    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><ul><li><p><code>root</code> 권한으로 <code>adduser</code> 명령어를 사용해 새로운 사용자를 생성한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ adduser suyn</span><br><span class="line">adduser: Only root may add a user or group to the system.</span><br><span class="line"></span><br><span class="line">ubuntu@ip-172-31-42-223:~$ sudo adduser suyn</span><br><span class="line">Adding user `suyn&#x27; ...</span><br><span class="line">Adding new group `suyn&#x27; (1001) ...</span><br><span class="line">Adding new user `suyn&#x27; (1001) with group `suyn&#x27; ...</span><br><span class="line">Creating home directory `/home/suyn&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for suyn</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">ubuntu@ip-172-31-42-223:~$ sudo passwd suyn</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>생성한 <code>suyn</code> 유저로 전환</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ su - suyn</span><br><span class="line">Password:</span><br><span class="line">suyn@ip-172-31-42-223:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="ls-명령어"><a href="#ls-명령어" class="headerlink" title="ls 명령어"></a>ls 명령어</h3><ul><li><code>al</code> 옵션을 주면 숨김파일 까지 조회할 수 있다.</li><li>파일 권한</li><li>파일마다 소유자, 소유자그룹, 모든 사용자에대해 권한을 설정할 수 있다.</li><li><code>drwxr-xr-x</code><ul><li>d : directory 를 나타냄. <a href="#%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%A2%85%EB%A5%98">리눅스 파일종류👆</a></li><li>rwx 소유자는 rwx 가능</li><li>r-x 그룹은 rx 가능</li><li>r-x 모든 사용자는 rx 가능</li></ul></li><li>소유자 접근 권한 정보는 <code>inode</code> 에 저장되어 있다.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:~$ ls -al</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 5 ubuntu ubuntu 4096 May 18 15:40 .</span><br><span class="line">drwxr-xr-x 4 root   root   4096 May 18 15:20 ..</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu  220 Apr  4  2018 .bash_logout</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu 3771 Apr  4  2018 .bashrc</span><br><span class="line">drwx------ 2 ubuntu ubuntu 4096 May 17 15:29 .cache</span><br><span class="line">drwx------ 3 ubuntu ubuntu 4096 May 17 15:29 .gnupg</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu  807 Apr  4  2018 .profile</span><br><span class="line">drwx------ 2 ubuntu ubuntu 4096 May 17 15:24 .ssh</span><br><span class="line">-rw-r--r-- 1 ubuntu ubuntu    0 May 18 15:19 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 ubuntu ubuntu 2106 May 18 15:40 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>[다시한번 짚고가기] <strong>슈퍼블록 &amp; inode</strong></p><ul><li><code>슈퍼블록</code>은 파일 시스템의 정보를 담고있다.<ul><li>SUPER_BLOCK [ [fileA] [fileB] ] 이런식이다.</li></ul></li><li>inode 는 파일이름마다 <code>inode 고유값</code>이 매칭되며 <code>자료구조</code> 형식으로 관리된다. 또한, inode를 기반의 메타정보(파일권한, 소유자정보, 파일사이즈, 생성시간 등)를 담고있다. 파일 시스템에서는 inode 기반으로 파일에 엑세스한다.<ul><li>SUPER_BLOCK [ [fileA:inode] [fileB:inode] ] 이런식이다.</li></ul></li></ul></blockquote><h3 id="ln-명령어"><a href="#ln-명령어" class="headerlink" title="ln 명령어"></a>ln 명령어</h3><ul><li>하드링크 : 기존파일의 inode 는 동일하다.</li><li><code>cp</code> 명령어는 물리적인 공간이 늘어나는 반면에, 하드링크는 동일한 inode 를 사용하되 포인터만 늘어난다고 생각하면 된다. (전체 파일 용량은 달라지지 않는다.)</li><li>심볼릭 링크 (소프트링크)</li><li>inode 가 바뀐다. 기존 파일의 위치가 바뀌거나 파일이 삭제되면 소프트링크에 접근할 수 없게된다.</li></ul><ul><li><p>하드링크 예시</p><ul><li>아래 코드에서 inode 값을 확인! a.txt 와 a_link 의 inode 값은 동일하다.<br><code>256239</code> -rw-rw-r– 2 ubuntu ubuntu 6 May 20 08:39 a.txt<br><code>256239</code> -rw-rw-r– 2 ubuntu ubuntu 6 May 20 08:39 a_link.txt<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ cat a.txt</span><br><span class="line">asdfg</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ln a.txt a_link.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ls -ali *.txt</span><br><span class="line">256239 -rw-rw-r-- 2 ubuntu ubuntu 6 May 20 08:39 a.txt</span><br><span class="line">256239 -rw-rw-r-- 2 ubuntu ubuntu 6 May 20 08:39 a_link.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>소프트링크 예시</p><ul><li>아래 코드에서 inode 값을 확인! a.txt 와 a_link.txt 의 inode 값은 다르다.<br><code>256241</code> -rw-rw-r– 1 ubuntu ubuntu 9 May 20 08:54 b.txt<br><code>256238</code> lrwxrwxrwx 1 ubuntu ubuntu 5 May 20 08:55 b_link.txt -&gt; b.txt<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-33-123:~$ cat b.txt</span><br><span class="line">softlink</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ln -s b.txt b_link.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ ls -ali b*</span><br><span class="line">256241 -rw-rw-r-- 1 ubuntu ubuntu 9 May 20 08:54 b.txt</span><br><span class="line">256238 lrwxrwxrwx 1 ubuntu ubuntu 5 May 20 08:55 b_link.txt -&gt; b.txt</span><br><span class="line">ubuntu@ip-172-31-33-123:~$ cat b_link.txt</span><br><span class="line">softlink</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;클라우드 컴퓨팅 환경에서 서버를 실행해보자. with AWS&lt;br&gt;리눅스 파일종류와 쉘(shell), 소프트링크/하드링크&lt;br&gt;&lt;code&gt;#EC2&lt;/code&gt; &lt;code&gt;#shell&lt;/code&gt; &lt;code&gt;#Linux&lt;/code&gt; &lt;code&gt;#hardlink&lt;/code&gt; &lt;code&gt;#softlink&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Linux" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Linux/"/>
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>💻 부팅의 이해</title>
    <link href="http://yoursite.com/2021/05/15/%EB%B6%80%ED%8C%85%EC%9D%98-%EC%9D%B4%ED%95%B4/"/>
    <id>http://yoursite.com/2021/05/15/%EB%B6%80%ED%8C%85%EC%9D%98-%EC%9D%B4%ED%95%B4/</id>
    <published>2021-05-15T12:59:56.000Z</published>
    <updated>2021-05-20T01:06:40.835Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><ul><li>컴퓨터를 켜서 동작시키는 절차를 말한다.</li><li>BIOS 가 특정 Storage 를 Memory 에 읽어와 bootstrap loader 를 메모리에 올리고 실행한다.</li><li>bootstrap loader 프로그램이 있는곳을 찾아서 실행시킨다.</li></ul><ol><li><code>CPU &gt; ROM-BIOS(특별한RAM: 컴퓨터가 종료되어도 메모리 기억)</code></li></ol><ul><li>CPU 가 BIOS 에서 매핑된 Memory 주소를 찾는다.</li></ul><ol start="2"><li><code>BIOS -&gt; Memory (RAM)</code></li></ol><ul><li>BIOS 프로그램을 Memory 에 올린다.</li><li>BIOS 는 컴퓨터를 초기화한다.</li></ul><ol start="3"><li><code>Memory &lt;-&gt; MBR(Master Boot Record ;저장매체)</code></li></ol><ul><li>부트로더 라는 프로그램을 로드한다.</li><li>부트로더에는 파티션 table 정보가 있다. (C:/, D:/)</li><li>어떤 파티션이 메인 파티션인지 확인.</li></ul><ol start="4"><li><code>Memory &lt;-&gt; 부트섹터(저장매체)</code></li></ol><ul><li>해당 메인 파티션에 들어가있는 특정 부트섹터 영역의 부트 코드를 로드한다.</li></ul><ol start="5"><li><code>Memory &lt;-&gt; 커널 이미지(저장매체)</code></li></ol><ul><li>부트 코드까지 Memory 에 올라가면 커널로부터 운영체제 이미지를 가져온다.</li></ul><ol start="6"><li>컴퓨터가 실행된다. </li></ol><br><img width="972" alt="부팅과정" src="https://user-images.githubusercontent.com/28856435/118362451-85ef3600-b5ca-11eb-9f56-c2f281b47f1e.PNG"><h1 id="실제-운영체제"><a href="#실제-운영체제" class="headerlink" title="실제 운영체제"></a>실제 운영체제</h1><ul><li>리눅스 운영체제</li></ul><ol><li>process management</li></ol><ul><li>응용프로그램은 여러개의 process로 관리.</li><li>프로세스 스케줄러: 프로세스 실행/종료 및 인터럽트 처리 관리.</li></ul><ol start="2"><li>memory management</li></ol><ul><li>가상메모리. page 기반 메모리 관리.</li></ul><ol start="3"><li>IO device management</li></ol><ul><li>VFS (Virsual File System)    - 가상 파일 시스템 인터페이스 사용</li><li>fild, Device drivers, Network 관리</li></ul><h2 id="시스템-프로그램"><a href="#시스템-프로그램" class="headerlink" title="시스템 프로그램"></a>시스템 프로그램</h2><ul><li>bash(bourne-again shell)</li><li>내부는 시스템콜을 호출하도록 구현</li><li>필요시 해당 운영체제의 시스템콜을 호출. (라이브러리-시스템콜)</li></ul><blockquote><ul><li><strong>안드로이드 스마트폰</strong><ul><li>Linux Kernel + Android Framework</li><li>리눅스OS 기반으로 안드로이드 플랫폼이 존재한다. </li></ul></li><li><strong>IoT</strong></li></ul><ul><li>IoT 관련 OS 의 경우 기능을 최소화 한다. (Tiny OS : 멀티태스킹, 보호모드, 가상메모리, 파일시스템 사용하지 않는다.)</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;부팅은 무엇이고, 실제로 어떻게 일어날까?&lt;br&gt;&lt;code&gt;#BIOS&lt;/code&gt; &lt;code&gt;#booting&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="booting" scheme="http://yoursite.com/tags/booting/"/>
    
    <category term="BIOS" scheme="http://yoursite.com/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>🗄 파일 시스템</title>
    <link href="http://yoursite.com/2021/05/15/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"/>
    <id>http://yoursite.com/2021/05/15/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/</id>
    <published>2021-05-15T11:44:27.000Z</published>
    <updated>2021-05-25T00:54:42.549Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="파일-시스템이란"><a href="#파일-시스템이란" class="headerlink" title="파일 시스템이란 ?"></a>파일 시스템이란 ?</h1><blockquote><p>운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘을 의미한다.</p></blockquote><h2 id="파일-시스템이-만들어진-이유"><a href="#파일-시스템이-만들어진-이유" class="headerlink" title="파일 시스템이 만들어진 이유?"></a>파일 시스템이 만들어진 이유?</h2><ul><li>블록: <code>블록</code> 단위로(보통 4KB), 블록마다 고유 번호를 부여해서 관리한다.</li><li>0과 1의 데이터를 비트로 저장하기에는 오버헤드 발생하기 때문.</li><li>파일: 사용자는 <code>파일</code> 단위로 관리하며, 각 파일에는 블록 단위로 관리된다.</li><li>사용자가 블록 단위로 고유번호를 관리하기 어렵기 때문.</li></ul><h2 id="파일-시스템-저장-방법"><a href="#파일-시스템-저장-방법" class="headerlink" title="파일 시스템 저장 방법"></a>파일 시스템 저장 방법</h2><ul><li>가능한 연속적 공간에 파일을 저장하는것이 좋으나, 파일 사이즈가 가변적이라면 외부 단편화가 일어날 수 있다.</li><li>따라서,  불연속 공간에 파일을 저장하는 기능이 필요하다.</li><li><code>블록체인</code>: 각 블록을 링크드 리스트로 연결한다. 어떤 주소를 찾으려면 처음부터 주소를 따라가야 하는 단점이 있다.</li><li><code>인덱스 블록</code>: 각 블록에 대한 위치정보를 기억해서, 한번에 그 블록을 찾을 수 있다.</li></ul><h2 id="파일시스템과-시스템콜"><a href="#파일시스템과-시스템콜" class="headerlink" title="파일시스템과 시스템콜"></a>파일시스템과 시스템콜</h2><ul><li>동일한 시스템콜을 사용해서 다양한 파일 시스템 지원 가능하도록 구현되어 있다.</li><li>파일을 실제로 어떻게 저장하는지는 다를 수 있다.</li><li>리눅스의 경우 ext4, NTFS, FAT32 파일시스템을 지원한다.</li></ul><h1 id="inode-방식-파일-시스템"><a href="#inode-방식-파일-시스템" class="headerlink" title="inode 방식 파일 시스템"></a>inode 방식 파일 시스템</h1><ul><li>파일시스템의 기본 구조</li><li>수퍼블록: 파일시스템 정보</li><li>아이노드 블록: 파일 상세정보 (PCB)</li><li>데이터 블록: 실제 데이터 (1KB~4KB)</li></ul><br><img width="316" alt="파일시스템구조" src="https://user-images.githubusercontent.com/28856435/118361659-6b678d80-b5c7-11eb-87d4-839182efbba0.PNG"><br><h2 id="수퍼블록"><a href="#수퍼블록" class="headerlink" title="수퍼블록"></a>수퍼블록</h2><ul><li>파일시스템 정보 및 파티션 정보를 포함한다.</li><li>리눅스 명령어 <code>df</code> 를 했을 때 출력되는 정보들.</li></ul><h2 id="inode와-파일"><a href="#inode와-파일" class="headerlink" title="inode와 파일"></a>inode와 파일</h2><ul><li><p>파일 <code>inode 고유값</code>과 <code>자료구조</code>에 의해 주요 정보를 관리한다.</p></li><li><p>파이이름 : inode =&gt; 파일이름은 inode 와 매칭된다.</p></li><li><p>파일 시스템에서는 inode 기반으로 파일에 엑세스 한다.</p></li><li><p><code>inode 기반의 메타 데이터</code> : 파일권한, 소유자 정보, 파일 사이즈, 생성시간 등</p></li><li><p>각 <code>디렉토리 엔트리</code>(dentry)를 탐색</p></li><li><p>/home/ubuntu/link.txt : <code>/</code> 마다 <code>dentry</code> 를 가지고 있다.</p></li><li><p>파일생성 &gt; inode 번호 &gt; inode 블록 &lt;- 파일 쿼리</p></li><li><p>아래 명령을 실행할 경우,</p></li><li><p>inode 번호 &gt; inode 블록 접근 &gt; 해당 데이터를 읽어옴.</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat data.txt</span></span><br></pre></td></tr></table></figure><br><img width="773" alt="inode구조" src="https://user-images.githubusercontent.com/28856435/118361800-e92b9900-b5c7-11eb-8da3-0791cdf1dfc7.PNG"><br><h1 id="디렉토리-엔트리"><a href="#디렉토리-엔트리" class="headerlink" title="디렉토리 엔트리"></a>디렉토리 엔트리</h1><ul><li>디렉토리를 표현하는 데 쓰이는 자료구조이다.</li><li>일반적으로 파일이름, 파일 속성 등 여러가지 정보가 저장되는데, 유닉스 계열에서는 <code>파일이름</code>과 <code>inode번호</code>만 저장된다.</li><li>리눅스 파일탐색: /home/ubuntu/ink.txt</li><li>각 디렉토리 엔트리를 탐색 : 각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있다.</li><li>즉 <code>/</code> - <code>home</code> - <code>ubuntu</code> - <code>link.txt</code> 순으로 파일을 찾아 해당 <code>inode</code> 를 얻는다. </li></ul><h2 id="가상-파일-시스템"><a href="#가상-파일-시스템" class="headerlink" title="가상 파일 시스템"></a>가상 파일 시스템</h2><ul><li>Network 등 다양한 기기도 동일한 파일시스템 인터페이스를 통해 관리가능</li><li>eg. read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)</li><li>추상화 (abstraction)</li><li>복잡한 기능/자료/데이터의 핵심적 개념과 기능을 간추려 내는것.</li><li>input/output 을 통해 모든 디바이스를 <code>파일 interface</code> 로 다룬다.</li></ul><blockquote><p>모든 것은 파일이라는 철학</p><ul><li>모든 인터렉션 파일을 읽고, 쓰는것처럼 이루어져 있다.</li><li>마우스, 키보드와 같은 모든 디바이스 관련 기술 또한 파일과 같이 다루어짐.<br><strong>즉, 모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용한다.</strong></li></ul></blockquote><h2 id="특수파일-디바이스"><a href="#특수파일-디바이스" class="headerlink" title="특수파일 -디바이스"></a>특수파일 -디바이스</h2><ul><li>블록 디바이스(Block Device): HDD, CD/DVD 같이 블록 또는 섹터 단위 등 정해진 단위로 데이터를 전송한다. I/O 송수신 속도가 높다.</li><li>캐릭터 디바이스 (Character Device): 키보드, 마우스 등 byte 단위 데이터를 전송한다. I/O 송수신 속도가 낮다.</li></ul><h3 id="캐릭터-디바이스-tty"><a href="#캐릭터-디바이스-tty" class="headerlink" title="캐릭터 디바이스-tty"></a>캐릭터 디바이스-tty</h3><ul><li>가상파일 시스템 인터페이스를 통해서, <code>가상 터미널환경(디바이스)</code>에 연결이 되어있다. 이 디바이스에 input 을 주는것은 <code>키보드</code>이다.</li><li>아래 예제를 보면, tty라는 파일을 출력하면, 키보드로 입력하는 것이 두 번 출력된다.</li><li>키보드에 직접 입력하면 첫번째출력. <code>tty</code>-<code>cat</code>명령어를 통해 두번째 출력.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-42-223:/dev$ cat tty</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">i&#x27;m</span><br><span class="line">i&#x27;m</span><br><span class="line">suyeon</span><br><span class="line">suyeon</span><br></pre></td></tr></table></figure>즉, 터미널 조차도 가상시스템 인터페이스를 통해서 일종의 파일처럼 다뤄지고 있으며, 그 파일을 읽거나 쓰면 해당 디바이스를 다룰 수 있다.(운영체제와 통신할 수 있다.)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;inode 와 가상 파일 시스템&lt;br&gt;&lt;code&gt;#inode&lt;/code&gt; &lt;code&gt;#file_system&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="file_system" scheme="http://yoursite.com/tags/file-system/"/>
    
    <category term="inode" scheme="http://yoursite.com/tags/inode/"/>
    
  </entry>
  
  <entry>
    <title>☁️ 가상메모리와 페이징 시스템</title>
    <link href="http://yoursite.com/2021/05/13/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"/>
    <id>http://yoursite.com/2021/05/13/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/</id>
    <published>2021-05-13T08:34:43.000Z</published>
    <updated>2021-05-20T01:06:40.833Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><h1 id="가상-메모리-Virtual-Memory-System"><a href="#가상-메모리-Virtual-Memory-System" class="headerlink" title="가상 메모리 (Virtual Memory System)"></a>가상 메모리 (Virtual Memory System)</h1><ul><li>각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 있다.</li><li>eg. 리눅스는 프로세스 하나당 4GB 이다.</li><li>즉, <code>가상 메모리</code>는 실제 메모리보다 많아보이게 하는 기술이다.</li><li>프로세스간 공간이 분리되어 프로세스 이슈가 전체 시스템에 영향을 주지 않는다.</li></ul><h2 id="가상-메모리의-사용"><a href="#가상-메모리의-사용" class="headerlink" title="가상 메모리의 사용"></a>가상 메모리의 사용</h2><ul><li>프로세스는 가상주소를 사용하고, 그 주소에 매핑되는 실제 주소는 데이터 read/write 시에만 가져온다. </li><li><code>virtual address</code>(가상주소) : 프로세스가 참조하는 주소</li><li><code>physical address</code> (물리주소) : 실제 메모리 주소</li><li><code>MMU</code> (Memory Management Unit)</li><li>가상주소의 메모리 접근이 필요할 때, 그 주소값을 물리주소로 반환해주는 하드웨어 장치이다.</li></ul><h2 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU (Memory Management Unit)"></a>MMU (Memory Management Unit)</h2><ul><li>CPU 는 가상메모리를 다루고, 해당 주소 접근시 <code>MMU 하드웨어 장치를 통해 물리메모리에 접근</code>한다.</li><li>하드웨어 장치를 사용하면 주소 변환이 빠르기 때문에 별도 장치를 둔다.</li></ul><h1 id="페이징-시스템-Paging-System"><a href="#페이징-시스템-Paging-System" class="headerlink" title="페이징 시스템 (Paging System)"></a>페이징 시스템 (Paging System)</h1><ul><li>페이징이란 ?</li><li>크기가 동일한 페이지로 가상주소 공간과 그에 상응하는 물리주소 공간을 관리한다.<ul><li>page(page frame) : 고정된 크기의 block(4KB)</li></ul></li><li>페이징 번호를 기반으로 <code>가상주소-물리주소 매핑 정보를 저장</code>하고 사용한다.</li><li>리눅스에서는 보통 4KB 만큼 페이징.</li><li>프로세스 (4GB) 의 <code>PCB</code>에 <code>Page Table 구조체</code>를 가리키는 주소가 들어있다.</li></ul><h2 id="페이징-시스템-구조"><a href="#페이징-시스템-구조" class="headerlink" title="페이징 시스템 구조"></a>페이징 시스템 구조</h2><ul><li>페이징 시스템</li><li>가상주소 = 가상메모리 페이지 + 변위</li><li>페이지 크기 4KB 라면, 가상주소의 <code>0~11bit</code> 변위를 나타내고, <code>12bit 이상</code>이 페이지 번호가 될 수 있다.</li></ul><h2 id="페이지-테이블-page-table"><a href="#페이지-테이블-page-table" class="headerlink" title="페이지 테이블 (page table)"></a>페이지 테이블 (page table)</h2><ul><li>프로세스 생성시 페이지 테이블 정보가 생성된다.</li><li>관련 페이지 테이블 base address 는 별도 <code>CR3 레지스터</code>에 저장한다.</li><li>물리주소에 있는 페이지 번호와 해당 페이지 번호의 첫 물리주소를 매핑한 표.</li><li>해당 페이지 테이블에서 해당 page 에 매핑된 첫 물리주소를 알아내고 변위를 더한값이 실제 물리주소이다.</li></ul><h2 id="MMU-Memory-Management-Unit-물리주소를-얻는-방법"><a href="#MMU-Memory-Management-Unit-물리주소를-얻는-방법" class="headerlink" title="MMU (Memory Management Unit) : 물리주소를 얻는 방법"></a>MMU (Memory Management Unit) : 물리주소를 얻는 방법</h2><p>  MMU(하드웨어 장치) - 물리메모리를 확인하기 위해 Memory 에 갔다와야 한다.</p><ul><li><code>CPU</code> 는 <code>virtual address</code>를 <code>MMU</code> 에 요청한다.</li><li><code>MMU</code> 는 <code>virtual address</code>로 해당 프로세스의 <code>PCB</code>의 페이지 테이블에 접근하여 <code>CR3 레지스터</code>로부터 <code>base address</code>를 얻는다.</li><li><code>MMU</code> 는 <code>base address</code>로, Memory의 물리주소에 접근한다.</li></ul><h2 id="다중단계-페이징-시스템"><a href="#다중단계-페이징-시스템" class="headerlink" title="다중단계 페이징 시스템"></a>다중단계 페이징 시스템</h2><ul><li>프로세스마다 페이지를 나누어서 메모리에 할당하면 많은 공간이 낭비된다. 필요한 부분만 페이지를 나눠서 할당하여 공간의 활용도를 높이고자 하는것에 착안했다.</li><li>모든 부분을 페이지도 나눌 필요없이 단계적으로 나누어서 필요한 부분만 <code>페이지 테이블</code>에 두고 이것을 <code>페이지 디렉토리</code>에 저장한다.</li><li>32bit 시스템에서 4KB를 위한 페이징 시스템</li><li><code>하위 12bit</code> : 오프셋(변위)</li><li><code>상위 20bit</code> : 페이징 번호 (2<sup>20</sup>=1048576 개의 페이징 번호)</li><li>페이지 번호를 나타내는 bit를 구분하여 단계를 나눈다.</li><li>10bit : Page Directory</li><li>10bit : Page Table</li><li>20bit : OFFSET &gt; Pysical Frame</li><li>CR3 -&gt; Page Directory(시작주소) -&gt; Page Table(시작주소) -&gt; Pysical Frame(물리 메모리에서 프레임주소)</li></ul><h2 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB (Translation Lookaside Buffer)"></a>TLB (Translation Lookaside Buffer)</h2><ul><li>페이지 정보를 캐슁한다. (Pysical Address 전달/캐슁)</li></ul><h2 id="공유-메모리-Shared-Memory"><a href="#공유-메모리-Shared-Memory" class="headerlink" title="공유 메모리 (Shared Memory)"></a>공유 메모리 (Shared Memory)</h2><ul><li>프로세스간 동일한 물리주소를 가리킬 수 있다.</li><li>공간절약, 메모리 할당 절약.</li><li>P1(Parent) - [fork] -&gt; P2(Child)</li></ul><h2 id="요구-페이징-Demand-Paging"><a href="#요구-페이징-Demand-Paging" class="headerlink" title="요구 페이징 (Demand Paging)"></a>요구 페이징 (Demand Paging)</h2><ul><li>프로세스의 모든 데이터를 메모리에 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재한다.</li><li>더 이상 필요치 않은 페이지 프레임은 저장매체에 저장한다.(페이지 교체 알고리즘)</li><li>요구페이징 &lt;-&gt; 선행페이징(anticipatory paging): 미리 프로세스 관련 데이터를 모두 메모리에 올려놓고 실행.</li></ul><h2 id="페이지-폴트-Page-Fault"><a href="#페이지-폴트-Page-Fault" class="headerlink" title="페이지 폴트 (Page Fault)"></a>페이지 폴트 (Page Fault)</h2><ul><li>어떤 페이지 정보가 실제 물리메모리에 없을때 <code>페이지폴트 인터럽트</code>가 발생한다.</li></ul><h1 id="전체-페이징-시스템-프로세스-feat-TLB-Page-fault"><a href="#전체-페이징-시스템-프로세스-feat-TLB-Page-fault" class="headerlink" title="전체 페이징 시스템 프로세스(feat. TLB, Page fault)"></a>전체 페이징 시스템 프로세스(feat. TLB, Page fault)</h1><br><img width="1009" alt="페이징_시스템" src="https://user-images.githubusercontent.com/28856435/118363663-62c78500-b5d0-11eb-902d-6ec65340e35c.PNG"><p>(a) <strong>[CPU -&gt; MMU]</strong> CPU는 <code>MMU</code> 에 가상주소를 요청한다.<br>(b) <strong>[MMU -&gt; TLB]</strong> 먼저 <code>TLB 칩</code>에 변환된 물리주소가 있는지 확인한다. 있다면 바로 그 정보로 (e)단계로, 없다면 (c) 단계로 진행한다.<br>(c) <strong>[MMU -&gt; Memory]</strong> <code>CR3 레지스터</code>로부터 해당 페이지의 테이블에 물리주소가 있는지(valid) 확인한다. -&gt; invalid일 경우(d) 단계를 수행, valid일 경우 (e)단계로 진행한다.</p><ul><li>(d-1) <strong>[MMU -&gt; OS]</strong> <code>Page Fault Interrupt</code> OS(운영체제) 에서 <code>page fault interrupt handling</code>이 수행되고</li><li>(d-2) <strong>[OS -&gt; 저장매체]</strong> <code>저장매체</code>에서 해당 프로세스의 페이지 정보를 찾아온다.</li><li>(d-3) <strong>[저장매체 -&gt; Memory]</strong> 해당 물리주소를 <code>메모리</code>에 올린다.</li><li>(d-4) <strong>[Memory]</strong> 페이징 정보를 업데이트 한다.</li></ul><p>(e) <strong>[Memory -&gt; MMU]</strong> 페이지 테이블에서 해당 물리주소를 가져온다.<br>(f) <strong>[MMU -&gt; Memory]</strong> 실제 물리주소 위치에 접근한다.<br>(g) <strong>[Memory -&gt; CPU]</strong> 해당 데이터를 전달한다.</p><hr><h1 id="페이지-교체-알고리즘"><a href="#페이지-교체-알고리즘" class="headerlink" title="페이지 교체 알고리즘"></a>페이지 교체 알고리즘</h1><h2 id="페이지-교체-정책-Page-replacement-policy"><a href="#페이지-교체-정책-Page-replacement-policy" class="headerlink" title="페이지 교체 정책 (Page replacement policy)"></a>페이지 교체 정책 (Page replacement policy)</h2><ul><li>운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리메모리에 공간이 없다면.</li><li>기존 페이지 중 하나를 저장매체로 내린다.</li><li>새로운 페이지를 해당 물리공간에 올린다.</li></ul><blockquote><p>페이지 교체 알고리즘(Page Replacement Algorithm) : 어떤 페이지를 물리메모리에서 저장매체로 보낼것인가 ?</p></blockquote><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>가장 먼저 들어온 페이지를 내리자.</li></ul><h3 id="OPT-OPTimal-Replacement-Algorithm"><a href="#OPT-OPTimal-Replacement-Algorithm" class="headerlink" title="OPT(OPTimal Replacement Algorithm)"></a>OPT(OPTimal Replacement Algorithm)</h3><ul><li>최적 페이지 교체 알고리즘</li><li>앞으로 오랫동안 사용하지 않을 페이지를 내리자.</li><li>어떤 페이지가 오랫동안 사용하지 않을지 예측이 힘들다. - 일반 OS에서는 구현이 불가.</li></ul><h3 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU (Least Recently Used)"></a>LRU (Least Recently Used)</h3><ul><li>가장 오래전에 사용된 페이지를 교체한다.</li><li>OPT 알고리즘이 현실적으로 불가하므로, 과거 기록을 기반으로 한다.</li><li><code>메모리 지역성</code> 에 따르면 근처의 메모리 영역을 많이 사용한다.</li></ul><h3 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU (Least Frequently Used)"></a>LFU (Least Frequently Used)</h3><ul><li>가장 적게 사용된 페이지를 교체한다.</li></ul><h3 id="NUR-Not-Used-Recently"><a href="#NUR-Not-Used-Recently" class="headerlink" title="NUR (Not Used Recently)"></a>NUR (Not Used Recently)</h3><ul><li>최근에 사용하지 않은 페이지부터 교체한다. (LRU와 비슷)</li><li>참조비트와 수정비르를 사용해 그 순서대로 페이지를 교체한다.</li></ul><h2 id="Threshing-스레싱"><a href="#Threshing-스레싱" class="headerlink" title="Threshing (스레싱)"></a>Threshing (스레싱)</h2><ul><li>반복적으로 페이지 폴트가 발생하면, 과도하게 페이지 교체작업이 일어나 결국엔 아무 일도 수행하지 못하는 상황.</li></ul><hr><h1 id="세그멘테이션-기법"><a href="#세그멘테이션-기법" class="headerlink" title="세그멘테이션 기법"></a>세그멘테이션 기법</h1><ul><li>가상메모리를 서로 <code>크기가 다른</code> 논리적 단위인 <code>segment</code>로 분할한다.</li><li>세그먼트의 가상주소도 페이징과 동일하게 (세그먼트번호 + 블록 내 변위) 로 찾는다.</li></ul><h2 id="내부단편화-amp-외부단편화"><a href="#내부단편화-amp-외부단편화" class="headerlink" title="내부단편화 &amp; 외부단편화"></a>내부단편화 &amp; 외부단편화</h2><ul><li>내부단편화는 페이징 기법에서 나타나는 현상이다.</li><li>페이지 블록만큼 데이터가 채워지지 않았을 경우.</li><li>이식성을 중요시하는 리눅스는 페이징 기법으로 구현되어 있다.</li><li>외부단편화는 세그멘트 기법에서 나타나는 현상이다.</li><li>물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;가상메모리와 페이징 기법과 세그먼트 기법.&lt;br&gt;&lt;code&gt;#paging_system&lt;/code&gt; &lt;code&gt;#virtual_memory&lt;/code&gt; &lt;code&gt;#segment&lt;/code&gt; &lt;code&gt;#MMU&lt;/code&gt; &lt;code&gt;#TLB&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="paging_system" scheme="http://yoursite.com/tags/paging-system/"/>
    
    <category term="virtual_memory" scheme="http://yoursite.com/tags/virtual-memory/"/>
    
  </entry>
  
  <entry>
    <title>📑 Thread, Synchronization, Semaphore</title>
    <link href="http://yoursite.com/2021/05/11/%EC%93%B0%EB%A0%88%EB%93%9C/"/>
    <id>http://yoursite.com/2021/05/11/%EC%93%B0%EB%A0%88%EB%93%9C/</id>
    <published>2021-05-11T14:32:46.000Z</published>
    <updated>2021-05-20T01:06:40.837Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="Thread-쓰레드"><a href="#Thread-쓰레드" class="headerlink" title="Thread 쓰레드?"></a>Thread 쓰레드?</h1><ul><li>한마디로 프로세스의 서브셋이다.</li><li><code>Light Weight Process</code> 라고도 한다.</li><li>하나의 프로세스에 여러개 스레드 생성이 가능하다.</li><li>스레드를 동시에 실행 가능하다.</li><li>프로세스 내부에 있으므로 <code>프로세스 데이터에 접근이 가능</code>하다.</li><li>각 스레드마다 <code>stack</code>이 존재한다.</li></ul><h2 id="Process-vs-Thread"><a href="#Process-vs-Thread" class="headerlink" title="Process vs Thread"></a>Process vs Thread</h2><ul><li>Process</li><li>프로세스 간 서로의 영역에 데이터 접근이 불가하다.</li><li>자신만의 주소를 갖는다. (독립적)</li><li>통신을 위해서 IPC 기법이 필요하다.</li><li>하나의 프로세스에 문제가 생겼을 경우, 다른 프로세스에 영향을 주지 않는다.</li><li>Thread</li><li>프로세스 자원 정보가 공유된다.</li><li>스레드 간의 주소 영역을 공유한다.</li><li>CODE, DATA, HEAP 영역을 공유.</li><li>하나의 스레드에 오류가 발생하면, 같은 자원을 사용하는 동일한 프로세스 내의 모든 스레드의 작업이 중단된다.</li></ul><h2 id="Multi-Thread"><a href="#Multi-Thread" class="headerlink" title="Multi Thread"></a>Multi Thread</h2><ul><li>최근의 CPU 는 멀티 프로세싱이 가능하므로 (여러개 CPU) 프로세스 내에도 여러개의 스레드를 만들어 멀티코어의 활용도를 높인다.</li></ul><h2 id="Thread-의-장-단점"><a href="#Thread-의-장-단점" class="headerlink" title="Thread 의 장.단점"></a>Thread 의 장.단점</h2><ul><li>장점</li><li>사용자에 대한 응답속도 향상 (T1이 특정작업을 하는 동시에 T2는 사용자와 통신을 한다.)</li><li>프로세스의 자원공유를 위해서 사용되는 IPC (Inter Processing Communication) 기법과 같이, 별도의 작업을 할 필요가 없다.</li><li>프로세스의 데이터에 접근 할 수 있다.</li><li>단점</li><li>하나의 프로세스에 있는 여러개 스레드 중 하나라도 문제가 생기면, 전체 프로세스에 영향을 미친다.</li><li>스레드를 너무 많이 생성하면 Context Switching 이 빈번하게 발생하여 성능이 저하될 수 있다. (모든 스레드를 스케줄링 해야하므로.)</li><li>공유 자원을 사용하기 때문에 동기화 이슈가 있다.</li></ul><blockquote><ul><li>PThread = POSIX Threads</li></ul><ul><li>Thread 관련 표준 API</li></ul></blockquote><h1 id="동기화-Synchronization-이슈"><a href="#동기화-Synchronization-이슈" class="headerlink" title="동기화 (Synchronization) 이슈"></a>동기화 (Synchronization) 이슈</h1><ul><li>동시에 여러개의 스레드가 동잃한 자원을 사용할 경우 발생한다.</li><li>동일 자원을 여러 스레드가 동시 수정시 최종 결과에 영향을 미친다.</li><li>두 스레드가 같은 객체를 공유하면서 서로 간섭하며 예상치 못한 결과를 도출하게 된다.</li></ul><h2 id="동기화-이슈-예시"><a href="#동기화-이슈-예시" class="headerlink" title="동기화 이슈 예시"></a>동기화 이슈 예시</h2><ul><li>Cal.java : <code>Cal</code> 이라는 객체에 다음값을 리턴해주는 함수가 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idx=idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>TestThreads.java : th1, th2 이라는 스레드 두개를 만들어 각 set1, set2 에 Cal 객체를 사용하여 증가값을 넣어준다. (Set 은 중복을 허용하지 않음.)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThreads</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedIOException </span>&#123;</span><br><span class="line">    Cal cal = <span class="keyword">new</span> Cal(<span class="number">0</span>);</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">      Thread th1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line">            set1.add(cal.getNext());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line">            set2.add(cal.getNext());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set1 : &quot;</span>+set1.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;set2 : &quot;</span>+set2.size());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">        ee.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">                </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>main 함수를 실행시 코드 그대로의 결과는 set1과 set2 에 각각 100000 개의 사이즈가 나와야 한다. 그런데 set1 과 set2 의 사이즈를 찍어보면, 아래와 같이 조금 부족한 숫자가 나온다.</li></ul><img width="871" alt="스레드_동기화" src="https://user-images.githubusercontent.com/28856435/117925951-ef551780-b332-11eb-8d3e-e147ff79439a.png"><br><blockquote><p><code>왜 예상 결과값과 다를까?</code><br><strong>main 함수 수행 중, idx=8888 인 시점이라고 가정한다.</strong></p><ol><li>th1 가 연산을 수행하기 위해 idx=8888 을 가져온다. 이 때 th2 가 끼어들면 th1 은 다음 연산을 수행하지 못하고&gt;멈추게 된다. (각 스레드는 자신의 stack 영역을 갖는다.)</li><li>th2 도 수행을 위해 idx=8888을 가져오고 자신의 n번째 작업을 마친다. idx=8889 로 업데이트 된다.</li><li>th1 이 중단되었던 작업을 이어서 수행한다. 이때 th1이 갖고 있는 Cal() 객체의 idx=8888 이다. th1 도 자신의 n번째 작업을 마친다.</li><li>th1 의 작업으로 인해 idx=8889 가 된다. Cal() 객체의 idx 값이 덮어씌워진다. 언급한 작업은 두 번 이지만 idx 의 값은&gt;8889로 동일하게 유지되는 현상을 볼 수 있다.</li></ol></blockquote><h2 id="동기화-이슈-해결방안"><a href="#동기화-이슈-해결방안" class="headerlink" title="동기화 이슈 해결방안"></a>동기화 이슈 해결방안</h2><ul><li>상호배제 (Mutual Extension)</li><li>여러 스레드가 사용중인(변경중인) 공유 변수에 대해 배제 (exclusive access) 필요하다.</li><li>임계영역을 하나의 스레드가 어떤 자원을 사용할 때 다른 스레드가 동시에 접근할 수 없도록 막는다.</li><li>위에서 수행했던 java 예제에서는 아래와 같이 바꿔줄 수 있다. ++ 연산이 수행되는 임계점에 <code>synchronized</code> 를 붙여준다. 이 부분은 <code>동기화</code> 처리 되어 수행중인 스레드가 있을 때 다른 스레드가 간섭하지 못하게 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idx=idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="임계영역-Critical-Section"><a href="#임계영역-Critical-Section" class="headerlink" title="임계영역(Critical Section)"></a>임계영역(Critical Section)</h1><ul><li>하나의 스레드의 접근만 허락된 영역. 둘 이상의 스레드가 접근하면 문제를 일으킬 수 코드들.</li></ul><h2 id="Mutex-와-Semaphore"><a href="#Mutex-와-Semaphore" class="headerlink" title="Mutex 와 Semaphore"></a>Mutex 와 Semaphore</h2><ul><li>Mutex(binary semaphore) : 임계영역에 하나의 스레드만 접근 가능하다.</li><li>Semaphore : 카운터를 두어, 임계영역역에 허용 가능한 스레드 개수만큼 여러개의 스레드가 동시에 접근할 수 있도록 한다.</li></ul><h3 id="Semaphore-수도코드로-표현-feat-바쁜대기"><a href="#Semaphore-수도코드로-표현-feat-바쁜대기" class="headerlink" title="Semaphore 수도코드로 표현 (feat.바쁜대기)"></a>Semaphore 수도코드로 표현 (feat.바쁜대기)</h3><ul><li>세마포어를 아래 조건에서 수도코드로 나타냈을때.</li><li>P: 검사 (임계영역에 <code>들어갈때</code>) S값이 1이상이면 임계영역 진입후 S 값 차감. (S값이 0이면 대기)</li><li>V: 증가 (임계영역에서 <code>나올때</code>) S 값에 1을 더하고 임계 영역을 나옴.</li><li>S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시에 임계 영역 접근가능)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P</span>(S): <span class="built_in">wait</span>(S)&#123;</span><br><span class="line">  <span class="keyword">while</span> S &lt;= <span class="number">0</span> ; <span class="comment">// 바쁜 대기</span></span><br><span class="line">  </span><br><span class="line">  S--;</span><br><span class="line">  <span class="comment">// 다른 프로세스 접근 제한</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(S): <span class="built_in">signal</span>(S)&#123;</span><br><span class="line">  S++;</span><br><span class="line">  <span class="comment">// 다른 프로세스 접근 허용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wait 바쁜 대기 (S&lt;=0) 일 경우 프로세스 중단. 중단은 대부분 loop 로 표현된다.<br>즉, 중단은  CPU 에 부하를 줄 수 있다.</li></ul><h3 id="Semaphore-대기큐-운영체제-기술로-보완"><a href="#Semaphore-대기큐-운영체제-기술로-보완" class="headerlink" title="Semaphore - 대기큐 (운영체제 기술로 보완)"></a>Semaphore - 대기큐 (운영체제 기술로 보완)</h3><ul><li>S 가 음수일 경우, 바쁜대기 대신 대기큐에 넣는다.</li><li>block() 함수를 통해 대기상태로.</li><li>S 가 양수일 경우, 해당 프로세스를 대기큐에서 지운다.</li><li>wakeup() 함수를 통해 대기상태의 프로세스를 재실행.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">  S-&gt;count--;</span><br><span class="line">  <span class="keyword">if</span> ( S-&gt;count &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">    add <span class="keyword">this</span> process to S-&gt;queue;</span><br><span class="line">    <span class="built_in">block</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">  S-&gt;count++;</span><br><span class="line">  <span class="keyword">if</span> ( S-&gt;count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    remove a process P from S-&gt;queue;</span><br><span class="line">    <span class="built_in">wakeup</span>(P)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-주요함수"><a href="#Semaphore-주요함수" class="headerlink" title="Semaphore 주요함수"></a>Semaphore 주요함수</h2></li><li>sem_open() : 세마포어 생성</li><li>sem_wait() : 임계영역 접근 전, 세마포어를 잠그거나 잠겨있다면 풀릴때까지 대기.</li><li>sem_post() : 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.</li></ul><h1 id="교착상태-amp-기아상태"><a href="#교착상태-amp-기아상태" class="headerlink" title="교착상태 &amp; 기아상태"></a>교착상태 &amp; 기아상태</h1><h2 id="교착상태-deadlock"><a href="#교착상태-deadlock" class="headerlink" title="교착상태 (deadlock)"></a>교착상태 (deadlock)</h2><ul><li>무한대기상태 : 두개 이상의 작업이 서로의 작업이 끝나기만을 기다리며, 다음 단계로 진행하지 못함.</li><li>프로세스, 쓰레드에서 모두 일어날 수 있다.</li><li>배치 프로그램에서는 일어나지 않는다.</li><li>교착상태 발생조건</li><li>상호배제(Mutual Exclusion) : 프로세스들이 필요로하는 공유자원에 대해 권한 접근이 제한되기 때문에 한번에 하나의 프로세스만 공유자원을 사용할 수 있다.</li><li>점유대기 : 이미 자원을 할당받은 프로세스가 그 자원을 양보하지 않은 상태에서 다른 자원을 요구할 수 있다.</li><li>비선점 : 프로세스가 어떤 자원의 사용을 끝날때까지 뺏을 수 없다. 즉, 한 프로세스가 다른 프로세스의 접근 권한을 강제로 취소할 수 없다.</li><li>순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다. 두 개 이상의 프로세스가 자원 할당을 기다리는 사이클이 존재한다.</li></ul><h3 id="교착상태-해결방법"><a href="#교착상태-해결방법" class="headerlink" title="교착상태 해결방법"></a>교착상태 해결방법</h3><ul><li>교착상태 예방 : 교착상태 네 가지 발생조건 중 한가지를 제거한다.</li><li>교착상태 회피 : 교착상태 조건 중 자원할당 순서를 정의하지 않는다. (순환대기 조건 제거)</li><li>교착상태 발견 : 교착상태를 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것.</li><li>교착상태 회복 : 교착상태를 일으킨 프로세스를 종료하거나, 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것.</li></ul><h2 id="기아상태-Starvation"><a href="#기아상태-Starvation" class="headerlink" title="기아상태 (Starvation)"></a>기아상태 (Starvation)</h2><ul><li>우선순위가 낮은 프로세스가 원하는 자원을 영원히 할당받지 못하는 상태.</li></ul><h3 id="기아상태-해결방법"><a href="#기아상태-해결방법" class="headerlink" title="기아상태 해결방법"></a>기아상태 해결방법</h3><ul><li>프로세스 우선순위를 수시로 변경해서 할당받을 기회를 준다.</li><li>오리 기다린 프로세스의 우선순위를 높여준다.</li><li>우선순위가 아니라, 요청을 순서대로 처리하는 FIFO 기반 큐를 사용한다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Thread 의 개념 및 프로세스와의 차이점, 동기화 이슈 그리고 세마포어&lt;br&gt;&lt;code&gt;#semaphore&lt;/code&gt; &lt;code&gt;#thread&lt;/code&gt; &lt;code&gt;#mutex&lt;/code&gt; &lt;code&gt;#critical_section&lt;/code&gt; &lt;code&gt;#deadlock&lt;/code&gt; &lt;code&gt;#starvation&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
    <category term="semaphore" scheme="http://yoursite.com/tags/semaphore/"/>
    
  </entry>
  
  <entry>
    <title>🔀 프로세스 구조와 컨텍스트 스위칭</title>
    <link href="http://yoursite.com/2021/05/10/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%A1%B0/"/>
    <id>http://yoursite.com/2021/05/10/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%A1%B0/</id>
    <published>2021-05-10T08:21:24.000Z</published>
    <updated>2021-05-12T08:42:28.557Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="프로세스란"><a href="#프로세스란" class="headerlink" title="프로세스란 ?"></a>프로세스란 ?</h1><blockquote><p>프로세스란 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.</p></blockquote><h1 id="프로세스와-프로그램"><a href="#프로세스와-프로그램" class="headerlink" title="프로세스와 프로그램"></a>프로세스와 프로그램</h1><blockquote><p>프로그램: 일반적으로 하드 디스크 등의 보조기억장치에 저장된 실행 코드<br>프로세스: 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭.<br>즉, 실행 중인 프로그램을 뜻한다. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행되는 것이다.</p></blockquote><h2 id="프로세스-구조"><a href="#프로세스-구조" class="headerlink" title="프로세스 구조"></a>프로세스 구조</h2><ul><li>STACK : 프로그램이 자동으로 사용하는 메모리 영역이다. 함수 내의 지역변수, 인자값, 반환값의 주소가 임시로 저장된다. 데이터가 쌓이거나 반환하기 위해 할당하는 스택의 위치를 <code>SP(Stack Pointer)</code> 라는 레지스터에 주소값을 저장한다. 하나의 데이터가 stack 에 쌓이면 다음 주소값이 SP 에서 갱신된다.</li><li>HEAP : 프로그래머의 필요에 의해 동적으로 메모리를 할당하고자 할 때 사용되는 영역이다. C 에서의 <code>malloc()</code> 함수 사용, Java 에서의 참조타입 혹은 생성자를 선언할 경우, 메모리 공간이나 크기를 할당할 수 있다.<br>메모리 주소 값에 의해서만 참조되고 사용되는 영역이다</li><li>DATA</li><li>BSS영역, Data영역을 구분하는 이유?<br>초기화 된 데이터는 초기값을 저장해야 하므로 Data 영역에 저장되어 <code>ROM</code> 에 저장된다. 하지만 초기화 되지 않은 데이터 까지 <code>ROM</code> 에 저장되면 큰 size의 공간이 필요하므로 구분하여, 초기화 되지 않은 데이터는 <code>RAM</code> 에 저장한다.</li><li>BSS : 초기화 되지 않은, 선언만 된 글로벌/전역 변수</li><li>DATA : 초기화된 글로벌/전역 변수</li><li>CODE(TEXT) : 프로그램 코드 (컴파일된 기계어, Read Only)</li></ul><h2 id="프로그램-코드-예시-feat-Heap"><a href="#프로그램-코드-예시-feat-Heap" class="headerlink" title="프로그램 코드 예시 (feat.Heap)"></a>프로그램 코드 예시 (feat.Heap)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_data1;</span><br><span class="line"><span class="keyword">int</span> global_data2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* data; <span class="comment">// int 타입의 포인터</span></span><br><span class="line"></span><br><span class="line">  data = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)  * <span class="number">4</span>); <span class="comment">// malloc 은 메모리를 할당해주는 동적함수.</span></span><br><span class="line"></span><br><span class="line"> *data = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 프로그램의 구조<table><thead><tr><th>영역</th><th>데이터</th></tr></thead><tbody><tr><td>stack</td><td>int* data</td></tr><tr><td>heap  data = (int*) malloc(sizeof(int)  * 4)</td><td></td></tr><tr><td>data</td><td></td></tr><tr><td>BSS</td><td>int global_data1;</td></tr><tr><td>DATA</td><td>int global_data2=1;</td></tr><tr><td>text(code)</td><td>위의 컴파일 코드</td></tr></tbody></table></li></ul><h2 id="스택-오버플로우-amp-amp-힙-오버플로우"><a href="#스택-오버플로우-amp-amp-힙-오버플로우" class="headerlink" title="스택 오버플로우 &amp;&amp; 힙 오버플로우"></a>스택 오버플로우 &amp;&amp; 힙 오버플로우</h2><ul><li>stack과 heap영역은 사실 같은 공간을 공유한다. heap이 메모리의 낮은 주소부터 할당되면 stack은 높은 주소부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 <code>stack overflow</code>, <code>heap overflow</code> 라고 한다.</li><li>하나의 함수에서 너무 큰 지역변수를 선언하거나, 종료조건이 없는 재귀함수가 무한히 호출 될 경우, 버퍼를 초과하게 되어 <code>스택 오버플로우</code>가 발생한다. 이 때, return 값을 덮어쓰게 된다면 해킹의 위험에 노출된다.</li></ul><h2 id="컨텍스트-스위칭-PCB"><a href="#컨텍스트-스위칭-PCB" class="headerlink" title="컨텍스트 스위칭, PCB"></a>컨텍스트 스위칭, PCB</h2><ul><li>컨텍스트 스위칭이란 ? </li></ul><ul><li>Context Switching = 문맥교환</li><li>CPU 가 어떤 하나의 프로세스를 실행하고 있는 중, 인터럽트 요청 혹은 스케줄러에 의해 다른 우선순위의 프로세스로 교체되어 실행되는 것을 말한다.<br>기존 프로세스의 상태, 레지스터값(Context) 을 저장하고, 다음 실행될 프로세스의 레지스터값으로 교체하면 CPU 는 해당값을 읽어 수행한다.</li></ul><h3 id="PCB-Process-Control-Context-Block"><a href="#PCB-Process-Control-Context-Block" class="headerlink" title="PCB (Process Control/Context Block)"></a>PCB (Process Control/Context Block)</h3><blockquote><p>프로세스가 생성시 만들어지며, 프로세스마다 존재한다.<br>운영체제가 프로세스를 제어하기 위해 실행중인 상태를 캡쳐/구조화 하여 저장되는 구조체이다.<br>주기억장치에 정보가 유지된다.</p></blockquote><ul><li>PCB 정보</li></ul><ul><li>Process ID</li><li>Register 값 : PC(Program Counter), SP(Stackk Pointer) 등</li><li>Scheduling Info (Process State)</li><li>Memory Info (메모리사이즈 limit)</li></ul><h3 id="컨텍스트-스위칭-과정"><a href="#컨텍스트-스위칭-과정" class="headerlink" title="컨텍스트 스위칭 과정"></a>컨텍스트 스위칭 과정</h3> <img width="326" alt="context_switching" src="https://user-images.githubusercontent.com/28856435/117633911-6f577200-b1b9-11eb-852e-56afe22a999f.png"><ol><li>실행중지할 프로세스를 해당 프로세스의 PCB 에 업데이트 후 메인메모리에 저장한다.</li><li>메인 메모리에서 다음 실행할 프로세스의 PCB 정보를 CPU 레지스터에 넣고 실행한다.</li></ol><ul><li><code>dispatch</code> : Ready 상태의 프로세스를 Running 상태로 바꾸는 것.</li></ul><h3 id="컴파일러-등장에-따른-컨텍스트-스위칭-속도"><a href="#컴파일러-등장에-따른-컨텍스트-스위칭-속도" class="headerlink" title="컴파일러 등장에 따른 컨텍스트 스위칭 속도"></a>컴파일러 등장에 따른 컨텍스트 스위칭 속도</h3><ul><li>초기 : 어셈블리어로 작성되어 서로다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램 작성</li><li>어셈블리어로는 프로그램 작성속도가 떨어짐.</li><li>컴파일러 등장 : CPU 아키텍처에 따라서 컴파일러 프로그램만 만들면 되게 되었다.</li><li>어셈블리 언어로 작성된 코드보다 속도가 떨어질 수도 있음.</li><li>리눅스의 경우, 각 CPU마다 다른 컨텍스트 스위칭 코드가 존재한다.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;프로세스 구조에 대해 자세히, 컨텍스트 스위칭은 어떻게 일어날까?&lt;br&gt;&lt;code&gt;#context_switching&lt;/code&gt; &lt;code&gt;#PC&lt;/code&gt; &lt;code&gt;#SP&lt;/code&gt; &lt;code&gt;#PCB&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>⏸ 인터럽트</title>
    <link href="http://yoursite.com/2021/05/07/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8/"/>
    <id>http://yoursite.com/2021/05/07/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8/</id>
    <published>2021-05-06T16:21:24.000Z</published>
    <updated>2021-05-11T01:52:08.022Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="인터럽트란"><a href="#인터럽트란" class="headerlink" title="인터럽트란?"></a>인터럽트란?</h2><ul><li>CPU 에서 프로그램 실행중에 입출력 이벤트나 프로그래밍 오류 등, 예기지 못한 상황이 발생했을 경우 CPU 에게 실행중인 작업을 중단시키고 그 상황을 먼저 처리하도록 하는 기술이다.</li></ul><h2 id="내부-외부-인터럽트"><a href="#내부-외부-인터럽트" class="headerlink" title="내부/외부 인터럽트"></a>내부/외부 인터럽트</h2><ul><li>내부 인터럽트 : 프로그램 내부에서 발생. (=소프트웨어 인터럽트)</li></ul><ul><li>프로그램 내부에서 잘못된 데이터 사용이나, 명령어 실행오류</li><li>권한을 위배한 엑세스 (사용자 모드에서 운영체제의 명령이나 공간에 접근)</li><li>Divide by zero</li><li>Overflow/Underflow</li></ul><ul><li>외부 인터럽트 : 프로그램 외부에서 발생. (=하드웨어 인터럽트)</li></ul><ul><li>기기문제나 전원이상</li><li>입출력 인터럽트</li><li>타이머 인터럽트</li></ul><h3 id="타이머-인터럽트"><a href="#타이머-인터럽트" class="headerlink" title="타이머 인터럽트"></a>타이머 인터럽트</h3><ul><li>선점형 스케줄러에 필요</li><li>하드웨어로부터 일정시간마다 타이머 인터럽트를 CPU 에게 알려주면, <code>context switching</code> 을 수행한다.</li><li>context switching : 수행중인 프로세스를 중단하고 다른 프로세스를 수행하는 것.</li><li>타이머 인터럽트를 발생시키는 칩이 컴퓨터에 별도로 존재한다.</li></ul><h3 id="입출력-인터럽트"><a href="#입출력-인터럽트" class="headerlink" title="입출력 인터럽트"></a>입출력 인터럽트</h3><ul><li>프린터, 키보드, 마우스, 저장매체(SSD) 등</li></ul><h2 id="인터럽트-예시-divide-by-zero"><a href="#인터럽트-예시-divide-by-zero" class="headerlink" title="인터럽트 예시 (divide by zero)"></a>인터럽트 예시 (divide by zero)</h2><ul><li>zero.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include &lt;studio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="keyword">int</span> divider =<span class="number">0</span>;</span><br><span class="line">  data = <span class="number">1</span> /divider; <span class="comment">// 0 으로 나눌 수 없음.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>cmd<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./zero</span><br><span class="line">hello</span><br><span class="line">Floating pont exception (core dumped)</span><br></pre></td></tr></table></figure></li><li><code>Floating pont exception (core dumped)</code> : 운영체제가 발생시킨 인터럽트</li></ul><h2 id="인터럽트-처리"><a href="#인터럽트-처리" class="headerlink" title="인터럽트 처리"></a>인터럽트 처리</h2><ol><li>CPU 가 프로그램을 실행하고 있을때, 소프트웨어 혹은 하드웨어 인터럽트가 발생한다.</li><li>운영체제는 실행중이던 프로세스를 중단하고 인터럽트 처리 함수를 먼저 실행한다.</li><li>인터럽트 처리가 끝나면 운영체제에게 알린다.</li><li>중단되었던 프로세스가 재실행된다.</li></ol><h2 id="IDT-Interrupt-Descriptor-Table"><a href="#IDT-Interrupt-Descriptor-Table" class="headerlink" title="IDT (Interrupt Descriptor Table)"></a>IDT (Interrupt Descriptor Table)</h2><ul><li>IDT 는 인터럽트 번호마다 각 시스템콜함수 주소가 있는 테이블이다.</li><li>리눅스는 인터럽트 처리를 위해 IDT 를 사용한다.</li></ul><br><p><img src="https://user-images.githubusercontent.com/28856435/117398693-d2d36c80-af39-11eb-921a-73415d97aacd.jpg" alt="idt"></p><h2 id="시스템콜-인터럽트"><a href="#시스템콜-인터럽트" class="headerlink" title="시스템콜 인터럽트"></a>시스템콜 인터럽트</h2><ul><li>시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU 가 수행할 수 있도록 해야한다.</li><li>시스템콜 인터럽트는 아래와 같이 어셈블리어 3줄로 표현된다.</li></ul><p>[Assembly Code]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">1</span></span><br><span class="line">mov ebx, <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><ul><li>eax (Exended Accumaltor Register) : Arithmetic Logic Operation 수행 및 함수의 반환값이 저장.</li><li>systemcall number 저장됨.</li><li>ebx (Extended Base Register) : 메모리 주소를 저장하기 위함.</li><li>systemcall argument 주소가 저장됨.</li><li>int 0X80 : 시스템콜의 Interurrpt Number, <int> 는 OP code.</li></ul><h2 id="시스템콜-인터럽트-처리"><a href="#시스템콜-인터럽트-처리" class="headerlink" title="시스템콜 인터럽트 처리"></a>시스템콜 인터럽트 처리</h2><ol><li>시스템콜 인터럽트 호출 (int 0X80)</li><li><code>User Mode =&gt; Kernel Mode 전환</code></li><li>IDT 참조, 0X80 에 매핑된 system_call() 주소로 이동.<table><thead><tr><th>interrupt</th><th>excution Code</th></tr></thead><tbody><tr><td>0X0</td><td>device_error()</td></tr><tr><td>…</td><td>…</td></tr><tr><td>0X80</td><td>system_cala()</td></tr></tbody></table></li></ol><br><ol start="4"><li>systemCall 테이블 참조<table><thead><tr><th>%eax</th><th>name</th><th>source</th><th>%ebx</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td>kernel/exit.c</td><td>int</td></tr><tr><td>2</td><td>sys_fork</td><td>arch/i386/kernel/process.c</td><td>struct_pt_regs</td></tr><tr><td>3</td><td>sys_read</td><td>fs/read_write.c</td><td>unsigned int</td></tr><tr><td>4</td><td>sys_write</td><td>fs/read_write.c</td><td>unsigned int</td></tr><tr><td>5</td><td>sys_open</td><td>fs/open.c</td><td>const char*</td></tr><tr><td>6</td><td>sys_close</td><td>fs/close.c</td><td>unsigned int</td></tr></tbody></table></li></ol><br><ol start="5"><li><code>Kernel Mode =&gt; User Mode 전환</code></li><li>프로세스 재진행</li></ol><blockquote><p><strong>IDT vs IVT ?</strong></p><ol><li>프로세서에서 인터럽트가 걸렸을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소-인터럽트 핸들러 주소가 저장되어 있는 <code>IVT (interrupt vector)</code> 인터럽트 벡터 테이블을 보고 결정한다.</li><li>IVT는 <code>real mode</code>에서, IDT는 <code>protected mode</code>에서 사용된다.</li></ol><ul><li>real mode 부팅 직후 작동되는 모드로 <code>물리 메모리</code>를 그대로 사용합니다.</li><li>protected mode는 <code>가상 메모리</code>를 지원하는 모드입니다.</li></ul><ol start="3"><li>최근 OS는 모두 protected mode를 기반으로 실행되어 IDT를 사용합니다.</li><li>IDT <code>interrupt descriptor table</code> 는 IVT <code>interrupt vector table</code> 을 구현하기 위해 X86 아키텍처에서 사용되는 데이터 구조체이다.</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;인터럽트는 무엇이고 어떻게 처리될까?&lt;br&gt;&lt;code&gt;#interrupt&lt;/code&gt; &lt;code&gt;#IDT&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>🙋‍♀️ 선점형 vs 비선점형</title>
    <link href="http://yoursite.com/2021/05/06/%EC%84%A0%EC%A0%90%ED%98%95vs%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95/"/>
    <id>http://yoursite.com/2021/05/06/%EC%84%A0%EC%A0%90%ED%98%95vs%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95/</id>
    <published>2021-05-06T14:41:43.000Z</published>
    <updated>2021-05-11T01:52:08.019Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h2 id="선점형-스케줄링-vs-비선점형-스케줄링"><a href="#선점형-스케줄링-vs-비선점형-스케줄링" class="headerlink" title="선점형 스케줄링 vs 비선점형 스케줄링"></a>선점형 스케줄링 vs 비선점형 스케줄링</h2><blockquote><p>기존에는 비선점형 스케줄러가 기본이었다. 선점형 스케줄러를 지원하는 운영체제, 그러지 못한 운영체제가 있었다.<br>현재, 시분할 시스템에서 선점형 스케줄러는 당연히 선행되는 개념이다.</p></blockquote><ul><li><strong>선점형 (Preemptive Scheduling)</strong><br>: 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음</li><li>blocking 상태나 종료된 상태가 아니더라도 프로세스 <code>running 중</code>에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체 가능.</li><li>각 프로세스 응답시간 단축효과가 있지만 우선순위가 높은 프로세스들이 반복적으로 들어오는 경우 오버헤드를 초래할 수 있다.</li><li>대표적 스케줄링 기법 <ul><li>Round Robin Schedling</li></ul></li><li><strong>비선점형 (Non-Preemptive Scheduling)</strong><br>: 하나의 프로세스가 끝나지 않으면 다른 프로세스는 프로세서(CPU)를 차지할 수 없음</li><li>프로세스가 자발적으로 <code>blocking 상태</code>로 들어가거나 실행이 <code>종료된 상태일때만</code> 다른 프로세스로 교체 가능.</li><li>대표적 스케줄링 기법 <ul><li>FIFO(FCFS), SJF, Priority-based</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;선점형, 비선점형 무슨 차이일까?&lt;br&gt;&lt;code&gt;#preemptive&lt;/code&gt; &lt;code&gt;#non_preemptive&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="scheduler" scheme="http://yoursite.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>✅ 프로세스 상태 기반 스케줄링</title>
    <link href="http://yoursite.com/2021/05/05/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C%EC%99%80_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"/>
    <id>http://yoursite.com/2021/05/05/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C%EC%99%80_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</id>
    <published>2021-05-05T11:40:25.000Z</published>
    <updated>2021-05-12T08:45:31.488Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h2 id="멀티-프로그래밍과-Wait"><a href="#멀티-프로그래밍과-Wait" class="headerlink" title="멀티 프로그래밍과 Wait"></a>멀티 프로그래밍과 Wait</h2><ul><li>멀티 프로그래밍 : CPU 활용도를 극대화하는 스케줄링 알고리즘</li><li>Wait : 예를 들면 I/O 장치나 저장매체로부터 파일 읽기를 기다리는 시간.</li></ul><h2 id="프로세스-상태기반-알고리즘"><a href="#프로세스-상태기반-알고리즘" class="headerlink" title="프로세스 상태기반 알고리즘"></a>프로세스 상태기반 알고리즘</h2><ul><li>여러 프로그램을 스케줄링 할 때 어떤 프로세스를 CPU 에 던져줄지 정하기위해 프로세스 상태를 확인한다.</li><li>프로세스 상태 큐</li><li>Raady State Queue</li><li>Raady State Queue</li><li>Raady State Queue</li><li>프로세스 주요 상태 (실제로는 더 세세하게 쪼개놓았다고 한다.)</li><li><strong>ready state</strong> : CPU 에서 실행 가능상태 (실행 대기)</li><li><strong>running state</strong> : 현재 CPU 에서 실행 상태</li><li><strong>block state</strong> = <code>wait</code> : 특정 이벤트 발생 대기 상태 (eg. 저장매체에서 파일읽기가 종료되기를 기다리는 시간)</li><li><strong>idle state</strong> : CPU 가 활용되지 않는 상태 (모든 프로세스 wait)</li></ul><h3 id="프로세스-상태-관계"><a href="#프로세스-상태-관계" class="headerlink" title="프로세스 상태 관계"></a>프로세스 상태 관계</h3><ul><li>raady, running, block states</li></ul><table><thead><tr><th>상태</th><th>설명</th></tr></thead><tbody><tr><td>Running -&gt; Block</td><td>Process blocks for input (특정 이벤트 대기)</td></tr><tr><td>Block -&gt; Ready</td><td>Process becomes available</td></tr><tr><td>Ready -&gt; Running</td><td>Scheduler picks another process</td></tr><tr><td>Running -&gt; Ready</td><td>Scheduler picks this process</td></tr></tbody></table><br><h3 id="프로세스-상태기반-알고리즘-예시"><a href="#프로세스-상태기반-알고리즘-예시" class="headerlink" title="프로세스 상태기반 알고리즘 예시"></a>프로세스 상태기반 알고리즘 예시</h3><blockquote><p>아래 그림이 조금 혼란스러울 수 있지만, 한 칸을 1초 라고 가정하여 상태기반 알고리즘이이 어떻게 수행되는지 순차적으로 그려보았다.<br>각 프로그램이 수행할 프로세스는 Queue 로 설명된다.<br><code>FIFO</code> 기법에 따라 순차적으로 <code>pop()</code> 되어 CPU 로 넘어간다. 그 프로세스는 <code>running</code> 상태.<br>해당 프로세스가 <code>wait</code> 라면 <code>block</code> 상태. 작업을 마친 프로세스는 종료되고, 남아있다면 다시 <code>ready</code> 로 넘어간다.<br>수행해야할 프로세스가 남아있지만, 해당 시간에 수행될 프로세스가 없다면, (모두 <code>block</code> 상태) 그 때 CPU 는 <code>Idle</code> 상태이다.</p></blockquote><p><img src="https://user-images.githubusercontent.com/28856435/117147563-541ee800-adf0-11eb-95f2-40182e617062.png" alt="image"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;프로세스 주요 상태와 프로세스 상태에 따른 스케줄링 기법.&lt;br&gt;&lt;code&gt;#algorithm_by&lt;/code&gt; &lt;code&gt;#process_state&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>✅ 스케줄링 알고리즘</title>
    <link href="http://yoursite.com/2021/05/04/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    <id>http://yoursite.com/2021/05/04/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</id>
    <published>2021-05-04T14:40:25.000Z</published>
    <updated>2021-05-11T01:52:08.020Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="스케줄링-알고리즘"><a href="#스케줄링-알고리즘" class="headerlink" title="스케줄링 알고리즘"></a>스케줄링 알고리즘</h1><blockquote><p>어느 순서대로 프로세스를 실행할까?</p></blockquote><ul><li>목표<ul><li>시분할 시스템: 프로세스 응답시간을 최소화.</li><li>멀티 프로그래밍: CPU 활용도를 높여서 프로세스를 빨리 실행</li></ul></li></ul><br><h2 id="프로세스-Process"><a href="#프로세스-Process" class="headerlink" title="프로세스? (Process)"></a>프로세스? (Process)</h2><ul><li><code>메모리</code>에 올려져서 실행중인 프로그램을 의미한다. : <code>폰노이만</code> 구조</li><li>작업, task, job 이라는 용어롸 혼용</li><li>응용 프로그램 != 프로세스</li><li>하나의 응용 프로그램은 여러개의 프로세스로가 상호작용하며 실행 할 수 있다.</li><li>간단한 C/C++ 프로그램을 만든다면 ?</li><li>하나의 프로세스를 갖는 여러 프로그램을 만들어, 서로 통신하며 프로그램을 작성 하는 방법도 있다. (IPC 기법)</li></ul><h2 id="스케줄러와-프로세스"><a href="#스케줄러와-프로세스" class="headerlink" title="스케줄러와 프로세스"></a>스케줄러와 프로세스</h2><blockquote><p><code>스케줄러</code>는 <code>프로세스 실행</code>을 관리한다.</p></blockquote><hr><h2 id="FIFO-스케줄러"><a href="#FIFO-스케줄러" class="headerlink" title="FIFO 스케줄러"></a>FIFO 스케줄러</h2><blockquote><p>프로세스가 저장매체를 읽거나 프린팅하는 작업 없이 CPU(프로세서)를 온전히 사용.</p></blockquote><ul><li>가장 간단한 스케줄러 (배치처리 시스템)</li><li>=FCFS (First Come First Served)</li></ul><h2 id="우선순위-기반-SJF-스케줄러"><a href="#우선순위-기반-SJF-스케줄러" class="headerlink" title="우선순위 기반 (SJF) 스케줄러"></a>우선순위 기반 (SJF) 스케줄러</h2><ul><li>SJF (Shortest Job First)</li><li>수행시간이 가장 짧은 작업부터 처리</li></ul><h2 id="Priority-Based-스케줄러"><a href="#Priority-Based-스케줄러" class="headerlink" title="Priority-Based 스케줄러"></a>Priority-Based 스케줄러</h2><ul><li>정적 우선순위 : 프로세스마다 우선순위를 미리 지정</li><li>동적 우선순위 : 스케줄러가 상황에 따라 우선순위를 동적으로 변경</li><li><code>Procss</code> [3(10), 2(20), 2(20), 2(20), 1(1)]<br>(괄호안 숫자는 미리 정한 우선순위)</li><li><code>CPU</code> 처리 순서</li><li>2 <strong>(20)</strong> -&gt; 2 <strong>(20)</strong> -&gt; 2 <strong>(20)</strong> -&gt; 3 <strong>(10)</strong> -&gt; 1 <strong>(1)</strong></li></ul><h2 id="Round-Robin-스케줄러"><a href="#Round-Robin-스케줄러" class="headerlink" title="Round Robin 스케줄러"></a>Round Robin 스케줄러</h2><ul><li>RR이라고 이야기 하기도 한다.</li><li>시분할 시스템을 위해 설계된 스케줄링 중 하나이며</li><li>프로세스들의 우선순위를 신경쓰지 않습니다.</li><li>다만 시분할 시스템처럼 최초 요청부터 순서대로 프로세서들에게 일정한 시간단위로 공평하게 CPU를 할당.</li><li>순서대로 공평하게 CPU를 할당해주기 때문에 그 시간에 프로세스가 완료되지 않을 경우 다시 뒤로 배치가 되서 차례를 기다린다.</li><li><code>Process</code> [3, 3, 2, 2, 2, 1]<table><thead><tr><th>RR Ready Queue</th><th>CPU</th></tr></thead><tbody><tr><td>[3, 2, 1]</td><td>[1]</td></tr><tr><td>[3, 2]</td><td>[1, 2]</td></tr><tr><td>[2, 3]</td><td>[1, 2, 3]</td></tr><tr><td>[3, 2]</td><td>[1, 2, 3, 2]</td></tr><tr><td>[2, 3]</td><td>[1, 2, 3, 2, 3]</td></tr><tr><td>[2]</td><td>[1, 2, 3, 2, 3, 2]</td></tr></tbody></table></li></ul><hr><br><h1 id="RTOS-VS-GPOS"><a href="#RTOS-VS-GPOS" class="headerlink" title="[+] RTOS VS GPOS"></a>[+] RTOS VS GPOS</h1><ul><li><code>General Purpose OS</code> (GPOS):</li></ul><ul><li>프로세스 실행시간에 민감하지 않고, 일반적으로 사용되는 OS : Windows, Linux</li></ul><ul><li><code>RealTime OS</code> (RTOS): 응용 프로그램 실시간 성능 보장을 목표로 하는 OS</li></ul><ul><li>정확하게 프로그램 시작, 완료시간을 보장</li><li>Hardware RTOS, Software RTOS</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;스케줄링 알고리즘의 기본 종류와 사용.&lt;br&gt;&lt;code&gt;scheduling_algorithm&lt;/code&gt; &lt;code&gt;FIFO&lt;/code&gt; &lt;code&gt;SJF&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>🔅 운영체제의 역할 (2)</title>
    <link href="http://yoursite.com/2021/05/04/%EC%BB%B4%EA%B3%B5-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%AC%EC%A1%B0/"/>
    <id>http://yoursite.com/2021/05/04/%EC%BB%B4%EA%B3%B5-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%AC%EC%A1%B0/</id>
    <published>2021-05-04T14:37:51.000Z</published>
    <updated>2021-05-12T08:43:56.666Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="응용프로그램이란"><a href="#응용프로그램이란" class="headerlink" title="응용프로그램이란?"></a><strong>응용프로그램이란?</strong></h1><ul><li>프로그램 = 소프트웨어</li><li>소프트웨어 = 운영체제(시스템 소프트웨어), 응용프로그램 (엑셀, 파워포인트 등)</li><li>응용 프로그램 = Application = App</li></ul><h2 id="운영체제와-응용-프로그램간의-관계"><a href="#운영체제와-응용-프로그램간의-관계" class="headerlink" title="운영체제와 응용 프로그램간의 관계"></a>운영체제와 응용 프로그램간의 관계</h2><ul><li>운영체제는 하드웨어 시스템 자원(System Reource)를 관리</li><li>응용체제는 시스템 소프트웨어이다.</li><li>사용자와 컴퓨터 간의 커뮤니케이션 지원</li><li>운영체제는 응용 프로그램을 관리</li></ul><ul><li>응용 프로그램을 실행시킨다.</li><li>응용 프로그램간의 <code>권한</code>을 관리</li><li>응용 프로그램을 사용하는 <code>사용자</code> 관리</li></ul><ul><li>특정 응용프로그램이 하드웨어 자원을 독점하여 사용하는 것을 막는다.</li><li>응용 프로그램은 누구나 만들 수 있다. 즉, 운영체제는 비정상적으로 작동하는 프로그램을 제어한다.</li></ul><ul><li>응용프로그램에 무한 반복문을 넣을경우.</li><li>응용 프로그램을 잘못 작성되어 프로그램 다운될 경우.</li><li>모든 파일이 삭제되는 코드가 사용될 경우. (권한/사용자 관리)</li></ul><blockquote><p>운영체제의 목표 ?<br>사용자가 실행하는 응용프로그램이 적절하게 동작하도록 지원.<br>응용프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고 지원하는 소프트웨어.</p></blockquote><hr><h2 id="운영체제는-어디에"><a href="#운영체제는-어디에" class="headerlink" title="운영체제는 어디에 ?"></a>운영체제는 어디에 ?</h2><ul><li>운영체제는 저장매체(SSD/HDD) 에 저장 된다.</li></ul><h2 id="컴퓨터를-키면"><a href="#컴퓨터를-키면" class="headerlink" title="컴퓨터를 키면?"></a>컴퓨터를 키면?</h2><ul><li>폰노이만 구조 : 모든 프로그램은 Memory 에 올라가게 된다. 하나씩 CPU 에 전달되면서 실행된다.</li></ul><br><h2 id="운영체제의-핵심-구조"><a href="#운영체제의-핵심-구조" class="headerlink" title="운영체제의 핵심 구조"></a>운영체제의 핵심 구조</h2><img  width="30%" src="https://user-images.githubusercontent.com/28856435/116893302-c619f480-ac6b-11eb-8849-f66627c325c5.jpg"><hr><br><h1 id="CPU-Protection-Rings"><a href="#CPU-Protection-Rings" class="headerlink" title="CPU Protection Rings"></a><strong>CPU Protection Rings</strong></h1><img width="400px" src="https://user-images.githubusercontent.com/28856435/117016719-f1651800-ad2d-11eb-88cc-571744d15042.png"/><br><ul><li>CPU의 두 가지 권한모드</li><li>사용자 모드 (user mode) : 응용 프로그램이 사용</li><li>커널 모드 (kernel mode) : OS가 사용, 특권 명령어와 작업 수행을 위한 자원에 접근가능.</li><li>Ring 0 (Kernal) ~ Ring 3 (user)</li></ul><h2 id="응용-프로그램과-운영체제"><a href="#응용-프로그램과-운영체제" class="headerlink" title="응용 프로그램과 운영체제"></a>응용 프로그램과 운영체제</h2><ul><li>우리가 만드는 프로그램은</li><li><code>사용자 영역</code> 에서 동작하기도하고 <code>커널 영역</code>(System Call 하위)에서 동작하기도 한다.<br>즉, 운영체제의 특권을 가지고 명령 및 작업을 수행한다.</li></ul><h2 id="시스템콜과-커널모드"><a href="#시스템콜과-커널모드" class="headerlink" title="시스템콜과 커널모드"></a>시스템콜과 커널모드</h2><ul><li>커널 모드에서만 실행가능한 기능들이 있다.</li><li>커널모드로 가려면 반드시 시스템콜을 거쳐야함.</li><li>시스템콜은 운영체제를 제공한다.</li></ul><h2 id="사용자-모드와-커널모드"><a href="#사용자-모드와-커널모드" class="headerlink" title="사용자 모드와 커널모드"></a>사용자 모드와 커널모드</h2><ul><li>응용프로그램이 전체 컴퓨터 시스템을 해지지 못함.</li><li>eg. 사용자모드(사용자) - 커널모드(은행)</li><li>사용자가 은행에 계좌 생성을 요청하면, 은행의 특별한 권한으로 해당 사용자의 계좌를 만들어줌.</li></ul><h2 id="응용-프로그래머-VS-시스템-프로그래머"><a href="#응용-프로그래머-VS-시스템-프로그래머" class="headerlink" title="응용 프로그래머 VS 시스템 프로그래머"></a>응용 프로그래머 VS 시스템 프로그래머</h2><ul><li>응용 프로그래머 : API (응용 프로그램) 사용자 프로그램</li><li>시스템 프로그래머 : 운영체제 및 시스템 프로그램, 하드웨어</li></ul><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><ul><li>운영체제의 역할? <code>응용 프로그램 관리</code>, <code>시스템 자원 효율적 분배</code>.</li><li>응용 프로그램이란? 소프트웨어 (운영체제, 응용 프로그램)</li><li>운영체제는 <code>시스템콜</code> 제공</li><li>프로그래밍 언어별로 OS 기능을 활용하기 위해 시스템콜을 기반으로 API 제공</li><li>응용 프로그램이 필요로하는 자원을 제공하는 소프트웨어</li></ul><blockquote><p>응용 프로그램이 실행되어 운영체제 기능이 필요하면 시스템콜을 호출 하여 커널모드로 변경되어 OS 내부에서 해당 명령이 수행되고, 다시 사용자모드, 응용프로그램으로 돌아간다.</p></blockquote><h2 id="용어의미"><a href="#용어의미" class="headerlink" title="용어의미"></a>용어의미</h2><ul><li>kernel (OS kernel : OS 본연의 기능)</li><li>(견과류) 알맹이</li><li>핵심</li><li>shell</li><li>(달걀, 견과류 등의) 껍데기</li><li>고동 껍데기</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;컴공 따라잡기 with fastCampus&lt;br&gt;운영체제의 역할부터 사용자가 어떻게 요청할 수 있는것인지 간단한 구조까지.&lt;br&gt;+커널모드와 사용자모드&lt;br&gt;&lt;code&gt;#kernal&lt;/code&gt; &lt;code&gt;#CPU_protect_rings&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>〰️ 운영체제의 스케줄링 기법</title>
    <link href="http://yoursite.com/2021/05/04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"/>
    <id>http://yoursite.com/2021/05/04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</id>
    <published>2021-05-04T13:23:32.000Z</published>
    <updated>2021-05-12T08:43:45.345Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h1 id="프로세스-스케줄링"><a href="#프로세스-스케줄링" class="headerlink" title="프로세스 스케줄링"></a>프로세스 스케줄링</h1><ul><li>배치 처리시스템</li><li>시분할 시스템</li><li>멀티 태스킹</li></ul><br><h2 id="배치처리-시스템"><a href="#배치처리-시스템" class="headerlink" title="배치처리 시스템"></a>배치처리 시스템</h2><ul><li>여러 응용 프로그램들이 순차적으로 자동 실행되도록 하는 시스템</li><li>문제점</li><li>시간이 긴 응용프로그램이 수행중일 경우 다음 프로그램 수행까지 많은 시간을 대기해야함. (응답시간 증가)</li><li>동시에 여러 작업을 할 수 없음. (동시성X)</li><li>다중 사용자를 지원해주지 않음. (다중성X)</li></ul><br><h2 id="시분할-시스템"><a href="#시분할-시스템" class="headerlink" title="시분할 시스템"></a>시분할 시스템</h2><ul><li>다중 사용자 지원을 위해 컴퓨터 응답시간을 최소화</li></ul><br><h2 id="멀티-태스킹"><a href="#멀티-태스킹" class="headerlink" title="멀티 태스킹"></a>멀티 태스킹</h2><ul><li>단일 CPU 에서 여러 응용 프로그램이 동시에 실행되는 것 <code>처럼</code> 보이도록 함.</li></ul><h2 id="실제-멀티-태스킹은-어떻게"><a href="#실제-멀티-태스킹은-어떻게" class="headerlink" title="실제 멀티 태스킹은 어떻게?"></a>실제 멀티 태스킹은 어떻게?</h2><ul><li>1000 ms = 1s</li><li>10~20 ms 단위로 실행 응용 프로그램이 바뀐다.</li><li>사용자는 동시에 실행되는 것 처럼 느낀다.</li></ul><br><h2 id="멀티-태스킹과-멀티-프로세싱"><a href="#멀티-태스킹과-멀티-프로세싱" class="headerlink" title="멀티 태스킹과 멀티 프로세싱"></a>멀티 태스킹과 멀티 프로세싱</h2><ul><li>멀티 태스킹 : <code>단일</code> CPU</li><li>멀티 프로세싱 : 하나의 응용프로그램을 <code>여러</code> CPU에서 병렬로 처리함으로써 <code>실행속도</code>를 극대화 한다.</li></ul><br><h2 id="멀티-프로그래밍"><a href="#멀티-프로그래밍" class="headerlink" title="멀티 프로그래밍"></a>멀티 프로그래밍</h2><ul><li>최대한 CPU 를 많이 활용하도록 하는 시스템</li><li>시간 대비 <code>CPU 활용도</code> 높임.</li><li>응용 프로그램을 짧은 시간 안에 실행완료 시킬 수 있음.</li></ul><blockquote><p>응용 프로그램은 CPU 만 온전히 쓰는것이 아니다.</p><ul><li>응용 프로그램 실행 중 파일을 읽는다.</li><li>응용 프로그램이 실행되다가 프린팅을 한다.</li></ul></blockquote><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><blockquote><p>실제로는 시분할 시스템, 멀티 프로그래밍, 멀티 태스킹이 유사한 의미로 통용된다.</p></blockquote><ul><li>배치 처리 시스템</li><li>시분할 시스템 (다중사용자 지원, 응답시간 최소화)</li><li>멀티 태스킹 (동시 실행되는것 처럼 보임)</li><li>멀티 프로세싱 (여러 CPU 가 하나의 프로그램을 병렬로 처리)</li><li>멀티 프로그래밍 : 시간대비 CPU 활용도를 최대한으로 높임.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;세 가지 프로세스 스케줄링 기법을 배운다.&lt;br&gt;&lt;code&gt;#batch&lt;/code&gt; &lt;code&gt;#multi_tasking&lt;/code&gt; &lt;code&gt;#time_sharing&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
    <category term="scheduling" scheme="http://yoursite.com/tags/scheduling/"/>
    
  </entry>
  
  <entry>
    <title>🔅 운영체제의 역할 (1)</title>
    <link href="http://yoursite.com/2021/05/03/%EC%BB%B4%EA%B3%B5-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0/"/>
    <id>http://yoursite.com/2021/05/03/%EC%BB%B4%EA%B3%B5-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0/</id>
    <published>2021-05-03T14:14:00.000Z</published>
    <updated>2021-05-12T08:44:18.454Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p><em>💬 해당 강의는 fastcampus 에서 ‘컴공 전공자 따라잡기 온라인 완주반’ 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.</em></p><br><h2 id="운영체제-역할"><a href="#운영체제-역할" class="headerlink" title="운영체제 역할"></a>운영체제 역할</h2><h3 id="1-시스템-자원-관리자-System-Resource"><a href="#1-시스템-자원-관리자-System-Resource" class="headerlink" title="1) 시스템 자원 관리자 (System Resource)"></a>1) 시스템 자원 관리자 (System Resource)</h3><ul><li>Operating System , OS.</li></ul><ul><li>CPU(중앙처리장치), Memory(DRAM,RAM)</li><li>I/O Devices(입출력장치)</li><li>Monitor, Mouse, Keyboard, Network</li><li>저장매체 : SSD, HDD (하드디스크)</li></ul><blockquote><p>컴퓨터 하드웨어는 스스로 할 수 있는것이 없다.</p></blockquote><ol><li>CPU : 스스로 용량을 얼마나 사용할지 결정못함.</li><li>Memory : 각 프로그램이 어느 주소에 저장되어야 하는지, 확보할 메모리공간을 자체적으로 결정 못함.</li><li>저장매체(HDD, SSD) : how, where? 저장할지 모름,</li><li>키보드/마우스 : 스스로 표시불가.</li></ol><blockquote><p>즉, OS 없이는 컴퓨터는 동작하지 않는다.<br>How did we ever run Computer without OS?</p></blockquote><h3 id="2-사용자와-컴퓨터간의-커뮤니케이션-지원"><a href="#2-사용자와-컴퓨터간의-커뮤니케이션-지원" class="headerlink" title="2) 사용자와 컴퓨터간의 커뮤니케이션 지원"></a>2) 사용자와 컴퓨터간의 커뮤니케이션 지원</h3><h3 id="3-컴퓨터-하드웨어와-응용프로그램의-제어"><a href="#3-컴퓨터-하드웨어와-응용프로그램의-제어" class="headerlink" title="3) 컴퓨터 하드웨어와 응용프로그램의 제어"></a>3) 컴퓨터 하드웨어와 응용프로그램의 제어</h3><br><h2 id="대표적인-운영체제"><a href="#대표적인-운영체제" class="headerlink" title="대표적인 운영체제"></a>대표적인 운영체제</h2><ul><li>Windows OS, Mac OS, UNIX</li><li>UNIX OS</li><li>UNIX 계열 OS</li><li>UNIX 와 사용법이나, OS와 구조가 유사 (가장 대표적으로 LINUX)</li><li>LINUX OS</li></ul><hr><h2 id="도서관으로-비유"><a href="#도서관으로-비유" class="headerlink" title="도서관으로 비유"></a>도서관으로 비유</h2><p>운영체제 -도서관<br>응용프로그램 - 시민<br>컴퓨터 하드웨어 - 책<br>운영체제의 역할</p><ul><li>시민은 도서관에 원하는 책(자원) 요청</li><li>도서관은 적절한 책(자원)을 찾아서 제공</li><li>기한이 다 되면, 도서관이 책(자원)을 회수.</li></ul><hr><br><h2 id="응용-프로그램-운영체제-컴퓨터-하드웨어의-관계"><a href="#응용-프로그램-운영체제-컴퓨터-하드웨어의-관계" class="headerlink" title="응용 프로그램, 운영체제, 컴퓨터 하드웨어의 관계"></a>응용 프로그램, 운영체제, 컴퓨터 하드웨어의 관계</h2><ul><li>운영체제는 응용프로그램이 요청하는 메모리를 허가 및 분배.</li><li>운영체제는 응용프로그램이 요청하는 CPU 시간을 제공</li><li>운영체제는 응용 프로그래밈이 요청하는 IO Devices 사용을 허가</li></ul><blockquote><p>User&lt;-&gt;Application&lt;-&gt;OS&lt;-&gt;Hardware</p></blockquote><h2 id="운영체제는-사용자-인터페이스-제공"><a href="#운영체제는-사용자-인터페이스-제공" class="headerlink" title="운영체제는 사용자 인터페이스 제공"></a>운영체제는 사용자 인터페이스 제공</h2><ul><li>쉘 (Shell)</li><li>사용자가 운영체제 기능, 서비스 조작 가능하게 인터페이스 제공. 쉘도 하나의 응용프로그램.</li><li>터미널환경(CUI)과 GUI 환경 제공</li></ul><h2 id="운영체제는-응용-프로그램을-위해서도-인터페이스를-제공한다"><a href="#운영체제는-응용-프로그램을-위해서도-인터페이스를-제공한다" class="headerlink" title="운영체제는 응용 프로그램을 위해서도 인터페이스를 제공한다"></a>운영체제는 응용 프로그램을 위해서도 인터페이스를 제공한다</h2><ul><li>API (Application Programming Interface)</li><li>함수로 제공</li><li>eg. open()</li><li>보통은 라이브러리 형태로 제공</li><li>C library</li></ul><h3 id="시스템-콜-System-Call"><a href="#시스템-콜-System-Call" class="headerlink" title="시스템 콜 (System Call)"></a>시스템 콜 (System Call)</h3><ul><li>운영체제 기능을 호출하는 함수</li><li>운영체제가 운영체제의 각 기능을 사용할 수 있도록 시스템 콜이라는 명령, 함수 제공</li><li>상위 API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분.<br>eg. POSIX API(유닉스/리눅스), 윈도우API</li></ul><blockquote><p>운영체제는 사용자든, 응용프로그램이든 외부에서 요청하면 시스템콜을 제공한다. 운영체제 입장에서의 기능을 정의해놓은 것이 시스템콜(System Call)이기 때문에 프로그래머 입장에서 좀더 쉽게 사용할 수 있도록 Library or API 를 제공한다. 이것을 기반으로 해서 Application 이나 shell 을 만드는것이고 이를 사용자가 사용할 수 있는 것이다.<br>응용 프로그램은 라이브러리를 사용하고, 라이브러리는 시스템 자원이 필요할 경우, 내부적으로 시스템 콜을 호출할 수 있다.</p></blockquote><hr><br><h2 id="운영체제를-만든다면"><a href="#운영체제를-만든다면" class="headerlink" title="운영체제를 만든다면?"></a>운영체제를 만든다면?</h2><ol><li>운영체제를 개발한다. (kernal)</li><li>시스템 콜을 개발</li><li>C API (Library) 개발</li><li>Shell 프로그램 개발</li></ol><h2 id="운영체제-amp-시스템콜-amp-API"><a href="#운영체제-amp-시스템콜-amp-API" class="headerlink" title="운영체제 &amp; 시스템콜 &amp; API"></a>운영체제 &amp; 시스템콜 &amp; API</h2><ul><li>API : 각 언어별 운영체제 기능 호출 인터페이스 함수. (각 언어별 인터페이스)</li><li>SystemCall : 운영체제 기능을 호출하는 함수</li></ul><br><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><ul><li>운영체제는 컴퓨터 하드웨어와 응용프로그램을 관리한다.</li><li>사용자 인터페이스 제공을 위해 쉘 프로그램을 제공한다.</li><li>응용프로그램은 운영체제 기능을 요청하기 위해 운영체제의 시스템콜을 사용한다.<ul><li>보통 시스템콜을 직접 사용하기보다는 해당 시스템콜을 사용해서 만든 각 언어별 라이브러리(API)를 사용한다.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;컴공 따라잡기 with fastCampus&lt;br&gt;운영체제의 역할부터 사용자가 어떻게 요청할 수 있는것인지 간단한 구조까지.&lt;br&gt;&lt;code&gt;#OS&lt;/code&gt; &lt;code&gt;#system_resource&lt;/code&gt; &lt;code&gt;#system_call&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ OS" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-OS/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Servlet 정의와 생명주기, Servlet 컨테이너</title>
    <link href="http://yoursite.com/2021/04/30/Servlet/"/>
    <id>http://yoursite.com/2021/04/30/Servlet/</id>
    <published>2021-04-30T01:26:43.000Z</published>
    <updated>2021-05-11T01:52:08.015Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><p>요즘 당연하게 생각하고 사용해왔던 개념, 기능들을 찾아보며 정리중이다.<br>Java, RESTful API 개발을 하고 있지만, 내부적으로 어떻게 돌아가는지 개념적인 부분을 다시 한번 짚고자 한다.</p><h3 id="Servlet-이란"><a href="#Servlet-이란" class="headerlink" title="Servlet 이란?"></a>Servlet 이란?</h3><blockquote><p>서버사이드에서 클라이언트 요청을 처리하고 그 결과를 응답해주는 규칙.</p></blockquote><h4 id="Servlet-특징"><a href="#Servlet-특징" class="headerlink" title="Servlet 특징"></a>Servlet 특징</h4><ul><li>동적 웹페이지를 작성하기 위해 나왔다.</li><li>서버쪽에서 실행되면서 클라이언트의 요청에 따라 동적으로 일을 처리하는 <code>자바 클래스</code> 이다.</li><li>Servlet</li></ul><h3 id="Servlet-컨테이너"><a href="#Servlet-컨테이너" class="headerlink" title="Servlet 컨테이너"></a>Servlet 컨테이너</h3><blockquote><p>Servlet 클래스로 작성된 프로그램을 실행하고, 관리해준다.</p></blockquote><h4 id="Servlet-컨테이너-역할"><a href="#Servlet-컨테이너-역할" class="headerlink" title="Servlet 컨테이너 역할"></a>Servlet 컨테이너 역할</h4><ul><li>웹서버와의 통신을 지원해준다. 서블릿 컨테이너는 소켓을 만들고  listen, accept 등의 기능을 api 로 제공하여 개발자가 비지니스 로직에만 집중할 수 있도록 해준다.</li><li>서블릿의 생명주기를 관리한다. 실행부터 종료까지. </li></ul><h3 id="Servlet-작동흐름"><a href="#Servlet-작동흐름" class="headerlink" title="Servlet 작동흐름"></a>Servlet 작동흐름</h3><blockquote><ol><li>클라이언트가 HTTP Request 를 Servlet Container 로 전송.</li><li>Servlet Container 는 HttpServletRequest, HttpServletResponse 두 객체 생성</li><li></li></ol></blockquote><h3 id="Servlet-생명주기"><a href="#Servlet-생명주기" class="headerlink" title="Servlet 생명주기"></a>Servlet 생명주기</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Servlet 개념 잡기 !&lt;br&gt;💬 &lt;em&gt;작성중&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ Java" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-Java/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Java Service &amp; ServiceImpl 국룰? 왜 이렇게 쓰지?</title>
    <link href="http://yoursite.com/2021/04/29/Service-ServiceImpl/"/>
    <id>http://yoursite.com/2021/04/29/Service-ServiceImpl/</id>
    <published>2021-04-29T13:28:01.000Z</published>
    <updated>2021-05-12T08:46:09.707Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><br><p>익히 경험한 Spring Boot Project 형식. MVC 구조이며 Service 와 DAO 를 인터페이스로 만들고 구현체는 따로 있다.<br>다른 기능이 생기면 Service 와 Dao 의 인터페이스를 생성하고 1:1로 구현체를 또 만들어낸다.<br>기존 샘플 코드들이 이렇게 되어있기에 그저 생각없이 만들어 썼는데, 이제서야 그 이유가 궁금해졌다.</p><br><h3 id="인터페이스-Interface"><a href="#인터페이스-Interface" class="headerlink" title="인터페이스 Interface"></a>인터페이스 Interface</h3><p>Service 로직은 Controller 에서 호출된다. 즉, Service 시점에서 보면 외부에서 어떤 <code>기능</code> 을 사용한다는 것이다.<br>사실, 코드도 하나의 <code>잘 만들어진 상품</code> 처럼 구현되어야 한다고 생각한다. 누구나 쉽게 이해할 수 있는건 물론이고, 구조와 기능이 잘 정리되어 있어야 한다. 그래서 Service 를 Interface 로 만들어, 해당 서비스에서 수행하는 기능들을 먼저 정의해둔 것이다. 또한, 이후에 같은 인터페이스를 갖는 구현체가 추가될지도 모르기 때문에 유지보수 측면에서 그 확장성을 열어두는 것 같다. 예를 들어 <code>Walking</code> 이라는 Interface 가 있다면, 각각 <code>Jhon</code>, <code>Dog</code> 라는 객체로 다르게 구현되어질 수 있다는 사실이다.</p><br><h3 id="단일책임의-원칙-SRP"><a href="#단일책임의-원칙-SRP" class="headerlink" title="단일책임의 원칙 SRP."></a>단일책임의 원칙 SRP.</h3><p>모을것은 모으고, 떼어버릴것은 떼어내자는, <code>SRP-단일책임의 원칙</code>(Single Responsibility Principle). 하나의 클래스는 하나의 책임만 가져야한다는 원칙이다.<br>즉, 클래스 간의 응집력은 커지고 결합도는 낮아져야 한다는 말이다.</p><blockquote><p>단일 책임 원칙을 지킨 경우에 클래스에 대한 외부 영향도를 최소화 할 수 있으며, 결국 유지보수나 확장 면에서 보다 효율적일 수 있다.</p></blockquote><br><h3 id="그러니까"><a href="#그러니까" class="headerlink" title="그러니까,"></a>그러니까,</h3><p>이미 우리가 잘 알고 있는 객체지향의 원리에서 비롯된 관습인듯하다. 원활한 유지보수가 가능한 ‘상품’ 을 만들어야 하기 때문에, 우리는 mvc 구조나 OOP 를 이용해 그 ‘상품’을 잘 설계되고 구조화된 코드로 제공한다. 이러한 것들을 준수하기 위해 Service 와 ServiceImpl 이 어느새 당연한 관습처럼 자리잡게 되어있는지 모른다.</p><br><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://doorbw.tistory.com/236">https://doorbw.tistory.com/236</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Service 를 인터페이스로 만드는 이유?&lt;br&gt;마치 국룰처럼 1:1로 만드는 이유가 무엇인지 생각해봤다.&lt;br&gt;&lt;code&gt;#java&lt;/code&gt; &lt;code&gt;#interface&lt;/code&gt; &lt;code&gt;#SRP&lt;/code&gt; &lt;code&gt;#OOP&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="mvc" scheme="http://yoursite.com/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>마크다운 유용한 문법</title>
    <link href="http://yoursite.com/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%AC%B8%EB%B2%95/"/>
    <id>http://yoursite.com/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%AC%B8%EB%B2%95/</id>
    <published>2021-04-27T16:28:21.000Z</published>
    <updated>2021-04-28T06:21:58.254Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><br><h2 id="🧐-마크다운-공백-만들기"><a href="#🧐-마크다운-공백-만들기" class="headerlink" title="🧐 마크다운 공백 만들기"></a>🧐 마크다운 공백 만들기</h2><br><h4 id="HTML-특수코드-nbsp"><a href="#HTML-특수코드-nbsp" class="headerlink" title="HTML 특수코드 &nbsp;"></a>HTML 특수코드 &nbsp;</h4><p>nbsp 의 약자는 <code>Non-breaking-space</code> 로, 입력한 만큼 공백이 생성.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">띄어쓰기 여러번 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 시도</span><br></pre></td></tr></table></figure><ul><li>띄어쓰기 여러번 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 시도</li></ul><br><h4 id="전각"><a href="#전각" class="headerlink" title="전각"></a>전각</h4><p>아래 대괄호 안의 전각(2바이트)을 복사해서 사용하면 한번에 큰 공백을 만들 수 있다.<br>[　]</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">공백　공백</span><br></pre></td></tr></table></figure><ul><li>공백 　　공백</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;마크다운(Markdown) 유용한 문법 Continuous Updating&lt;br&gt;&lt;code&gt;#마크다운&lt;/code&gt; &lt;code&gt;#공백&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="☁️ TIL" scheme="http://yoursite.com/categories/%E2%98%81%EF%B8%8F-TIL/"/>
    
    
  </entry>
  
</feed>
